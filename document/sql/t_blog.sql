/*
 Navicat Premium Data Transfer

 Source Server         : localhost
 Source Server Type    : MySQL
 Source Server Version : 80023
 Source Host           : localhost:3306
 Source Schema         : mogu_blog

 Target Server Type    : MySQL
 Target Server Version : 80023
 File Encoding         : 65001

 Date: 21/12/2022 16:49:00
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_blog
-- ----------------------------
DROP TABLE IF EXISTS `t_blog`;
CREATE TABLE `t_blog`  (
  `uid` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '唯一uid',
  `title` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '博客标题',
  `summary` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '博客简介',
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '博客内容',
  `tag_uid` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标签uid',
  `click_count` int(0) NULL DEFAULT 0 COMMENT '博客点击数',
  `collect_count` int(0) NULL DEFAULT 0 COMMENT '博客收藏数',
  `file_uid` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标题图片uid',
  `status` tinyint(0) UNSIGNED NOT NULL DEFAULT 1 COMMENT '状态',
  `create_time` timestamp(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '创建时间',
  `update_time` timestamp(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '更新时间',
  `admin_uid` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '管理员uid',
  `is_original` varchar(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '1' COMMENT '是否原创（0:不是 1：是）',
  `author` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '作者',
  `articles_part` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文章出处',
  `blog_sort_uid` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '博客分类UID',
  `level` tinyint(1) NULL DEFAULT 0 COMMENT '推荐等级(0:正常)',
  `is_publish` varchar(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '1' COMMENT '是否发布：0：否，1：是',
  `sort` int(0) NOT NULL DEFAULT 0 COMMENT '排序字段',
  `open_comment` tinyint(1) NOT NULL DEFAULT 1 COMMENT '是否开启评论(0:否 1:是)',
  `type` tinyint(1) NOT NULL DEFAULT 0 COMMENT '类型【0 博客， 1：推广】',
  `outside_link` varchar(1024) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '外链【如果是推广，那么将跳转到外链】',
  `oid` int(0) NOT NULL AUTO_INCREMENT COMMENT '唯一oid',
  `user_uid` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '投稿用户UID',
  `article_source` tinyint(1) NOT NULL DEFAULT 0 COMMENT '文章来源【0 后台添加，1 用户投稿】',
  PRIMARY KEY (`uid`, `oid`) USING BTREE,
  INDEX `oid`(`oid`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 58 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '博客表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog
-- ----------------------------
INSERT INTO `t_blog` VALUES ('062ca3475e8193a4a81853a4bf41a8fa', 'JVM堆', 'JVM堆', '<h1>堆</h1>\n\n<h2>堆的核心概念</h2>\n\n<p>堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。</p>\n\n<p><img alt=\"image-20200706195127740\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724553658.png\" /></p>\n\n<p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p>\n\n<p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。</p>\n\n<ul>\n	<li>堆内存的大小是可以调节的。</li>\n</ul>\n\n<p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p>\n\n<p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</p>\n\n<blockquote>\n<p>-Xms10m：最小堆内存</p>\n\n<p>-Xmx10m：最大堆内存</p>\n</blockquote>\n\n<p>下图就是使用：Java VisualVM查看堆空间的内容，通过 jdk bin提供的插件</p>\n\n<p><img alt=\"image-20200706200739392\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724554552.png\" /></p>\n\n<p>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p>\n\n<p>我要说的是：&ldquo;几乎&rdquo;所有的对象实例都在这里分配内存。&mdash;从实际使用角度看的。</p>\n\n<ul>\n	<li>因为还有一些对象是在栈上分配的</li>\n</ul>\n\n<p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>\n\n<p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p>\n\n<ul>\n	<li>也就是触发了GC的时候，才会进行回收</li>\n	<li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li>\n</ul>\n\n<p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p>\n\n<p><img alt=\"image-20200706201904057\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724554636.png\" /></p>\n\n<h3>堆内存细分</h3>\n\n<p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</p>\n\n<ul>\n	<li>Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区</li>\n	<li>Tenure generation space 养老区 Old/Tenure</li>\n	<li>Permanent Space永久区 Perm</li>\n</ul>\n\n<p>Java 8及之后堆内存逻辑上分为三部分：新生区养老区+元空间</p>\n\n<ul>\n	<li>Young Generation Space新生区 Young/New 又被划分为Eden区和Survivor区</li>\n	<li>Tenure generation space 养老区 Old/Tenure</li>\n	<li>Meta Space 元空间 Meta</li>\n</ul>\n\n<p>约定：新生区 -&gt; 新生代 -&gt; 年轻代 、 养老区 -&gt; 老年区 -&gt; 老年代、 永久区 -&gt; 永久代</p>\n\n<p><img alt=\"image-20200706203419496\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724554718.png\" /></p>\n\n<p>堆空间内部结构，JDK1.8之前从永久代 替换成 元空间</p>\n\n<p><img alt=\"image-20200706203835403\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724554846.png\" /></p>\n\n<h2>设置堆内存大小与OOM</h2>\n\n<p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项&quot;-Xmx&quot;和&quot;-Xms&quot;来进行设置。</p>\n\n<ul>\n	<li>&ldquo;-Xms&quot;用于表示堆区的起始内存，等价于-xx:InitialHeapSize</li>\n	<li>&ldquo;-Xmx&quot;则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li>\n</ul>\n\n<p>一旦堆区中的内存大小超过&ldquo;-xmx&quot;所指定的最大内存时，将会抛出outofMemoryError异常。</p>\n\n<p>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是<strong>为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong>。</p>\n\n<p>默认情况下</p>\n\n<ul>\n	<li>\n	<p>初始内存大小：物理电脑内存大小/64</p>\n	</li>\n	<li>\n	<p>最大内存大小：物理电脑内存大小/4</p>\n	</li>\n</ul>\n\n<pre>\n<code class=\"language-java\">/**\n * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小\n *  -X：是jvm运行参数\n *  ms：memory start\n * -Xmx：用来设置堆空间（年轻代+老年代）的最大内存大小\n *\n * @author: 陌溪\n * @create: 2020-07-06-20:44\n */\npublic class HeapSpaceInitial {\n    public static void main(String[] args) {\n        // 返回Java虚拟机中的堆内存总量\n        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;\n        // 返回Java虚拟机试图使用的最大堆内存\n        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;\n        System.out.println(\"-Xms:\" + initialMemory + \"M\");\n        System.out.println(\"-Xmx:\" + maxMemory + \"M\");\n    }\n}\n</code></pre>\n\n<p>输出结果</p>\n\n<pre>\n<code>-Xms:245M\n-Xmx:3614M\n</code></pre>\n\n<p>如何查看堆内存的内存分配情况</p>\n\n<pre>\n<code>jps  -&gt;  jstat -gc 进程id\n</code></pre>\n\n<p><img alt=\"image-20200706205756045\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724554916.png\" /></p>\n\n<pre>\n<code>-XX:+PrintGCDetails\n</code></pre>\n\n<p><img alt=\"image-20200706205821919\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724554956.png\" /></p>\n\n<h3>OutOfMemory举例</h3>\n\n<p><img alt=\"image-20200706205947535\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724555016.png\" /></p>\n\n<p><img alt=\"image-20200706210000461\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724555079.png\" /></p>\n\n<p>我们简单的写一个OOM例子</p>\n\n<pre>\n<code class=\"language-java\">/**\n * OOM测试\n *\n * @author: 陌溪\n * @create: 2020-07-06-21:11\n */\npublic class OOMTest {\n    public static void main(String[] args) {\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        while(true) {\n            list.add(999999999);\n        }\n    }\n}\n\n</code></pre>\n\n<p>然后设置启动参数</p>\n\n<pre>\n<code>-Xms10m -Xmx:10m\n</code></pre>\n\n<p>运行后，就出现OOM了，那么我们可以通过 VisualVM这个工具查看具体是什么参数造成的OOM</p>\n\n<p><img alt=\"image-20200706211652779\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724555117.png\" /></p>\n\n<h2>年轻代与老年代</h2>\n\n<p>存储在JVM中的Java对象可以被划分为两类：</p>\n\n<ul>\n	<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速\n	<ul>\n		<li>生命周期短的，及时回收即可</li>\n	</ul>\n	</li>\n	<li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li>\n</ul>\n\n<p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p>\n\n<p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</p>\n\n<p><img alt=\"image-20200707075847954\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724555189.png\" /></p>\n\n<p>下面这参数开发中一般不会调：</p>\n\n<p><img alt=\"image-20200707080154039\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724555216.png\" /></p>\n\n<ul>\n	<li>Eden：From：to -&gt; 8:1:1</li>\n	<li>新生代：老年代 - &gt; 1 : 2</li>\n</ul>\n\n<p>配置新生代与老年代在堆结构的占比。</p>\n\n<ul>\n	<li>\n	<p>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</p>\n	</li>\n	<li>\n	<p>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</p>\n	</li>\n</ul>\n\n<blockquote>\n<p>当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优</p>\n</blockquote>\n\n<p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项&ldquo;-xx:SurvivorRatio&rdquo;调整这个空间比例。比如-xx:SurvivorRatio=8</p>\n\n<p>几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）</p>\n\n<blockquote>\n<p>IBM公司的专门研究表明，新生代中80%的对象都是&ldquo;朝生夕死&rdquo;的。</p>\n\n<p>可以使用选项&quot;-Xmn&quot;设置新生代最大内存大小</p>\n\n<p>这个参数一般使用默认值就可以了。</p>\n</blockquote>\n\n<p><img alt=\"image-20200707084208115\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724555289.png\" /></p>\n\n<h2>图解对象分配过程</h2>\n\n<h3>概念</h3>\n\n<p>为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>\n\n<ul>\n	<li>new的对象先放伊甸园区。此区有大小限制。</li>\n	<li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li>\n	<li>然后将伊甸园中的剩余对象移动到幸存者0区。</li>\n	<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li>\n	<li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li>\n	<li>啥时候能去养老区呢？可以设置次数。默认是15次。</li>\n	<li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li>\n	<li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li>\n</ul>\n\n<p>可以设置参数：-Xx:MaxTenuringThreshold= N进行设置</p>\n\n<h3>图解过程</h3>\n\n<p>我们创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 YGC / Minor GC操作</p>\n\n<p><img alt=\"image-20200707084714886\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724555316.png\" /></p>\n\n<p>当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。</p>\n\n<p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1</p>\n\n<p><img alt=\"image-20200707085232646\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724555379.png\" /></p>\n\n<p>我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象 晋升到 老年代中</p>\n\n<p><img alt=\"image-20200707085737207\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724555416.png\" /></p>\n\n<h3>思考：幸存区区满了后？</h3>\n\n<p>特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作</p>\n\n<p>如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代</p>\n\n<blockquote>\n<p>举例：以当兵为例，正常人的晋升可能是 ： 新兵 -&gt; 班长 -&gt; 排长 -&gt; 连长</p>\n\n<p>但是也有可能有些人因为做了非常大的贡献，直接从 新兵 -&gt; 排长</p>\n</blockquote>\n\n<h3>对象分配的特殊情况</h3>\n\n<p><img alt=\"image-20200707091058346\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724555444.png\" /></p>\n\n<h3>代码演示对象分配过程</h3>\n\n<p>我们不断的创建大对象</p>\n\n<pre>\n<code class=\"language-java\">/**\n * 代码演示对象创建过程\n *\n * @author: 陌溪\n * @create: 2020-07-07-9:16\n */\npublic class HeapInstanceTest {\n    byte [] buffer = new byte[new Random().nextInt(1024 * 200)];\n    public static void main(String[] args) throws InterruptedException {\n        ArrayList&lt;HeapInstanceTest&gt; list = new ArrayList&lt;&gt;();\n        while (true) {\n            list.add(new HeapInstanceTest());\n            Thread.sleep(10);\n        }\n    }\n}\n</code></pre>\n\n<p>然后设置JVM参数</p>\n\n<pre>\n<code class=\"language-bash\">-Xms600m -Xmx600m\n</code></pre>\n\n<p>然后cmd输入下面命令，打开VisualVM图形化界面</p>\n\n<pre>\n<code>jvisualvm\n</code></pre>\n\n<p>然后通过执行上面代码，通过VisualGC进行动态化查看</p>\n\n<p><img alt=\"垃圾回收\" src=\"http://localhost:8600//blog/admin/gif/2020/10/15/1602724555783.gif\" /></p>\n\n<p>最终，在老年代和新生代都满了，就出现OOM</p>\n\n<pre>\n<code>Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n	at com.atguigu.java.chapter08.HeapInstanceTest.&lt;init&gt;(HeapInstanceTest.java:13)\n	at com.atguigu.java.chapter08.HeapInstanceTest.main(HeapInstanceTest.java:17)\n</code></pre>\n\n<h3>常用的调优工具</h3>\n\n<ul>\n	<li>JDK命令行</li>\n	<li>Eclipse：Memory Analyzer Tool</li>\n	<li>Jconsole</li>\n	<li>Visual VM（实时监控 推荐~）</li>\n	<li>Jprofiler（推荐~）</li>\n	<li>Java Flight Recorder（实时监控）</li>\n	<li>GCViewer</li>\n	<li>GCEasy</li>\n</ul>\n\n<h3>总结</h3>\n\n<ul>\n	<li>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to</li>\n	<li>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集</li>\n	<li>新生代采用复制算法的目的：是为了减少内碎片</li>\n</ul>\n\n<h2>Minor GC，MajorGC、Full GC</h2>\n\n<ul>\n	<li>Minor GC：新生代的GC</li>\n	<li>Major GC：老年代的GC</li>\n	<li>Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集</li>\n</ul>\n\n<blockquote>\n<p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW的问题</p>\n\n<p>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</p>\n</blockquote>\n\n<p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p>\n\n<p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p>\n\n<ul>\n	<li>新生代收集（MinorGC/YoungGC）：只是新生代的垃圾收集</li>\n	<li>老年代收集（MajorGC/o1dGC）：只是老年代的圾收集。\n	<ul>\n		<li>目前，只有CMSGC会有单独收集老年代的行为。</li>\n		<li>注意，很多时候Major GC会和Fu11GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li>\n	</ul>\n	</li>\n	<li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。\n	<ul>\n		<li>目前，只有G1 GC会有这种行为</li>\n	</ul>\n	</li>\n</ul>\n\n<p>整堆收集（FullGC）：收集整个java堆和方法区的垃圾收集。</p>\n\n<h3>Minor GC</h3>\n\n<p>当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）</p>\n\n<p>因为Java对象大多都具备 <strong>朝生夕灭</strong> 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p>\n\n<p>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p>\n\n<blockquote>\n<p>STW：stop the word</p>\n</blockquote>\n\n<p><img alt=\"image-20200707095606813\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724555516.png\" /></p>\n\n<h3>Major GC</h3>\n\n<p>指发生在老年代的GC，对象从老年代消失时，我们说 &ldquo;Major Gc&rdquo; 或 &ldquo;Full GC&rdquo; 发生了</p>\n\n<p>出现了MajorGc，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p>\n\n<ul>\n	<li>也就是在老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC</li>\n</ul>\n\n<p>Major GC的速度一般会比MinorGc慢1e倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了</p>\n\n<h3>Full GC</h3>\n\n<p>触发Fu11GC执行的情况有如下五种：</p>\n\n<ul>\n	<li>调用System.gc（）时，系统建议执行Fu11GC，但是不必然执行</li>\n	<li>老年代空间不足</li>\n	<li>方法区空间不足</li>\n	<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>\n	<li>由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>\n</ul>\n\n<p>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</p>\n\n<h3>GC 举例</h3>\n\n<p>我们编写一个OOM的异常，因为我们在不断的创建字符串，是存放在元空间的</p>\n\n<pre>\n<code class=\"language-java\">/**\n * GC测试\n *\n * @author: 陌溪\n * @create: 2020-07-07-10:01\n */\npublic class GCTest {\n    public static void main(String[] args) {\n        int i = 0;\n        try {\n            List&lt;String&gt; list = new ArrayList&lt;&gt;();\n            String a = \"mogu blog\";\n            while(true) {\n                list.add(a);\n                a = a + a;\n                i++;\n            }\n        }catch (Exception e) {\n            e.getStackTrace();\n        }\n    }\n}\n</code></pre>\n\n<p>设置JVM启动参数</p>\n\n<pre>\n<code class=\"language-bash\">-Xms10m -Xmx10m -XX:+PrintGCDetails\n</code></pre>\n\n<p>打印出的日志</p>\n\n<pre>\n<code>[GC (Allocation Failure) [PSYoungGen: 2038K-&gt;500K(2560K)] 2038K-&gt;797K(9728K), 0.3532002 secs] [Times: user=0.01 sys=0.00, real=0.36 secs] \n[GC (Allocation Failure) [PSYoungGen: 2108K-&gt;480K(2560K)] 2405K-&gt;1565K(9728K), 0.0014069 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n[Full GC (Ergonomics) [PSYoungGen: 2288K-&gt;0K(2560K)] [ParOldGen: 6845K-&gt;5281K(7168K)] 9133K-&gt;5281K(9728K), [Metaspace: 3482K-&gt;3482K(1056768K)], 0.0058675 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] \n[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 5281K-&gt;5281K(9728K), 0.0002857 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 5281K-&gt;5263K(7168K)] 5281K-&gt;5263K(9728K), [Metaspace: 3482K-&gt;3482K(1056768K)], 0.0058564 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] \nHeap\n PSYoungGen      total 2560K, used 60K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)\n  eden space 2048K, 2% used [0x00000000ffd00000,0x00000000ffd0f138,0x00000000fff00000)\n  from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)\n  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)\n ParOldGen       total 7168K, used 5263K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)\n  object space 7168K, 73% used [0x00000000ff600000,0x00000000ffb23cf0,0x00000000ffd00000)\n Metaspace       used 3514K, capacity 4498K, committed 4864K, reserved 1056768K\n  class space    used 388K, capacity 390K, committed 512K, reserved 1048576K\n  \n  Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n	at java.util.Arrays.copyOfRange(Arrays.java:3664)\n	at java.lang.String.&lt;init&gt;(String.java:207)\n	at java.lang.StringBuilder.toString(StringBuilder.java:407)\n	at com.atguigu.java.chapter08.GCTest.main(GCTest.java:20)\n</code></pre>\n\n<p>触发OOM的时候，一定是进行了一次Full GC，因为只有在老年代空间不足时候，才会爆出OOM异常</p>\n\n<h2>堆空间分代思想</h2>\n\n<p>为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p>\n\n<blockquote>\n<p>新生代：有Eden、两块大小相同的survivor（又称为from/to，s0/s1）构成，to总为空。 老年代：存放新生代中经历多次GC仍然存活的对象。</p>\n</blockquote>\n\n<p><img alt=\"image-20200707101511025\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724555544.png\" /></p>\n\n<p>其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储&ldquo;朝生夕死&rdquo;对象的区域进行回收，这样就会腾出很大的空间出来。</p>\n\n<p><img alt=\"image-20200707101543871\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724555572.png\" /></p>\n\n<h2>内存分配策略</h2>\n\n<p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</p>\n\n<p>对象晋升老年代的年龄阀值，可以通过选项-xx:MaxTenuringThreshold来设置</p>\n\n<p>针对不同年龄段的对象分配原则如下所示：</p>\n\n<ul>\n	<li>优先分配到Eden\n	<ul>\n		<li>开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li>\n	</ul>\n	</li>\n	<li>大对象直接分配到老年代\n	<ul>\n		<li>尽量避免程序中出现过多的大对象</li>\n	</ul>\n	</li>\n	<li>长期存活的对象分配到老年代</li>\n	<li>动态对象年龄判断\n	<ul>\n		<li>如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。</li>\n	</ul>\n	</li>\n</ul>\n\n<p>空间分配担保： -Xx:HandlePromotionFailure</p>\n\n<ul>\n	<li>也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。</li>\n</ul>\n\n<h2>为对象分配内存：TLAB</h2>\n\n<h3>问题：堆空间都是共享的么？</h3>\n\n<p>不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占</p>\n\n<h3>为什么有TLAB？</h3>\n\n<p>TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区</p>\n\n<p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p>\n\n<p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p>\n\n<p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p>\n\n<h3>什么是TLAB</h3>\n\n<p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p>\n\n<p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p>\n\n<p>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</p>\n\n<p><img alt=\"image-20200707103547712\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724555600.png\" /></p>\n\n<p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</p>\n\n<p>在程序中，开发人员可以通过选项&ldquo;-Xx:UseTLAB&rdquo;设置是否开启TLAB空间。</p>\n\n<p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1，当然我们可以通过选项&ldquo;-Xx:TLABWasteTargetPercent&rdquo;设置TLAB空间所占用Eden空间的百分比大小。</p>\n\n<p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p>\n\n<h3>TLAB分配过程</h3>\n\n<p>对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配</p>\n\n<p><img alt=\"image-20200707104253530\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724555628.png\" /></p>\n\n<h2>小结：堆空间的参数设置</h2>\n\n<ul>\n	<li>\n	<p>-XX：+PrintFlagsInitial：查看所有的参数的默认初始值</p>\n	</li>\n	<li>\n	<p>-XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</p>\n	</li>\n	<li>\n	<p>-Xms：初始堆空间内存（默认为物理内存的1/64）</p>\n	</li>\n	<li>\n	<p>-Xmx：最大堆空间内存（默认为物理内存的1/4）</p>\n	</li>\n	<li>\n	<p>-Xmn：设置新生代的大小。（初始值及最大值）</p>\n	</li>\n	<li>\n	<p>-XX:NewRatio：配置新生代与老年代在堆结构的占比</p>\n	</li>\n	<li>\n	<p>-XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</p>\n	</li>\n	<li>\n	<p>-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</p>\n	</li>\n	<li>\n	<p>-XX：+PrintGCDetails：输出详细的GC处理日志</p>\n\n	<ul>\n		<li>打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc</li>\n	</ul>\n	</li>\n	<li>\n	<p>-XX:HandlePromotionFalilure：是否设置空间分配担保</p>\n	</li>\n</ul>\n\n<p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。I</p>\n\n<ul>\n	<li>如果大于，则此次Minor GC是安全的</li>\n	<li>如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。\n	<ul>\n		<li>如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</li>\n		<li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li>\n		<li>如果小于，则改为进行一次FullGC。</li>\n		<li>如果HandlePromotionFailure=false，则改为进行一次Ful1 Gc。</li>\n	</ul>\n	</li>\n</ul>\n\n<p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。</p>\n\n<h2>堆是分配对象的唯一选择么？</h2>\n\n<h3>逃逸分析</h3>\n\n<p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p>\n\n<p>随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么&ldquo;绝对&rdquo;了。</p>\n\n<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>\n\n<p>此外，前面提到的基于openJDk深度定制的TaoBaovm，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>\n\n<p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p>\n\n<p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：</p>\n\n<ul>\n	<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li>\n	<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>\n</ul>\n\n<h4>逃逸分析举例</h4>\n\n<p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析</p>\n\n<pre>\n<code class=\"language-java\">public void my_method() {\n    V v = new V();\n    // use v\n    // ....\n    v = null;\n}\n</code></pre>\n\n<p>针对下面的代码</p>\n\n<pre>\n<code class=\"language-java\">public static StringBuffer createStringBuffer(String s1, String s2) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb;\n}\n</code></pre>\n\n<p>如果想要StringBuffer sb不发生逃逸，可以这样写</p>\n\n<pre>\n<code class=\"language-java\">public static String createStringBuffer(String s1, String s2) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb.toString();\n}\n</code></pre>\n\n<p>完整的逃逸分析代码举例</p>\n\n<pre>\n<code class=\"language-java\">/**\n * 逃逸分析\n * 如何快速的判断是否发生了逃逸分析，大家就看new的对象是否在方法外被调用。\n * @author: 陌溪\n * @create: 2020-07-07-20:05\n */\npublic class EscapeAnalysis {\n\n    public EscapeAnalysis obj;\n\n    /**\n     * 方法返回EscapeAnalysis对象，发生逃逸\n     * @return\n     */\n    public EscapeAnalysis getInstance() {\n        return obj == null ? new EscapeAnalysis():obj;\n    }\n\n    /**\n     * 为成员属性赋值，发生逃逸\n     */\n    public void setObj() {\n        this.obj = new EscapeAnalysis();\n    }\n\n    /**\n     * 对象的作用于仅在当前方法中有效，没有发生逃逸\n     */\n    public void useEscapeAnalysis() {\n        EscapeAnalysis e = new EscapeAnalysis();\n    }\n\n    /**\n     * 引用成员变量的值，发生逃逸\n     */\n    public void useEscapeAnalysis2() {\n        EscapeAnalysis e = getInstance();\n        // getInstance().XXX  发生逃逸\n    }\n}\n</code></pre>\n\n<h4>参数设置</h4>\n\n<p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p>\n\n<p>如果使用的是较早的版本，开发人员则可以通过：</p>\n\n<ul>\n	<li>选项&ldquo;-xx：+DoEscapeAnalysis&quot;显式开启逃逸分析</li>\n	<li>通过选项&ldquo;-xx：+PrintEscapeAnalysis&quot;查看逃逸分析的筛选结果</li>\n</ul>\n\n<h4>结论</h4>\n\n<p>开发中能使用局部变量的，就不要使用在方法外定义。</p>\n\n<p>使用逃逸分析，编译器可以对代码做如下优化：</p>\n\n<ul>\n	<li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li>\n	<li>同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li>\n	<li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li>\n</ul>\n\n<h3>栈上分配</h3>\n\n<p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p>\n\n<p>常见的栈上分配的场景</p>\n\n<blockquote>\n<p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</p>\n</blockquote>\n\n<h4>举例</h4>\n\n<p>我们通过举例来说明 开启逃逸分析 和 未开启逃逸分析时候的情况</p>\n\n<pre>\n<code class=\"language-java\">/**\n * 栈上分配\n * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails\n * @author: 陌溪\n * @create: 2020-07-07-20:23\n */\nclass User {\n    private String name;\n    private String age;\n    private String gender;\n    private String phone;\n}\npublic class StackAllocation {\n    public static void main(String[] args) throws InterruptedException {\n        long start = System.currentTimeMillis();\n        for (int i = 0; i &lt; 100000000; i++) {\n            alloc();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"花费的时间为：\" + (end - start) + \" ms\");\n\n        // 为了方便查看堆内存中对象个数，线程sleep\n        Thread.sleep(10000000);\n    }\n\n    private static void alloc() {\n        User user = new User();\n    }\n}\n</code></pre>\n\n<p>设置JVM参数，表示未开启逃逸分析</p>\n\n<pre>\n<code>-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails\n</code></pre>\n\n<p>运行结果，同时还触发了GC操作</p>\n\n<pre>\n<code>花费的时间为：664 ms\n</code></pre>\n\n<p>然后查看内存的情况，发现有大量的User存储在堆中</p>\n\n<p><img alt=\"image-20200707203038615\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724555657.png\" /></p>\n\n<p>我们在开启逃逸分析</p>\n\n<pre>\n<code>-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails\n</code></pre>\n\n<p>然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生GC操作</p>\n\n<pre>\n<code>花费的时间为：5 ms\n</code></pre>\n\n<p>然后在看内存情况，我们发现只有很少的User对象，说明User发生了逃逸，因为他们存储在栈中，随着栈的销毁而消失</p>\n\n<p><img alt=\"image-20200707203441718\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724555684.png\" /></p>\n\n<h3>同步省略</h3>\n\n<p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p>\n\n<p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p>\n\n<p>例如下面的代码</p>\n\n<pre>\n<code class=\"language-java\">public void f() {\n    Object hellis = new Object();\n    synchronized(hellis) {\n        System.out.println(hellis);\n    }\n}\n</code></pre>\n\n<p>代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p>\n\n<pre>\n<code class=\"language-java\">public void f() {\n    Object hellis = new Object();\n	System.out.println(hellis);\n}\n</code></pre>\n\n<p>我们将其转换成字节码</p>\n\n<p><img alt=\"image-20200707205634266\" src=\"http://localhost:8600//blog/admin/png/2020/10/15/1602724555745.png\" /></p>\n\n<h3>分离对象和标量替换</h3>\n\n<p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p>\n\n<p>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>\n\n<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过J工T优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p>\n\n<pre>\n<code class=\"language-java\">public static void main(String args[]) {\n    alloc();\n}\nclass Point {\n    private int x;\n    private int y;\n}\nprivate static void alloc() {\n    Point point = new Point(1,2);\n    System.out.println(\"point.x\" + point.x + \";point.y\" + point.y);\n}\n</code></pre>\n\n<p>以上代码，经过标量替换后，就会变成</p>\n\n<pre>\n<code class=\"language-java\">private static void alloc() {\n    int x = 1;\n    int y = 2;\n    System.out.println(\"point.x = \" + x + \"; point.y=\" + y);\n}\n</code></pre>\n\n<p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。 标量替换为栈上分配提供了很好的基础。</p>\n\n<h3>代码优化之标量替换</h3>\n\n<p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p>\n\n<pre>\n<code class=\"language-bash\">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations\n</code></pre>\n\n<p>这里设置参数如下：</p>\n\n<ul>\n	<li>参数-server：启动Server模式，因为在server模式下，才可以启用逃逸分析。</li>\n	<li>参数-XX:+DoEscapeAnalysis：启用逃逸分析</li>\n	<li>参数-Xmx10m：指定了堆空间最大为10MB</li>\n	<li>参数-XX:+PrintGC：将打印Gc日志。</li>\n	<li>参数一xx：+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li>\n</ul>\n\n<h3>逃逸分析的不足</h3>\n\n<p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。</p>\n\n<p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。 一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>\n\n<p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JvM设计者的选择。据我所知，oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p>\n\n<p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p>\n\n<h2>小结</h2>\n\n<p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p>\n\n<p>老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGc。</p>\n\n<p>当GC发生在老年代时则被称为MajorGc或者FullGC。一般的，MinorGc的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 4, 0, 'd134bdfe255b9aa8c2ce44da8297f6a6', 1, '2020-10-15 09:16:54', '2020-12-26 16:06:23', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 2, NULL, 0);
INSERT INTO `t_blog` VALUES ('05a627a5f5040b95c604410605a3ac5c', '测试', '测试', '<h2 id=\"测试\">测试</h2>\n<p>测试内容</p>\n', '7e0e93ea6cdb44ae92e58f48e6496ed7', 1, 0, '828227a0f1c736ea393fa4a747b1c5d9', 0, '2020-10-06 11:11:27', '2020-10-07 16:12:00', '7621746caa93ce605e2de7143a3787b5', '1', 'mogu2018mogu2018', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 1, NULL, 0);
INSERT INTO `t_blog` VALUES ('0ddc790e68eb0fbb41a9854ceaa72926', '测试Java', '测试Java', '<p>概念概念概念概念概念概念概念概念概念概念概念概念概念概念概念概念概念概念概念概念概念概念概念概念概念概念概念概念概念概念</p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 1, 0, 'ef1ce71e5a5dab0856c13f38da976aec', 1, '2020-12-26 15:46:57', '2020-12-26 16:08:19', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 32, NULL, 0);
INSERT INTO `t_blog` VALUES ('1091071a69da682123616e974b2f418d', 'Go语言发展简史.md', 'Go语言发展简史.md', '<h1>Go语言发展简史</h1>\n<h2>开发文档</h2>\n<p><a href=\"https://studygolang.com/pkgdoc\">https://studygolang.com/pkgdoc</a></p>\n<h2>Go语言核心开发团队</h2>\n<p>Ken Thompson（肯·汤普森）：1983年图灵奖（Turing Award）和1998年美国国家技术奖（National Medal of Technology）得主。他与Dennis Ritchie是Unix的原创者。Thompson也发明了后来衍生出C语言的B程序语言，同时也是C语言的主要发明人。</p>\n<p>Rob Pike（罗布-派克）：曾是贝尔实验室（Bell Labs）的Unix团队，和Plan 9操作系统计划的成员。\n他与Thompson共事多年，并共创出广泛使用的UTF-8字元编码。</p>\n<p>Robert Griesemer：曾协助制作Java的HotSpot编译器，和Chrome浏览器的JavaScript引擎V8。</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/1/14/1610606910400.png\" alt=\"image-20200718103112309\" /></p>\n<h2>Google为什么要创建Go</h2>\n<ul>\n<li>计算机硬件技术更新频繁，性能提高很快。目前主流的编程语言发展明显落后于硬件，不能合理利用多核多CPU的优势提升软件系统性能。</li>\n<li>软件系统复杂度越来越高，维护成本越来越高，目前缺乏一个足够简洁高效的编程语言。\n<ul>\n<li>现有编程语言存在：风格不统一、计算能力不够、处理大并发不够好</li>\n</ul>\n</li>\n<li>企业运行维护很多c/c++的项目，c/c++程序运行速度虽然很快，但是编译速度确很慢，同时还存在内存泄漏的一系列的困扰需要解决。</li>\n</ul>\n<h2>Go语言发展历史</h2>\n<ul>\n<li>2007年，谷歌工程师Rob Pike，Ken Thompson和Robert Griesemer开始设计一门全新的语言，这是Go语言的最初原型。</li>\n<li>2009年11月10日，Google将Go语言以开放源代码的方式向全球发布。</li>\n<li>2015年8月19日，Go1.5版发布，本次更新中移除了”最后残余的c代码”</li>\n<li>2017年2月17日，Go语言Go1.8版发布。</li>\n<li>2017年8月24日，Go语言Go1.9版发布。</li>\n<li>2018年2月16日，Go语言Go1.10版发布。</li>\n</ul>\n<h2>Go语言的特点</h2>\n<p>Go语言保证了既能到达静态编译语言的安全和性能，又达到了动态语言开发维护的高效率，使用一个表达式来形容Go语言：Go=C+Python，说明Go语言既有C静态语言程序的运行速度，又能达到Python动态语言的快速开发。</p>\n<ul>\n<li>从c语言中继承了很多理念，包括表达式语法，控制结构，基础数据类型，调用参数传值，指针等等，也保留了和C语言一样的编译执行方式及弱化的指针。</li>\n</ul>\n<pre><code class=\"language-go\">// go语言的指针使用特点\nfunc testPtr(num *int)  {\n	*num = 20\n}\n</code></pre>\n<ul>\n<li>引入包的概念，用于组织程序结构，Go语言的一个文件都要归属于一个包，而不能单独存在。</li>\n<li>垃圾回收机制，内存自动回收，不需开发人员管理 【稍微不注意就会出现内存泄漏】</li>\n<li>天然并发【重要特点】\n<ul>\n<li>从语言层面支持并发，实现简单</li>\n<li>goroutine，轻量级线程，可实现大并发处理，高效利用多核。</li>\n<li>基于CPS并发模型（Communicating Sequential Processes）实现</li>\n</ul>\n</li>\n<li>吸收了管道通信机制，形成go语言特有的管道channel，通过管道channel，可以实现不同的goroute之间的相互通信</li>\n<li>函数返回多个值（实例代码）</li>\n<li>新的创新：比如切片slice，延时执行defer等</li>\n</ul>\n<h2>Hello Go</h2>\n<p>我们写一个最简单的入门代码，在控制台输出hello go！</p>\n<pre><code class=\"language-go\">package main\n// fmt包中提供格式化，输入和输出的函数\nimport &quot;fmt&quot;\nfunc main() {\n	fmt.Println(&quot;hello go!&quot;)\n}\n</code></pre>\n<h2>Golang执行流程分析</h2>\n<p>我们可以通过以下命令来进行操作</p>\n<ul>\n<li>go build hello.go    -&gt; hello.exe</li>\n<li>go  run  hello.go</li>\n</ul>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/1/14/1610606911285.png\" alt=\"image-20200718161111596\" /></p>\n<h3>两种执行流程分析</h3>\n<ul>\n<li>如果我们先编译生成了可执行文件，那么我们可以将该可执行文件拷贝到没有go开发环境的机器上，然可以运行</li>\n<li>如果我们是直接go rungo源代码，那么如果要在另外一个机器上这么运行，也需要go开发环境，否则无法执行。</li>\n<li>在编译时，编译器会将程序运行依赖的库文件包含在可执行文件中，所以，可执行文件变大了很多。</li>\n</ul>\n<h3>什么是编译</h3>\n<ul>\n<li>有了go源文件，通过编译器将其编译成机器可以识别的二进制码文件。</li>\n<li>在该源文件目录下，通过go build 对hello.go文件进行编译。可以指定生成的可执行文件名，在windows下必须是.exe后缀。</li>\n<li>如果程序没有错误，没有任何提示，会在当前目录下会出现一个可执行文件（windows下是.exe Linux下是一个可执行文件），该文件是二进制码文件，也是可以执行的程序。</li>\n<li>如果程序有错误，编译时，会在错误的那行报错。</li>\n</ul>\n<h2>Go语言开发注意事项</h2>\n<ul>\n<li>Go源文件以“go”为扩展名</li>\n<li>Go应用程序的执行入口是main()方法</li>\n<li>Go语言严格区分大小写。</li>\n<li>Go方法由一条条语句构成，每个语句后不需要分号（Go语言会在每行后自动加分号），这也体现出Golang的简洁性。</li>\n<li>Go编译器是一行行进行编译的，因此我们一行就写一条语句，不能把多条语句写在同一个，否则报错</li>\n<li>Go语言定义的变量或者import的包如果没有使用到，代码不能编译通过</li>\n<li>大括号都是成对出现的，缺一不可。</li>\n</ul>\n<h2>Go语言中的转义字符</h2>\n<p>GoLang常用的转义字符（escape char）</p>\n<ul>\n<li>\\t：一个制表位，实现对齐的功能</li>\n<li>\\n：换行符</li>\n<li>\\：一个\\</li>\n<li>\\r：一个回车</li>\n</ul>\n', '5626932d452c2ad863d9b3cb0b69d22d', 0, 0, 'd134bdfe255b9aa8c2ce44da8297f6a6', 1, '2021-01-14 14:48:34', '2021-01-14 14:48:34', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '0', 0, 1, 0, NULL, 37, NULL, 0);
INSERT INTO `t_blog` VALUES ('11e0cace2148383e201439a682432d59', '【JVM】垃圾回收器', '【JVM】垃圾回收器', '<h1 id=\"垃圾回收器\">垃圾回收器</h1>\n<h2 id=\"GC分类与性能指标\">GC分类与性能指标</h2>\n<p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</p>\n<p>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</p>\n<p>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</p>\n<blockquote>\n<p>Java不同版本新特性</p>\n<ul>\n<li>语法层面：Lambda表达式、switch、自动拆箱装箱、enum</li>\n<li>API层面：Stream API、新的日期时间、Optional、String、集合框架</li>\n<li>底层优化：JVM优化、GC的变化、元空间、静态域、字符串常量池位置变化</li>\n</ul>\n</blockquote>\n<h3 id=\"垃圾收集器分类\">垃圾收集器分类</h3>\n<h4 id=\"按线程数分\"><strong>按线程数分</strong></h4>\n<p><strong>按线程数分</strong>（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器。</p>\n<p><img src=\"http://image.moguit.cn/e2af28473690473aa86e591a970251a2\" alt=\"image-20200713083030867\" /></p>\n<p>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p>\n<ul>\n<li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中</li>\n<li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</li>\n</ul>\n<p>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“stop-the-world”机制。</p>\n<h4 id=\"按工作模式分\">按工作模式分</h4>\n<p>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。</p>\n<ul>\n<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li>\n<li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li>\n</ul>\n<p><img src=\"http://image.moguit.cn/f5376dafb6574023b68f4e3d85690e35\" alt=\"image-20200713083443486\" /></p>\n<h4 id=\"按碎片处理方式分\">按碎片处理方式分</h4>\n<p>按碎片处理方式分，可分为压缩武垃圾回收器和非压缩式垃圾回收器。</p>\n<ul>\n<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</li>\n<li>非压缩式的垃圾回收器不进行这步操作。</li>\n</ul>\n<p>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</p>\n<h3 id=\"评估GC的性能指标\">评估GC的性能指标</h3>\n<ul>\n<li><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</li>\n<li><strong>垃圾收集开销</strong>：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>\n<li><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间。</li>\n<li><strong>收集频率</strong>：相对于应用程序的执行，收集操作发生的频率。</li>\n<li><strong>内存占用</strong>：Java堆区所占的内存大小。</li>\n<li><strong>快速</strong>：一个对象从诞生到被回收所经历的时间。</li>\n</ul>\n<p>吞吐量、暂停时间、内存占用 这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。 这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。 简单来说，主要抓住两点：</p>\n<p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。 简单来说，主要抓住两点：</p>\n<ul>\n<li>吞吐量</li>\n<li>暂停时间</li>\n</ul>\n<h3 id=\"性能指标-吞吐量\">性能指标：吞吐量</h3>\n<p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间）</p>\n<blockquote>\n<p>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>\n</blockquote>\n<p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p>\n<p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2+0.2=e.4</p>\n<p><img src=\"http://image.moguit.cn/5c7132f313c9475aa7248135ba301003\" alt=\"image-20200713084726176\" /></p>\n<h3 id=\"性能指标-暂停时间\">性能指标：暂停时间</h3>\n<p>“暂停时间”是指一个时间段内应用程序线程暂停，让Gc线程执行的状态</p>\n<p>例如，GC期间1ee毫秒的暂停时间意味着在这1e0毫秒期间内没有应用程序线程是活动的。暂停时间优先，意味着尽可能让单次STW的时间最短：0.1+0.1 + 0.1+ 0.1+ 0.1=0.5</p>\n<p><img src=\"http://image.moguit.cn/b18aee33c11d4977a93a3dfe37ef6cf4\" alt=\"image-20200713085306400\" /></p>\n<h3 id=\"吞吐量vs暂停时间\">吞吐量vs暂停时间</h3>\n<p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p>\n<p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。</p>\n<p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p>\n<p>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。</p>\n<p>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</p>\n<p>在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p>\n<p>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></p>\n<h2 id=\"不同的垃圾回收器概述\">不同的垃圾回收器概述</h2>\n<p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</p>\n<p>那么，Java常见的垃圾收集器有哪些？</p>\n<blockquote>\n<p>GC垃圾收集器是和JVM一脉相承的，它是和JVM进行搭配使用，在不同的使用场景对应的收集器也是有区别</p>\n</blockquote>\n<h3 id=\"垃圾回收器发展史\">垃圾回收器发展史</h3>\n<p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。</p>\n<ul>\n<li>1999年随JDK1.3.1一起来的是串行方式的serialGc，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</li>\n<li>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布·</li>\n<li>Parallel GC在JDK6之后成为HotSpot默认GC。</li>\n<li>2012年，在JDK1.7u4版本中，G1可用。</li>\n<li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li>\n<li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li>\n<li>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 &quot;No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li>\n<li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。·2019年9月，JDK13发布。增强zGC，自动返回未用堆内存给操作系统。</li>\n<li>2020年3月，JDK14发布。删除cMs垃圾回收器。扩展zGC在macos和Windows上的应用</li>\n</ul>\n<h3 id=\"7种经典的垃圾收集器\">7种经典的垃圾收集器</h3>\n<ul>\n<li>串行回收器：Serial、Serial old</li>\n<li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li>\n<li>并发回收器：CMS、G11</li>\n</ul>\n<p><img src=\"http://image.moguit.cn/b20873e989cd4337913a0330d42969e9\" alt=\"image-20200713093551365\" /></p>\n<h3 id=\"7款经典收集器与垃圾分代之间的关系\">7款经典收集器与垃圾分代之间的关系</h3>\n<p><img src=\"http://image.moguit.cn/c81063d5dc684c4b9e06c7707c3e1200\" alt=\"image-20200713093757644\" /></p>\n<p>新生代收集器：Serial、ParNew、Paralle1 Scavenge；</p>\n<p>老年代收集器：Serial old、Parallel old、CMS；</p>\n<p>整堆收集器：G1；</p>\n<h3 id=\"垃圾收集器的组合关系\">垃圾收集器的组合关系</h3>\n<p><img src=\"http://image.moguit.cn/a0bc661006244119af70fab4ae876f71\" alt=\"image-20200713094745366\" /></p>\n<ul>\n<li>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial old、Serial/CMS、ParNew/Serial old、ParNew/CMS、Parallel Scavenge/Serial 0ld、Parallel Scavenge/Parallel 01d、G1；</li>\n<li>其中Serial o1d作为CMs出现&quot;Concurrent Mode Failure&quot;失败的后备预案。</li>\n<li>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</li>\n<li>（绿色虚线）JDK14中：弃用Paralle1 Scavenge和Serialold GC组合（JEP366）</li>\n<li>（青色虚线）JDK14中：删除CMs垃圾回收器（JEP363）</li>\n</ul>\n<p>为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p>\n<p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器。</p>\n<h3 id=\"如何查看默认垃圾收集器\">如何查看默认垃圾收集器</h3>\n<p>-XX:+PrintcommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）</p>\n<p>使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID</p>\n<h2 id=\"Serial回收器-串行回收\">Serial回收器：串行回收</h2>\n<p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</p>\n<p>Serial收集器作为HotSpot中client模式下的默认新生代垃圾收集器。</p>\n<p>Serial收集器采用复制算法、串行回收和&quot;stop-the-World&quot;机制的方式执行内存回收。</p>\n<p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial old收集器。Serial old收集器同样也采用了串行回收和&quot;stop the World&quot;机制，只不过内存回收算法使用的是标记-压缩算法。</p>\n<ul>\n<li>Serial old是运行在Client模式下默认的老年代的垃圾回收器</li>\n<li>Serial 0ld在Server模式下主要有两个用途：\n<ul>\n<li>与新生代的Parallel scavenge配合使用</li>\n<li>作为老年代CMS收集器的后备垃圾收集方案</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://image.moguit.cn/c9a3ac2f93ff431dae0a5396dec54667\" alt=\"image-20200713100703799\" /></p>\n<p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</p>\n<p>优势：简单而高效（与其他收集器的单线程比），对于限定单个cPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>\n<p>运行在client模式下的虚拟机是个不错的选择。</p>\n<p>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。</p>\n<p>在HotSpot虚拟机中，使用-XX：+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。</p>\n<p>等价于新生代用Serial GC，且老年代用Serial old GC</p>\n<h3 id=\"总结\">总结</h3>\n<p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。</p>\n<p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</p>\n<h2 id=\"ParNew回收器-并行回收\">ParNew回收器：并行回收</h2>\n<p>如果说serialGC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是serial收集器的多线程版本。</p>\n<ul>\n<li>Par是Parallel的缩写，New：只能处理的是新生代</li>\n</ul>\n<p>ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、&quot;stop-the-World&quot;机制。</p>\n<p>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p>\n<p><img src=\"http://image.moguit.cn/7956256d195d42c882ea2efb9bd9078b\" alt=\"image-20200713102030127\" /></p>\n<ul>\n<li>对于新生代，回收次数频繁，使用并行方式高效。</li>\n<li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li>\n</ul>\n<p>由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比serial收集器更高效？</p>\n<p>因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作</p>\n<p>在程序中，开发人员可以通过选项&quot;-XX：+UseParNewGC&quot;手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p>\n<p>-XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数。</p>\n<h2 id=\"Parallel回收器-吞吐量优先\">Parallel回收器：吞吐量优先</h2>\n<p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和&quot;Stop the World&quot;机制。</p>\n<p>那么Parallel 收集器的出现是否多此一举？</p>\n<ul>\n<li>和ParNew收集器不同，ParallelScavenge收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的垃圾收集器。</li>\n<li>自适应调节策略也是Paralle1 Scavenge与ParNew一个重要区别。</li>\n</ul>\n<p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>\n<p>Paralle1收集器在JDK1.6时提供了用于执行老年代垃圾收集的Paralle1o1d收集器，用来代替老年代的serialold收集器。</p>\n<p>Parallel old收集器采用了标记-压缩算法，但同样也是基于并行回收和&quot;stop-the-World&quot;机制。</p>\n<p><img src=\"http://image.moguit.cn/df20d6f88ba744faa9f2eb12c5c4bb55\" alt=\"image-20200713110359441\" /></p>\n<p>在程序吞吐量优先的应用场景中，IParalle1收集器和Parallel old收集器的组合，在server模式下的内存回收性能很不错。在Java8中，默认是此垃圾收集器。</p>\n<h3 id=\"参数配置\">参数配置</h3>\n<p>-XX：+UseParallelGC 手动指定年轻代使用Paralle1并行收集器执行内存回收任务。</p>\n<p>-XX：+UseParalleloldcc 手动指定老年代都是使用并行回收收集器。</p>\n<ul>\n<li>分别适用于新生代和老年代。默认jdk8是开启的。</li>\n<li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li>\n</ul>\n<p>-XX:ParallelGcrhreads设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p>\n<p>在默认情况下，当CPU数量小于8个，ParallelGcThreads的值等于CPU数量。</p>\n<p>当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU Count]/8]</p>\n<p>-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即STw的时间）。单位是毫秒。</p>\n<p>为了尽可能地把停顿时间控制在MaxGCPauseMi11s以内，收集器在工作时会调整Java堆大小或者其他一些参数。 对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。该参数使用需谨慎。</p>\n<p>-XX:GCTimeRatio垃圾收集时间占总时间的比例（=1/（N+1））。用于衡量吞吐量的大小。</p>\n<p>取值范围（0，100）。默认值99，也就是垃圾回收时间不超过1。</p>\n<p>与前一个-xx:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</p>\n<p>-XX:+UseAdaptivesizepplicy 设置Parallel scavenge收集器具有自适应调节策略</p>\n<p>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</p>\n<p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMil1s），让虚拟机自己完成调优工作。</p>\n<h2 id=\"CMS回收器-低延迟\">CMS回收器：低延迟</h2>\n<p>在JDK1.5时期，Hotspot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：cMS（Concurrent-Mark-Sweep）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，<strong>它第一次实现了让垃圾收集线程与用户线程同时工作</strong>。</p>\n<p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p>\n<p>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p>\n<p>CMS的垃圾收集算法采用标记-清除算法，并且也会&quot;stop-the-world&quot;</p>\n<p>不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</p>\n<p>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p>\n<p><img src=\"http://image.moguit.cn/68b528d2d17a4aaca3550358d35380e7\" alt=\"image-20200713205154007\" /></p>\n<p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及STW的阶段主要是：初始标记 和 重新标记)</p>\n<ul>\n<li><strong>初始标记</strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是<strong>标记出GCRoots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</li>\n<li><strong>并发标记</strong>（Concurrent-Mark）阶段：从Gc Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li>\n<li><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li>\n<li><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li>\n</ul>\n<p>尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。</p>\n<p>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p>\n<p>另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p>\n<p>CMS收集器的垃圾收集算法采用的是<strong>标记清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</p>\n<p><img src=\"http://image.moguit.cn/e69c5c84ce8846ce8af5f0af10060c34\" alt=\"image-20200713212230352\" /></p>\n<h3 id=\"CMS为什么不使用标记整理算法-\">CMS为什么不使用标记整理算法？</h3>\n<p>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world” 这种场景下使用</p>\n<h3 id=\"优点\">优点</h3>\n<ul>\n<li>并发收集</li>\n<li>低延迟</li>\n</ul>\n<h3 id=\"缺点\">缺点</h3>\n<ul>\n<li>会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发FullGC。</li>\n<li>CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li>\n<li>CMS收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure&quot;失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li>\n</ul>\n<h3 id=\"设置的参数\">设置的参数</h3>\n<ul>\n<li>-XX：+UseConcMarkSweepGC手动指定使用CMS收集器执行内存回收任务。</li>\n</ul>\n<p>开启该参数后会自动将-xx：+UseParNewGC打开。即：ParNew（Young区用）+CMS（01d区用）+Serial old的组合。</p>\n<ul>\n<li>-XX:CMSInitiatingoccupanyFraction 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</li>\n</ul>\n<p>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次cMs回收。JDK6及以上版本默认值为92%</p>\n<p>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Ful1Gc的执行次数。</p>\n<ul>\n<li>-XX：+UseCMSCompactAtFullCollection用于指定在执行完Ful1</li>\n</ul>\n<p>GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p>\n<ul>\n<li>-XX:CMSFullGCsBeforecompaction 设置在执行多少次Ful1GC后对内存空间进行压缩整理。</li>\n<li>-XX:ParallelcMSThreads 设置cMs的线程数量。</li>\n</ul>\n<p>CMs默认启动的线程数是（Paralle1GCThreads+3）/4，ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</p>\n<h3 id=\"小结\">小结</h3>\n<p>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个Gc有什么不同呢？</p>\n<p>请记住以下口令：</p>\n<ul>\n<li>如果你想要最小化地使用内存和并行开销，请选Serial GC；</li>\n<li>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</li>\n<li>如果你想要最小化GC的中断或停顿时间，请选CMs GC。</li>\n</ul>\n<h3 id=\"JDK后续版本中CMS的变化\">JDK后续版本中CMS的变化</h3>\n<p><strong>JDK9新特性</strong>：CMS被标记为eprecate了（JEP291）&gt;如果对JDK9及以上版本的HotSpot虚拟机使用参数-XX： +UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</p>\n<p>JDK14新特性：删除CMs垃圾回收器（JEP363）移除了CMS垃圾收集器，如果在JDK14中使用 XX：+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</p>\n<h2 id=\"G1回收器-区域化分代式\">G1回收器：区域化分代式</h2>\n<h3 id=\"既然我们已经有了前面几个强大的GC-为什么还要发布Garbage-First-G1--\">既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？</h3>\n<p>原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p>\n<p>与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p>\n<p><strong>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望</strong>。</p>\n<h3 id=\"为什么名字叫-Garbage-First-G1-呢-\">为什么名字叫 Garbage First(G1)呢？</h3>\n<p>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</p>\n<p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p>\n<p>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。</p>\n<p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</p>\n<p>在JDK1.7版本正式启用，移除了Experimenta1的标识，是JDK9以后的默认垃圾回收器，取代了CMS回收器以及Paralle1+Parallel old组合。被orac1e官方称为“全功能的垃圾收集器”。</p>\n<p>与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。在jdk8中还不是默认的垃圾回收器，需要使用-xx：+UseG1GC来启用。</p>\n<h3 id=\"G1垃圾收集器的优点\">G1垃圾收集器的优点</h3>\n<p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p>\n<p><strong>并行与并发</strong></p>\n<ul>\n<li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li>\n<li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>\n</ul>\n<p><strong>分代收集</strong></p>\n<ul>\n<li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>\n<li>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</li>\n<li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li>\n</ul>\n<p>G1所谓的分代，已经不是下面这样的了</p>\n<p><img src=\"http://image.moguit.cn/e12a1513700d43ce9829d852ca322b28\" alt=\"image-20200713215105293\" /></p>\n<p>而是这样的一个区域</p>\n<p><img src=\"http://image.moguit.cn/5328b852ef4e4218b72bbd2604f0ebc5\" alt=\"image-20200713215133839\" /></p>\n<p><strong>空间整合</strong></p>\n<ul>\n<li>CMS：“标记-清除”算法、内存碎片、若干次Gc后进行一次碎片整理</li>\n<li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li>\n</ul>\n<p><strong>可预测的停顿时间模型（即：软实时soft real-time）</strong> 这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>\n<ul>\n<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>\n<li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</li>\n<li>相比于CMSGC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li>\n</ul>\n<h3 id=\"G1垃圾收集器的缺点\">G1垃圾收集器的缺点</h3>\n<p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。</p>\n<p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</p>\n<h3 id=\"G1参数设置\">G1参数设置</h3>\n<ul>\n<li>-XX:+UseG1GC：手动指定使用G1垃圾收集器执行内存回收任务</li>\n<li>-XX:G1HeapRegionSize设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</li>\n<li>-XX:MaxGCPauseMillis 设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</li>\n<li>-XX:+ParallelGcThread 设置STW工作线程数的值。最多设置为8</li>\n<li>-XX:ConcGCThreads 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGcThreads）的1/4左右。</li>\n<li>-XX:InitiatingHeapoccupancyPercent 设置触发并发Gc周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</li>\n</ul>\n<h3 id=\"G1收集器的常见操作步骤\">G1收集器的常见操作步骤</h3>\n<p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p>\n<ul>\n<li>第一步：开启G1垃圾收集器</li>\n<li>第二步：设置堆的最大内存</li>\n<li>第三步：设置最大的停顿时间</li>\n</ul>\n<p>G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Fu11GC，在不同的条件下被触发。</p>\n<h3 id=\"G1收集器的适用场景\">G1收集器的适用场景</h3>\n<p>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p>\n<p>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；</p>\n<p>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于e.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次Gc停顿时间不会过长）。 用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用61可能比CMS好：</p>\n<ul>\n<li>超过5e%的Java堆被活动数据占用；</li>\n<li>对象分配频率或年代提升频率变化很大；</li>\n<li>GC停顿时间过长（长于e.5至1秒）</li>\n</ul>\n<p>HotSpot垃圾收集器里，除了61以外，其他的垃圾收集器使用内置的JVM线程执行Gc的多线程操作，而G1GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p>\n<h3 id=\"分区Region-化整为零\">分区Region：化整为零</h3>\n<p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过</p>\n<p>XX:G1HeapRegionsize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。</p>\n<p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p>\n<p><img src=\"http://image.moguit.cn/0f3195e8412a4c04ae9f5ad301dc588a\" alt=\"image-20200713223244886\" /></p>\n<p>一个region有可能属于Eden，Survivor或者old/Tenured内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于survivor内存区域，o表示属于01d内存区域。图中空白的表示未使用的内存空间。</p>\n<p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，就放到H。</p>\n<p>**设置H的原因：**对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Fu11Gc。G1的大多数行为都把H区作为老年代的一部分来看待。</p>\n<p>每个Region都是通过指针碰撞来分配空间</p>\n<p><img src=\"http://image.moguit.cn/c06aadcef53c4becb21da57be83d1ba0\" alt=\"image-20200713223509993\" /></p>\n<h3 id=\"G1垃圾回收器的回收过程\">G1垃圾回收器的回收过程</h3>\n<p>G1GC的垃圾回收过程主要包括如下三个环节：</p>\n<ul>\n<li>年轻代GC（Young GC）</li>\n<li>老年代并发标记过程（Concurrent Marking）</li>\n<li>混合回收（Mixed GC）</li>\n</ul>\n<p>（如果需要，单线程、独占式、高强度的Fu11GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</p>\n<p><img src=\"http://image.moguit.cn/5c542594ac9444b48043f4b23c2ec44c\" alt=\"image-20200713224113996\" /></p>\n<p>顺时针，young gc-&gt;young gc+concurrent mark-&gt;Mixed GC顺序，进行垃圾回收。</p>\n<p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p>\n<p>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p>\n<p>标记完成马上开始混合回收过程。对于一个混合回收期，G1GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p>\n<p>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p>\n<h3 id=\"Remembered-Set-记忆集-\">Remembered Set（记忆集）</h3>\n<p>一个对象被不同区域引用的问题</p>\n<p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p>\n<p>在其他的分代收集器，也存在这样的问题（而G1更突出）回收新生代也不得不同时扫描老年代？这样的话会降低MinorGC的效率；</p>\n<p><strong>解决方法：</strong></p>\n<p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：</p>\n<p>每个Region都有一个对应的Remembered Set；每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；</p>\n<p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；如果不同，通过cardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p>\n<p><img src=\"http://image.moguit.cn/42f3aad6f049435381badb4c052fe176\" alt=\"image-20200713224716715\" /></p>\n<h3 id=\"G1回收过程-年轻代GC\">G1回收过程-年轻代GC</h3>\n<p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p>\n<p>YGC时，首先G1停止应用程序的执行（stop-The-Wor1d），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p>\n<p><img src=\"http://image.moguit.cn/3713efc8ca9d49f288f57a13de3ba121\" alt=\"image-20200713225100632\" /></p>\n<p>然后开始如下回收过程：</p>\n<ul>\n<li>第一阶段，扫描根</li>\n</ul>\n<p>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p>\n<ul>\n<li>第二阶段，更新RSet</li>\n</ul>\n<p>处理dirty card queue（见备注）中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。</p>\n<ul>\n<li>第三阶段，处理RSet</li>\n</ul>\n<p>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p>\n<ul>\n<li>第四阶段，复制对象。</li>\n</ul>\n<p>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到o1d区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</p>\n<ul>\n<li>第五阶段，处理引用</li>\n</ul>\n<p>处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p>\n<h3 id=\"G1回收过程-并发标记过程\">G1回收过程-并发标记过程</h3>\n<ul>\n<li>初始标记阶段：标记从根节点直接可达的对象。这个阶段是sTw的，并且会触发一次年轻代GC。</li>\n<li>根区域扫描（Root Region Scanning）：G1 Gc扫描survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在youngGC之前完成。</li>\n<li>并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被youngGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li>\n<li>再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li>\n<li>独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是sTw的。这个阶段并不会实际上去做垃圾的收集</li>\n<li>并发清理阶段：识别并清理完全空闲的区域。</li>\n</ul>\n<h3 id=\"G1回收过程---混合回收\">G1回收过程 - 混合回收</h3>\n<p>当越来越多的对象晋升到老年代o1d region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个old GC，除了回收整个Young Region，还会回收一部分的old Region。这里需要注意：<strong>是一部分老年代，而不是全部老年代</strong>。可以选择哪些o1d Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p>\n<p><img src=\"http://image.moguit.cn/127776c15dce4bc185787acf451c9f59\" alt=\"image-20200713225810871\" /></p>\n<p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收</p>\n<p>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p>\n<p>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，</p>\n<p>XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p>\n<p>混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为1e%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于1e%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</p>\n<h3 id=\"G1回收可选的过程4---Full-GC\">G1回收可选的过程4 - Full GC</h3>\n<p>G1的初衷就是要避免Fu11GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（stop-The-world），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p>\n<p>要避免Fu11GC的发生，一旦发生需要进行调整。什么时候会发生Ful1GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到ful1gc，这种情况可以通过增大内存解决。 导致61Fu11GC的原因可能有两个：</p>\n<ul>\n<li>EVacuation的时候没有足够的to-space来存放晋升的对象；</li>\n<li>并发处理过程完成之前空间耗尽。</li>\n</ul>\n<h3 id=\"G1回收的优化建议\">G1回收的优化建议</h3>\n<p>从oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>\n<p>年轻代大小</p>\n<ul>\n<li>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小</li>\n<li>固定年轻代的大小会覆盖</li>\n</ul>\n<p>暂停时间目标暂停时间目标不要太过严苛</p>\n<ul>\n<li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li>\n<li>评估G1GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>\n</ul>\n<h2 id=\"垃圾回收器总结\">垃圾回收器总结</h2>\n<p>截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p>\n<p><img src=\"http://image.moguit.cn/7bbd145aeb3e47ffbf9ef6cd472a2cc7\" alt=\"image-20200714075738203\" /></p>\n<p>GC发展阶段：Seria l=&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC</p>\n<p>不同厂商、不同版本的虚拟机实现差距比较大。HotSpot虚拟机在JDK7/8后所有收集器及组合如下图</p>\n<p><img src=\"http://image.moguit.cn/827e304bf1194104a3e824a4ab9dc384\" alt=\"image-20200714080151020\" /></p>\n<h3 id=\"怎么选择垃圾回收器\">怎么选择垃圾回收器</h3>\n<p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。怎么选择垃圾收集器？</p>\n<ul>\n<li>优先调整堆的大小让JVM自适应完成。</li>\n<li>如果内存小于100M，使用串行收集器</li>\n<li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li>\n<li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li>\n<li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li>\n<li>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li>\n</ul>\n<p>最后需要明确一个观点：</p>\n<ul>\n<li>没有最好的收集器，更没有万能的收集</li>\n<li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>\n</ul>\n<h3 id=\"面试\">面试</h3>\n<p>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。 这里较通用、基础性的部分如下：</p>\n<p>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</p>\n<p>垃圾收集器工作的基本流程。</p>\n<p>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</p>\n<h2 id=\"GC日志分析\">GC日志分析</h2>\n<p>通过阅读Gc日志，我们可以了解Java虚拟机内存分配与回收策略。 内存分配与垃圾回收的参数列表</p>\n<ul>\n<li>-XX:+PrintGc输出GC日志。类似：-verbose:gc</li>\n<li>-XX:+PrintGcDetails输出Gc的详细日志</li>\n<li>-XX:+PrintGcTimestamps 输出Gc的时间戳（以基准时间的形式）</li>\n<li>-XX:+PrintGCDatestamps 输出Gc的时间戳（以日期的形式，如2013-05-04T21：53：59.234+0800）</li>\n<li>-XX:+PrintHeapAtGC在进行Gc的前后打印出堆的信息</li>\n<li>-Xloggc:../logs/gc.1og日志文件的输出路径</li>\n</ul>\n<h3 id=\"verbose-gc\">verbose:gc</h3>\n<p>打开GC日志</p>\n<pre><code class=\"language-bash\">-verbose:gc\n\n</code></pre>\n<p>这个只会显示总的GC堆的变化，如下：</p>\n<p><img src=\"http://image.moguit.cn/6554517157554a5f956c14ab5256a8d2\" alt=\"image-20200714081610474\" /></p>\n<p>参数解析</p>\n<p><img src=\"http://image.moguit.cn/49ed4aad0976462d95fe69a111554d57\" alt=\"image-20200714081622526\" /></p>\n<h3 id=\"PrintGCDetails\">PrintGCDetails</h3>\n<p>打开GC日志</p>\n<pre><code class=\"language-bash\">-verbose:gc -XX:+PrintGCDetails\n\n</code></pre>\n<p>输入信息如下</p>\n<p><img src=\"http://image.moguit.cn/e52e549d02b54a379a9e2b01860620b8\" alt=\"image-20200714081909309\" /></p>\n<p>参数解析</p>\n<p><img src=\"http://image.moguit.cn/564fb80c36a74ead8da0d084d78d60f3\" alt=\"image-20200714081925767\" /></p>\n<h3 id=\"补充\">补充</h3>\n<ul>\n<li>[GC&quot;和&quot;[Fu11GC&quot;说明了这次垃圾收集的停顿类型，如果有&quot;Fu11&quot;则说明GC发生了&quot;stop The World&quot;</li>\n<li>使用Seria1收集器在新生代的名字是Default New Generation，因此显示的是&quot;[DefNew&quot;</li>\n<li>使用ParNew收集器在新生代的名字会变成&quot;[ParNew&quot;，意思是&quot;Parallel New Generation&quot;</li>\n<li>使用Paralle1 scavenge收集器在新生代的名字是”[PSYoungGen&quot;</li>\n<li>老年代的收集和新生代道理一样，名字也是收集器决定的</li>\n<li>使用G1收集器的话，会显示为&quot;garbage-first heap&quot;</li>\n</ul>\n<p>Allocation Failure表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p>\n<p>[PSYoungGen：5986K-&gt;696K（8704K）]5986K-&gt;704K（9216K）中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</p>\n<p>user代表用户态回收耗时，sys内核态回收耗时，rea实际耗时。由于多核的原因，时间总和可能会超过rea1时间</p>\n<h3 id=\"Young-GC图片\">Young GC图片</h3>\n<p><img src=\"http://image.moguit.cn/1d27507cd71e45aeb9a7bd66afe03115\" alt=\"image-20200714082555688\" /></p>\n<h3 id=\"FullGC图片-\">FullGC图片、</h3>\n<p><img src=\"http://image.moguit.cn/810ab4da1ff94137a22e288b83ec76a0\" alt=\"image-20200714082714690\" /></p>\n<h3 id=\"GC回收举例\">GC回收举例</h3>\n<p>我们编写一个程序，用来说明GC收集的过程</p>\n<pre><code class=\"language-java\">/**\n * GC垃圾收集过程\n * @author: 陌溪\n * @create: 2020-07-14-8:35\n */\npublic class GCUseTest {\n    static final Integer _1MB = 1024 * 1024;\n    public static void main(String[] args) {\n        byte [] allocation1, allocation2, allocation3, allocation4;\n        allocation1 = new byte[2 *_1MB];\n        allocation2 = new byte[2 *_1MB];\n        allocation3 = new byte[2 *_1MB];\n        allocation4 = new byte[4 *_1MB];\n    }\n}\n\n</code></pre>\n<p>我们设置JVM启动参数</p>\n<pre><code class=\"language-bash\">-Xms10m -Xmx10m -XX:+PrintGCDetails\n\n</code></pre>\n<p>首先我们会将3个2M的数组存放到Eden区，然后后面4M的数组来了后，将无法存储，因为Eden区只剩下2M的剩余空间了，那么将会进行一次Young GC操作，将原来Eden区的内容，存放到Survivor区，但是Survivor区也存放不下，那么就会直接晋级存入Old 区</p>\n<p><img src=\"http://image.moguit.cn/05329144e4a848539a196a911210cac2\" alt=\"image-20200714083332238\" /></p>\n<p>然后我们将4M对象存入到Eden区中</p>\n<p><img src=\"http://image.moguit.cn/bfe9a7aa4fe44611a4225ffa5907d175\" alt=\"image-20200714083526790\" /></p>\n<p>可以用一些工具去分析这些GC日志</p>\n<p>常用的日志分析工具有：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat等</p>\n<p><strong>GCViewer</strong></p>\n<p><img src=\"http://image.moguit.cn/58a5e03f426e40378c368fcad3ad7fb0\" alt=\"image-20200714084921184\" /></p>\n<p><strong>GC easy</strong></p>\n<p><img src=\"http://image.moguit.cn/ba907d5d7e2a4cf2b359bc2ee8b8f58a\" alt=\"image-20200714084726824\" /></p>\n<h2 id=\"垃圾回收器的新发展\">垃圾回收器的新发展</h2>\n<p>GC仍然处于飞速发展之中，目前的默认选项G1GC在不断的进行改进，很多我们原来认为的缺点，例如串行的Fu11GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK10以后，Fu11GC已经是并行运行，在很多场景下，其表现还略优于ParallelGC的并行Ful1GC实现。</p>\n<p>即使是SerialGC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在serverless等新的应用场景下，Serial Gc找到了新的舞台。</p>\n<p>比较不幸的是CMSGC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除</p>\n<p>Epsilon:A No-Op GarbageCollector（Epsilon垃圾回收器，&quot;No-Op（无操作）&quot;回收器）<a href=\"http://openidk.iava.net/iep\">http://openidk.iava.net/iep</a> s/318</p>\n<p>ZGC:A Scalable Low-Latency Garbage Collector（Experimental）（ZGC：可伸缩的低延迟垃圾回收器，处于实验性阶段）</p>\n<p>现在G1回收器已成为默认回收器好几年了。我们还看到了引入了两个新的收集器：ZGC（JDK11出现）和Shenandoah（Open JDK12）</p>\n<blockquote>\n<p>主打特点：低停顿时间</p>\n</blockquote>\n<h3 id=\"Open-JDK12的Shenandoash-GC\">Open JDK12的Shenandoash GC</h3>\n<p>Open JDK12的shenandoash GC：低停顿时间的GC（实验性）</p>\n<p>Shenandoah，无疑是众多GC中最孤独的一个。是第一款不由oracle公司团队领导开发的Hotspot垃圾收集器。不可避免的受到官方的排挤。比如号称openJDK和OracleJDk没有区别的Oracle公司仍拒绝在oracleJDK12中支持Shenandoah。</p>\n<p>Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，旨在针对JVM上的内存回收实现低停顿的需求。在2014年贡献给OpenJDK。</p>\n<p>Red Hat研发Shenandoah团队对外宣称，Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>\n<p><img src=\"http://image.moguit.cn/cfd6595a3f3249ec986ee9e45f1fed13\" alt=\"image-20200714090608807\" /></p>\n<p>这是RedHat在2016年发表的论文数据，测试内容是使用Es对200GB的维基百科数据进行索引。从结果看：</p>\n<blockquote>\n<p>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。 而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</p>\n</blockquote>\n<p>总结</p>\n<ul>\n<li>shenandoah Gc的弱项：高运行负担下的吞吐量下降。</li>\n<li>shenandoah GC的强项：低延迟时间。</li>\n</ul>\n<h3 id=\"革命性的ZGC\">革命性的ZGC</h3>\n<p>zGC与shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</p>\n<p>《深入理解Java虚拟机》一书中这样定义zGC：2GC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。</p>\n<p>ZGC的工作过程可以分为4个阶段：<strong>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</strong> 等。</p>\n<p>ZGC几乎在所有地方并发执行的，除了初始标记的是STw的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p>\n<p><img src=\"http://image.moguit.cn/77e579af05784c5caa5bac520e0ccfa9\" alt=\"image-20200714091201073\" /></p>\n<p>停顿时间对比</p>\n<p><img src=\"http://image.moguit.cn/83965f8a8afc4b05a22cabde793e3526\" alt=\"image-20200714091401511\" /></p>\n<p>虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。 未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</p>\n<p><img src=\"http://image.moguit.cn/f7d81d6e33424719af53019e80a519de\" alt=\"image-20200714093243028\" /></p>\n<p>JDK14之前，2GC仅Linux才支持。</p>\n<p>尽管许多使用zGc的用户都使用类Linux的环境，但在Windows和macos上，人们也需要zGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，2GC特性被移植到了Windows和macos上。</p>\n<p>现在mac或Windows上也能使用zGC了，示例如下：</p>\n<pre><code class=\"language-bash\">-XX:+UnlockExperimentalVMOptions-XX：+UseZGC\n\n</code></pre>\n<h3 id=\"AliGC\">AliGC</h3>\n<p>AliGC是阿里巴巴JVM团队基于G1算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p>\n<p><img src=\"http://image.moguit.cn/35fa2d414f1a4507aa434422f87737cc\" alt=\"image-20200714093604012\" /></p>\n<p>当然，其它厂商也提供了各种别具一格的GC实现，例如比较有名的低延迟GC Zing</p>\n', '7e0e93ea6cdb44ae92e58f48e6496ed7,15721a34adba068763b5a2fb1991fc57,5626932d452c2ad863d9b3cb0b69d22d', 35, 1, '828227a0f1c736ea393fa4a747b1c5d9', 1, '2020-08-18 00:57:36', '2020-11-13 09:35:25', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', 'db0d64ea7df409de5d2d747927cfa1a5', 0, '1', 0, 1, 0, NULL, 3, NULL, 0);
INSERT INTO `t_blog` VALUES ('1207aad62c503ec2881156c846f7a8c3', '利用jenkins远程部署sprincloud项目到docker中运行（一）-利用jenkins远程部署sprincloud项目到docker中运行一', '利用jenkins远程部署sprincloud项目到docker中运行（一）-利用jenkins远程部署sprincloud项目到docker中运行一', '<pre class=\"vditor-yml-front-matter\"><code class=\"language-yaml\">title: 利用jenkins远程部署sprincloud项目到docker中运行（一） date: 2021-04-10 21:46:39.0 updated: 2021-04-12 12:41:59.62 url: [http://halo.chenmx.net/archives/利用jenkins远程部署sprincloud项目到docker中运行一](http://halo.chenmx.net/archives/利用jenkins远程部署sprincloud项目到docker中运行一) categories: docker | jenkins使用技巧 | spring tags: docker | jenkins | Spring\n---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n### 利用jenkins部署springcloud项目（Maven父子项目）\n\n* 因为是maven父子项目的缘故，我们这里先整体构建父项目，这样的话各个子项目的jar包也会同时打包好，然后再分别利用jenkins自动部署各个子项目\n* 新建一个maven项目![image-20210410113046483](http://qiniu.chenmx.net/d7387432807c4353a6831397fd6ce530)\n* 我的项目是存储在Gitee，所以还需要去插件管理下载[^Gitee插件](![image-20210410115702876](C:\\Users\\Ray\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210410115702876.png))，安装完成后到全局管理中[^配置Gitee](![image-20210410120117450](C:\\Users\\Ray\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210410120117450.png))的用户名、密码等。![image-20210410113642698](http://qiniu.chenmx.net/d401a40cad9745c289097b903061593d)\n* 配置项目地址，选择需要构建的分支，不指定的话默认master分支![image-20210410113823363](http://qiniu.chenmx.net/a4d4d92248ac4a199dda31eed5569fc1)\n* ![image-20210410114200804](http://qiniu.chenmx.net/bcf3faf31d744b6fbd9dabe7b4cef139)我们到Gitee上，找到自己的项目配置webhook，这样在你推送指定分支代码的时候就可以自动构建了![image-20210410114400407](http://qiniu.chenmx.net/963ee1a02bed446091c5d78fd4cd88b0)![image-20210410114558744](http://qiniu.chenmx.net/df13a64a74784c629265e6939dc9079a)\n* WebHook密码处也是填写jenkins中自动生成的密码![image-20210410114818791](http://qiniu.chenmx.net/eaa7387981f34ab98cf81a37bb76f493)\n* ![构建环境](http://qiniu.chenmx.net/05538293d71f48bf934f2ec977ac2c83)\n* 到此配置完成，你可以尝试推送一次变更到远程分支，检查下jenkins任务是否可以自动构建。![image-20210410115113925](http://qiniu.chenmx.net/382bce3424434524bc9bd9ced03bc1f2)\n* 利用Jenkins构建前端篇[利用jenkins自动构建前端项目](http://blog.chenmx.net/#/info?blogUid=2dd3f1a7789049fb2eb5e92b2c57ac2b)\n* 利用Jenkins构建Maven父子项目-子项目篇[利用jenkins自动构建springcloud项目（二）](http://blog.chenmx.net/#/info?blogUid=aee0db4cb70f1792df49e9791d89eea8)</code></pre>\n', '5626932d452c2ad863d9b3cb0b69d22d', 2, 0, 'd134bdfe255b9aa8c2ce44da8297f6a6', 1, '2021-04-12 16:44:31', '2021-05-17 10:32:48', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 57, NULL, 0);
INSERT INTO `t_blog` VALUES ('12334d21386fee363afd7831d6369f75', 'Go语言安装', 'Go语言安装', '<h1>Windows下Go语言的安装</h1>\n<h2>前言</h2>\n<p>这阵子因为以后工作的原因，所以开始了go语言的学习之旅，工欲善其事必先利其器，首先就得把go语言环境搭建完成</p>\n<h2>下载Go</h2>\n<p>因为go语言的官网经常打不开，所以我就找了一个 <a href=\"https://studygolang.com/dl\">镜像网站</a>，里面有很多版本的Go语言，选择自己合适的，比如我的是Windows电脑，所以我选中里面的Windows版本的</p>\n<p><img src=\"images/image-20200718111751694.png\" alt=\"image-20200718111751694\" /></p>\n<p>下载完成是一个安装文件，我们需要进行安装，同时需要注意的就是安装目录，因为事后还需要配置环境变量，下面是安装成功后的图片</p>\n<p><img src=\"images/image-20200718111822269.png\" alt=\"image-20200718111822269\" /></p>\n<h2>配置环境变量</h2>\n<p>根据windows系统在查找可执行程序的原理，可以将Go所在路径定义到环境变量中，让系统帮我们去找运行的执行程序，这样在任何目录下都可以执行go指令，需要配置的环境变量有：</p>\n<table>\n<thead>\n<tr><th>环境变量</th><th>说明</th></tr>\n</thead>\n<tbody>\n<tr><td>GOROOT</td><td>指定SDK的安装目录</td></tr>\n<tr><td>Path</td><td>添加SDK的/bin目录</td></tr>\n<tr><td>GOPATH</td><td>工作目录</td></tr>\n</tbody>\n</table>\n<p>这里面有几个重要的环境变量</p>\n<ul>\n<li><strong>GOPATH</strong>：在1.11版本之前，是我们书写项目的工作目录。在1.11版本之后它内部存储的是我们go.mod下载的依赖包。</li>\n<li><strong>GOROOT</strong>：Go语言的安装目录，不需要我们配置</li>\n<li><strong>GOPROXY</strong>：使用mod进行包管理时候的代理</li>\n</ul>\n<p>首先我们需要打开我们的环境变量，然后添加上GOROOT</p>\n<p><img src=\"images/image-20200718151418230.png\" alt=\"image-20200718151418230\" /></p>\n<p>然后我们在PATH上添加我们的bin目录</p>\n<p><img src=\"images/image-20200718151503318.png\" alt=\"image-20200718151503318\" /></p>\n<p>添加完成后，我们输入下面的命令，查看是否配置成功</p>\n<pre><code class=\"language-bash\">go version\n</code></pre>\n<p><img src=\"images/image-20200718112254366.png\" alt=\"image-20200718112254366\" /></p>\n<h2>下载Jetbrain下的GoLang</h2>\n<p>在我们配置好环境，我们就可以使用Jetbrain公司开发的Goland编辑器了，首先进入官网下载</p>\n<p><a href=\"https://www.jetbrains.com/\">https://www.jetbrains.com/</a></p>\n<p>下载完成后，进行启动</p>\n<p><img src=\"images/image-20200718150736688.png\" alt=\"image-20200718150736688\" /></p>\n<p>启动完成后，我们需要配置一下环境，点击：File -&gt;settings -&gt; GOROOT，配置一下刚刚go安装的目录</p>\n<p><img src=\"images/image-20200718151701767.png\" alt=\"image-20200718151701767\" /></p>\n<p>以及GOPATH项目所在的目录</p>\n<p><img src=\"images/image-20200718151733127.png\" alt=\"image-20200718151733127\" /></p>\n<h2>hello world</h2>\n<p>在上面的方法都完成以后，我来来输出hello world吧~</p>\n<pre><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc main() {\n	fmt.Println(&quot;hello world!&quot;)\n}\n</code></pre>\n<p>代码的说明</p>\n<ul>\n<li>go文件的后缀是.go</li>\n<li>package main：表示该hello.go文件所在的包是main，在go中，每个文件都归属与一个包</li>\n<li>import &quot;fmt&quot;：表示引入一个包，可以调用里面的函数</li>\n<li>func main()：表示程序入口，是一个主函数</li>\n</ul>\n<p>输出结果</p>\n<p><img src=\"images/image-20200718151850083.png\" alt=\"image-20200718151850083\" /></p>\n<h2>编译和执行</h2>\n<p>我们可以通过使用下面命令进行编译和执行</p>\n<pre><code class=\"language-bash\"># 编译 hello.go 后 会生成一个 hello.exe文件\ngo build hello.go\n# 运行 hello.ext\nhello.ext\n</code></pre>\n<p>需要注意的是，我们也可以使用下面的方式，来直接运行的（使用go run会比较慢，因为内部有个编译的过程）</p>\n<pre><code class=\"language-bash\">go run hello.go\n</code></pre>\n<p>但是在生产环境中，是需要先编译在执行的</p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 0, 0, 'd134bdfe255b9aa8c2ce44da8297f6a6', 1, '2021-01-14 15:38:03', '2021-01-14 15:38:03', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '0', 0, 1, 0, NULL, 41, NULL, 0);
INSERT INTO `t_blog` VALUES ('1e2164300cef164a0c7d8738bfcb441f', '新增博客2', '新增博客2', '<p>新增博客2</p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 2, 0, 'ef1ce71e5a5dab0856c13f38da976aec', 1, '2020-12-08 21:17:03', '2020-12-12 10:28:37', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 30, NULL, 0);
INSERT INTO `t_blog` VALUES ('23f05b8e79da2be47b59c2d311eb72a5', '博客', '博客', '<p>黑客</p>\n', '7e0e93ea6cdb44ae92e58f48e6496ed7', 0, 0, 'fddeb9dfc18d88c621ac01f355197c61', 0, '2021-04-12 10:24:00', '2021-04-12 10:53:08', NULL, '1', 'mogu2018', '蘑菇博客', 'db0d64ea7df409de5d2d747927cfa1a5', 0, '0', 0, 1, 0, NULL, 56, 'b486735e7b914e366840d01f049306e4', 0);
INSERT INTO `t_blog` VALUES ('2ef496a8bc4784b024d47d541d047dae', '.md', '.md', '<h1>Windows下Go语言的安装</h1>\n<h2>前言</h2>\n<p>这阵子因为以后工作的原因，所以开始了go语言的学习之旅，工欲善其事必先利其器，首先就得把go语言环境搭建完成</p>\n<h2>下载Go</h2>\n<p>因为go语言的官网经常打不开，所以我就找了一个 <a href=\"https://studygolang.com/dl\">镜像网站</a>，里面有很多版本的Go语言，选择自己合适的，比如我的是Windows电脑，所以我选中里面的Windows版本的</p>\n<p><img src=\"images/image-20200718111751694.png\" alt=\"image-20200718111751694\" /></p>\n<p>下载完成是一个安装文件，我们需要进行安装，同时需要注意的就是安装目录，因为事后还需要配置环境变量，下面是安装成功后的图片</p>\n<p><img src=\"images/image-20200718111822269.png\" alt=\"image-20200718111822269\" /></p>\n<h2>配置环境变量</h2>\n<p>根据windows系统在查找可执行程序的原理，可以将Go所在路径定义到环境变量中，让系统帮我们去找运行的执行程序，这样在任何目录下都可以执行go指令，需要配置的环境变量有：</p>\n<table>\n<thead>\n<tr><th>环境变量</th><th>说明</th></tr>\n</thead>\n<tbody>\n<tr><td>GOROOT</td><td>指定SDK的安装目录</td></tr>\n<tr><td>Path</td><td>添加SDK的/bin目录</td></tr>\n<tr><td>GOPATH</td><td>工作目录</td></tr>\n</tbody>\n</table>\n<p>这里面有几个重要的环境变量</p>\n<ul>\n<li><strong>GOPATH</strong>：在1.11版本之前，是我们书写项目的工作目录。在1.11版本之后它内部存储的是我们go.mod下载的依赖包。</li>\n<li><strong>GOROOT</strong>：Go语言的安装目录，不需要我们配置</li>\n<li><strong>GOPROXY</strong>：使用mod进行包管理时候的代理</li>\n</ul>\n<p>首先我们需要打开我们的环境变量，然后添加上GOROOT</p>\n<p><img src=\"images/image-20200718151418230.png\" alt=\"image-20200718151418230\" /></p>\n<p>然后我们在PATH上添加我们的bin目录</p>\n<p><img src=\"images/image-20200718151503318.png\" alt=\"image-20200718151503318\" /></p>\n<p>添加完成后，我们输入下面的命令，查看是否配置成功</p>\n<pre><code class=\"language-bash\">go version\n</code></pre>\n<p><img src=\"images/image-20200718112254366.png\" alt=\"image-20200718112254366\" /></p>\n<h2>下载Jetbrain下的GoLang</h2>\n<p>在我们配置好环境，我们就可以使用Jetbrain公司开发的Goland编辑器了，首先进入官网下载</p>\n<p><a href=\"https://www.jetbrains.com/\">https://www.jetbrains.com/</a></p>\n<p>下载完成后，进行启动</p>\n<p><img src=\"images/image-20200718150736688.png\" alt=\"image-20200718150736688\" /></p>\n<p>启动完成后，我们需要配置一下环境，点击：File -&gt;settings -&gt; GOROOT，配置一下刚刚go安装的目录</p>\n<p><img src=\"images/image-20200718151701767.png\" alt=\"image-20200718151701767\" /></p>\n<p>以及GOPATH项目所在的目录</p>\n<p><img src=\"images/image-20200718151733127.png\" alt=\"image-20200718151733127\" /></p>\n<h2>hello world</h2>\n<p>在上面的方法都完成以后，我来来输出hello world吧~</p>\n<pre><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc main() {\n	fmt.Println(&quot;hello world!&quot;)\n}\n</code></pre>\n<p>代码的说明</p>\n<ul>\n<li>go文件的后缀是.go</li>\n<li>package main：表示该hello.go文件所在的包是main，在go中，每个文件都归属与一个包</li>\n<li>import &quot;fmt&quot;：表示引入一个包，可以调用里面的函数</li>\n<li>func main()：表示程序入口，是一个主函数</li>\n</ul>\n<p>输出结果</p>\n<p><img src=\"images/image-20200718151850083.png\" alt=\"image-20200718151850083\" /></p>\n<h2>编译和执行</h2>\n<p>我们可以通过使用下面命令进行编译和执行</p>\n<pre><code class=\"language-bash\"># 编译 hello.go 后 会生成一个 hello.exe文件\ngo build hello.go\n# 运行 hello.ext\nhello.ext\n</code></pre>\n<p>需要注意的是，我们也可以使用下面的方式，来直接运行的（使用go run会比较慢，因为内部有个编译的过程）</p>\n<pre><code class=\"language-bash\">go run hello.go\n</code></pre>\n<p>但是在生产环境中，是需要先编译在执行的</p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 0, 0, 'd134bdfe255b9aa8c2ce44da8297f6a6', 1, '2021-01-14 15:24:34', '2021-01-14 15:24:34', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '0', 0, 1, 0, NULL, 40, NULL, 0);
INSERT INTO `t_blog` VALUES ('31ba99fe46e0bddb4db1e50ed97fcf22', '相关概念', '相关概念', '<p>JavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJava</p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 2, 0, '70f5b89fe70a28d95e10c19c96bf2e85', 1, '2020-12-08 21:17:27', '2020-12-26 16:07:53', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 31, NULL, 0);
INSERT INTO `t_blog` VALUES ('32945390483577a0309fe72ee4425870', '微信扫码关注陌溪', '微信扫码关注陌溪', '<p>今天的天气还可以呢~</p>\n<p><a href=\"http://www.baidu.com\">测试</a></p>\n', '7e0e93ea6cdb44ae92e58f48e6496ed7', 1, 0, '447a45547828a30e77081df12131e83f', 1, '2021-04-12 09:02:28', '2021-04-12 16:20:43', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', '093d8bdd01c84890a928e923d5c235fe', 1, '1', 4, 1, 0, NULL, 52, 'b486735e7b914e366840d01f049306e4', 0);
INSERT INTO `t_blog` VALUES ('33f5cafa9191688952105f11bc9a9f9d', '默认标题1', '默认简介1', '<h1 id=\"Gin内容介绍\">Gin内容介绍</h1>\n<h2 id=\"参考\">参考</h2>\n<p>参考博客和文档：</p>\n<ul>\n<li><a href=\"https://www.liwenzhou.com/posts/Go/Gin_framework/\">Gin框架介绍及使用</a></li>\n<li><a href=\"https://gin-gonic.com/zh-cn/docs/\">Gin中文文档</a></li>\n</ul>\n<h2 id=\"主要内容\">主要内容</h2>\n<p>本教程主要从下面几个方面来进行讲解</p>\n<ul>\n<li>Gin框架基本使用</li>\n<li>GORM基本使用</li>\n<li>Web开发项目实战</li>\n</ul>\n<h2 id=\"关于Web\">关于Web</h2>\n<ul>\n<li>Web是基于HTTP协议进行交互的应用网络</li>\n<li>Web就是通过使用浏览器/APP访问的各种资源</li>\n</ul>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/9/23/1600821565137.png\" alt=\"image-20200913201627904\" />一个请求对应一个响应，以淘宝网为例，我们输入一个url，就会返回一个页面</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/9/23/1600821566129.png\" alt=\"image-20200913201929752\" /></p>\n<h2 id=\"创建项目\">创建项目</h2>\n<p>首先我们使用Goland创建一个Go项目</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/9/23/1600821566179.png\" alt=\"image-20200913202119089\" /></p>\n<p>创建完成后，打开命令窗口，输入下面的命令，创建一个依赖管理</p>\n<pre><code class=\"language-bash\">go mod init gin_demo\n\n</code></pre>\n<p>然后打开setting页面，勾选这个选项【不勾选会导致go.mod依赖爆红】</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/9/23/1600821566378.png\" alt=\"image-20200913210316077\" /></p>\n<p>我们创建一个main.go文件，然后使用go代码实现一个请求和响应</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n	&quot;fmt&quot;\n	&quot;net/http&quot;\n)\n\n// http.ResponseWriter：代表响应，传递到前端的\n// *http.Request：表示请求，从前端传递过来的\nfunc sayHello(w http.ResponseWriter, r *http.Request) {\n	_, _ = fmt.Fprintln(w, &quot;hello Golang!&quot;);\n}\n\nfunc main() {\n	http.HandleFunc(&quot;/hello&quot;, sayHello)\n	err := http.ListenAndServe(&quot;:9090&quot;, nil)\n	if err != nil {\n		fmt.Println(&quot;http server failed, err:%v \\n&quot;, err)\n		return\n	}\n}\n\n</code></pre>\n<p>在浏览器访问如下地址</p>\n<pre><code class=\"language-bash\">http://localhost:9090/hello\n\n</code></pre>\n<p>就能打开我们的hello golang页面了</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/9/23/1600821566240.png\" alt=\"image-20200913203807251\" /></p>\n<p>我们可以给文字添加色彩</p>\n<pre><code class=\"language-bash\">// http.ResponseWriter：代表响应，传递到前端的\n// *http.Request：表示请求，从前端传递过来的\nfunc sayHello(w http.ResponseWriter, r *http.Request) {\n	_, _ = fmt.Fprintln(w, &quot;&lt;h1 style=\'color:red\'&gt;hello Golang!&lt;h1&gt;&quot;);\n}\n\n</code></pre>\n<p>然后重启后，在刷新</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/9/23/1600821566300.png\" alt=\"image-20200913203922973\" /></p>\n<p>我们还可以把里面的字符串放在一个文件里，我们定义一个 hello.html文件</p>\n<pre><code class=\"language-html\">&lt;html&gt;\n    &lt;title&gt;hello golang&lt;/title&gt;\n    &lt;body&gt;\n        &lt;h1 style=\'color:red\'&gt;\n            hello Golang!\n        &lt;/h1&gt;\n        &lt;h1&gt;\n            hello gin!\n        &lt;/h1&gt;\n        &lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600011052622&amp;di=9aeee5de695a40c8d469f0c3980c2d48&amp;imgtype=0&amp;src=http%3A%2F%2Fa4.att.hudong.com%2F22%2F59%2F19300001325156131228593878903.jpg&quot;&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n\n\n</code></pre>\n<p>然后修改刚刚的main.go，使用 ioutil解析文件</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n	&quot;fmt&quot;\n	&quot;io/ioutil&quot;\n	&quot;net/http&quot;\n)\n\n// http.ResponseWriter：代表响应，传递到前端的\n// *http.Request：表示请求，从前端传递过来的\nfunc sayHello(w http.ResponseWriter, r *http.Request) {\n	html, _ := ioutil.ReadFile(&quot;./template/hello.html&quot;)\n	_, _ = fmt.Fprintln(w, string(html));\n}\n\nfunc main() {\n	http.HandleFunc(&quot;/hello&quot;, sayHello)\n	err := http.ListenAndServe(&quot;:9090&quot;, nil)\n	if err != nil {\n		fmt.Println(&quot;http server failed, err:%v \\n&quot;, err)\n		return\n	}\n}\n\n</code></pre>\n<p>最后刷新我们的页面，就出来这样的效果了，这就是我们通过golang开发的一个Web页面</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/9/23/1600821566328.png\" alt=\"image-20200913204456513\" /></p>\n<h2 id=\"为什么要用框架\">为什么要用框架</h2>\n<p>我们通过上面的http包，就能够实现一个web的开发，那为什么还要用gin呢？</p>\n<p>其实框架的好处，就是别人帮我们搭建了一个舞台，同时提供了很多现成的轮子，让我们专注于业务的开发，同时让开发效率更高。</p>\n<h2 id=\"Gin框架介绍\">Gin框架介绍</h2>\n<p><code>Gin</code>是一个用Go语言编写的web框架。它是一个类似于 <code>martini</code>但拥有更好性能的API框架, 由于使用了 <code>httprouter</code>，速度提高了近40倍。 如果你是性能和高效的追求者, 你会爱上 <code>Gin</code>。</p>\n<p>Go世界里最流行的Web框架，<a href=\"https://github.com/gin-gonic/gin\">Github</a>上有 <code>32K+</code>star。 基于<a href=\"https://github.com/julienschmidt/httprouter\">httprouter</a>开发的Web框架。 <a href=\"https://gin-gonic.com/zh-cn/docs/\">中文文档</a>齐全，简单易用的轻量级框架。</p>\n<h2 id=\"Gin框架安装与使用\">Gin框架安装与使用</h2>\n<h3 id=\"安装\">安装</h3>\n<p>下载并安装 <code>Gin</code>:</p>\n<pre><code class=\"language-bash\">go get -u github.com/gin-gonic/gin\n\n</code></pre>\n<h3 id=\"第一个Gin示例-\">第一个Gin示例：</h3>\n<pre><code class=\"language-golang\">package main\n\nimport (\n	&quot;github.com/gin-gonic/gin&quot;\n)\n\nfunc main() {\n	// 创建一个默认的路由引擎\n	r := gin.Default()\n	// GET：请求方式；/hello：请求的路径\n	// 当客户端以GET方法请求/hello路径时，会执行后面的匿名函数\n	r.GET(&quot;/hello&quot;, func(c *gin.Context) {\n		// c.JSON：返回JSON格式的数据\n		c.JSON(200, gin.H{\n			&quot;message&quot;: &quot;Hello world!&quot;,\n		})\n	})\n	// 启动HTTP服务，默认在0.0.0.0:8080启动服务\n	r.Run()\n}\n\n</code></pre>\n<p>将上面的代码保存并编译执行，然后使用浏览器打开 <code>127.0.0.1:8080/hello</code>就能看到一串JSON字符串。</p>\n<h2 id=\"RESTful-API\">RESTful API</h2>\n<p>REST与技术无关，代表的是一种软件架构风格，REST是Representational State Transfer的简称，中文翻译为“表征状态转移”或“表现层状态转化”。</p>\n<p>推荐阅读<a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\">阮一峰 理解RESTful架构</a></p>\n<p>简单来说，REST的含义就是客户端与Web服务器之间进行交互的时候，使用HTTP协议中的4个请求方法代表不同的动作。</p>\n<ul>\n<li><code>GET</code>用来获取资源</li>\n<li><code>POST</code>用来新建资源</li>\n<li><code>PUT</code>用来更新资源</li>\n<li><code>DELETE</code>用来删除资源。</li>\n</ul>\n<p>只要API程序遵循了REST风格，那就可以称其为RESTful API。目前在前后端分离的架构中，前后端基本都是通过RESTful API来进行交互。</p>\n<p>例如，我们现在要编写一个管理书籍的系统，我们可以查询对一本书进行查询、创建、更新和删除等操作，我们在编写程序的时候就要设计客户端浏览器与我们Web服务端交互的方式和路径。按照经验我们通常会设计成如下模式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">请求方法</th>\n<th align=\"center\">URL</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">GET</td>\n<td align=\"center\">/book</td>\n<td align=\"center\">查询书籍信息</td>\n</tr>\n<tr>\n<td align=\"center\">POST</td>\n<td align=\"center\">/create_book</td>\n<td align=\"center\">创建书籍记录</td>\n</tr>\n<tr>\n<td align=\"center\">POST</td>\n<td align=\"center\">/update_book</td>\n<td align=\"center\">更新书籍信息</td>\n</tr>\n<tr>\n<td align=\"center\">POST</td>\n<td align=\"center\">/delete_book</td>\n<td align=\"center\">删除书籍信息</td>\n</tr>\n</tbody>\n</table>\n<p>同样的需求我们按照RESTful API设计如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">请求方法</th>\n<th align=\"center\">URL</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">GET</td>\n<td align=\"center\">/book</td>\n<td align=\"center\">查询书籍信息</td>\n</tr>\n<tr>\n<td align=\"center\">POST</td>\n<td align=\"center\">/book</td>\n<td align=\"center\">创建书籍记录</td>\n</tr>\n<tr>\n<td align=\"center\">PUT</td>\n<td align=\"center\">/book</td>\n<td align=\"center\">更新书籍信息</td>\n</tr>\n<tr>\n<td align=\"center\">DELETE</td>\n<td align=\"center\">/book</td>\n<td align=\"center\">删除书籍信息</td>\n</tr>\n</tbody>\n</table>\n<p>Gin框架支持开发RESTful API的开发。</p>\n<pre><code class=\"language-go\">func main() {\n	r := gin.Default()\n	r.GET(&quot;/book&quot;, func(c *gin.Context) {\n		c.JSON(200, gin.H{\n			&quot;message&quot;: &quot;GET&quot;,\n		})\n	})\n\n	r.POST(&quot;/book&quot;, func(c *gin.Context) {\n		c.JSON(200, gin.H{\n			&quot;message&quot;: &quot;POST&quot;,\n		})\n	})\n\n	r.PUT(&quot;/book&quot;, func(c *gin.Context) {\n		c.JSON(200, gin.H{\n			&quot;message&quot;: &quot;PUT&quot;,\n		})\n	})\n\n	r.DELETE(&quot;/book&quot;, func(c *gin.Context) {\n		c.JSON(200, gin.H{\n			&quot;message&quot;: &quot;DELETE&quot;,\n		})\n	})\n  \n   	// 启动HTTP服务，默认在0.0.0.0:8080启动服务\n	r.Run()\n}\n\n</code></pre>\n<p>开发RESTful API的时候我们通常使用<a href=\"https://www.getpostman.com/\">Postman</a>来作为客户端的测试工具。</p>\n<h2 id=\"Gin渲染\">Gin渲染</h2>\n<h3 id=\"HTML渲染\">HTML渲染</h3>\n<p>我们首先定义一个存放模板文件的 <code>templates</code>文件夹，然后在其内部按照业务分别定义一个 <code>posts</code>文件夹和一个 <code>users</code>文件夹。 <code>posts/index.html</code>文件的内容如下：</p>\n<pre><code class=\"language-template\">{{define &quot;posts/index.html&quot;}}\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;posts/index&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    {{.title}}\n&lt;/body&gt;\n&lt;/html&gt;\n{{end}}\n\n</code></pre>\n<p><code>users/index.html</code>文件的内容如下：</p>\n<pre><code class=\"language-template\">{{define &quot;users/index.html&quot;}}\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;users/index&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    {{.title}}\n&lt;/body&gt;\n&lt;/html&gt;\n{{end}}\n\n</code></pre>\n<p>Gin框架中使用 <code>LoadHTMLGlob()</code>或者 <code>LoadHTMLFiles()</code>方法进行HTML模板渲染。</p>\n<pre><code class=\"language-go\">func main() {\n	r := gin.Default()\n	r.LoadHTMLGlob(&quot;templates/**/*&quot;)\n	//r.LoadHTMLFiles(&quot;templates/posts/index.html&quot;, &quot;templates/users/index.html&quot;)\n	r.GET(&quot;/posts/index&quot;, func(c *gin.Context) {\n		c.HTML(http.StatusOK, &quot;posts/index.html&quot;, gin.H{\n			&quot;title&quot;: &quot;posts/index&quot;,\n		})\n	})\n\n	r.GET(&quot;users/index&quot;, func(c *gin.Context) {\n		c.HTML(http.StatusOK, &quot;users/index.html&quot;, gin.H{\n			&quot;title&quot;: &quot;users/index&quot;,\n		})\n	})\n\n	r.Run(&quot;:8080&quot;)\n}\n\n</code></pre>\n<h3 id=\"自定义模板函数\">自定义模板函数</h3>\n<p>定义一个不转义相应内容的 <code>safe</code>模板函数如下：</p>\n<pre><code class=\"language-go\">func main() {\n	router := gin.Default()\n	router.SetFuncMap(template.FuncMap{\n		&quot;safe&quot;: func(str string) template.HTML{\n			return template.HTML(str)\n		},\n	})\n	router.LoadHTMLFiles(&quot;./index.tmpl&quot;)\n\n	router.GET(&quot;/index&quot;, func(c *gin.Context) {\n		c.HTML(http.StatusOK, &quot;index.tmpl&quot;, &quot;&lt;a href=\'https://liwenzhou.com\'&gt;李文周的博客&lt;/a&gt;&quot;)\n	})\n\n	router.Run(&quot;:8080&quot;)\n}\n\n</code></pre>\n<p>在 <code>index.tmpl</code>中使用定义好的 <code>safe</code>模板函数：</p>\n<pre><code class=\"language-template\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;zh-CN&quot;&gt;\n&lt;head&gt;\n    &lt;title&gt;修改模板引擎的标识符&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div&gt;{{ . | safe }}&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n<p>为了让index.tmpl文件有语法显示，我们还需要配置一下</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/9/23/1600821566450.png\" alt=\"image-20200913213156919\" /></p>\n<p>然后我们加入 *.tmpl，保存即可</p>\n<h3 id=\"静态文件处理\">静态文件处理</h3>\n<p>当我们渲染的HTML文件中引用了静态文件时，我们只需要按照以下方式在渲染页面前调用 <code>gin.Static</code>方法即可。</p>\n<pre><code class=\"language-go\">func main() {\n	r := gin.Default()\n	r.Static(&quot;/static&quot;, &quot;./static&quot;)\n	r.LoadHTMLGlob(&quot;templates/**/*&quot;)\n   // ...\n	r.Run(&quot;:8080&quot;)\n}\n\n</code></pre>\n<h3 id=\"使用模板继承\">使用模板继承</h3>\n<p>Gin框架默认都是使用单模板，如果需要使用 <code>block template</code>功能，可以通过 <code>&quot;github.com/gin-contrib/multitemplate&quot;</code>库实现，具体示例如下：</p>\n<p>首先，假设我们项目目录下的templates文件夹下有以下模板文件，其中 <code>home.tmpl</code>和 <code>index.tmpl</code>继承了 <code>base.tmpl</code>：</p>\n<pre><code class=\"language-bash\">templates\n├── includes\n│   ├── home.tmpl\n│   └── index.tmpl\n├── layouts\n│   └── base.tmpl\n└── scripts.tmpl\n\n</code></pre>\n<p>然后我们定义一个 <code>loadTemplates</code>函数如下：</p>\n<pre><code class=\"language-go\">func loadTemplates(templatesDir string) multitemplate.Renderer {\n	r := multitemplate.NewRenderer()\n	layouts, err := filepath.Glob(templatesDir + &quot;/layouts/*.tmpl&quot;)\n	if err != nil {\n		panic(err.Error())\n	}\n	includes, err := filepath.Glob(templatesDir + &quot;/includes/*.tmpl&quot;)\n	if err != nil {\n		panic(err.Error())\n	}\n	// 为layouts/和includes/目录生成 templates map\n	for _, include := range includes {\n		layoutCopy := make([]string, len(layouts))\n		copy(layoutCopy, layouts)\n		files := append(layoutCopy, include)\n		r.AddFromFiles(filepath.Base(include), files...)\n	}\n	return r\n}\n\n</code></pre>\n<p>我们在 <code>main</code>函数中</p>\n<pre><code class=\"language-go\">func indexFunc(c *gin.Context){\n	c.HTML(http.StatusOK, &quot;index.tmpl&quot;, nil)\n}\n\nfunc homeFunc(c *gin.Context){\n	c.HTML(http.StatusOK, &quot;home.tmpl&quot;, nil)\n}\n\nfunc main(){\n	r := gin.Default()\n	r.HTMLRender = loadTemplates(&quot;./templates&quot;)\n	r.GET(&quot;/index&quot;, indexFunc)\n	r.GET(&quot;/home&quot;, homeFunc)\n	r.Run()\n}\n\n</code></pre>\n<h3 id=\"补充文件路径处理\">补充文件路径处理</h3>\n<p>关于模板文件和静态文件的路径，我们需要根据公司/项目的要求进行设置。可以使用下面的函数获取当前执行程序的路径。</p>\n<pre><code class=\"language-go\">func getCurrentPath() string {\n	if ex, err := os.Executable(); err == nil {\n		return filepath.Dir(ex)\n	}\n	return &quot;./&quot;\n}\n\n</code></pre>\n<h3 id=\"JSON渲染\">JSON渲染</h3>\n<pre><code class=\"language-go\">func main() {\n	r := gin.Default()\n\n	// gin.H 是map[string]interface{}的缩写\n	r.GET(&quot;/someJSON&quot;, func(c *gin.Context) {\n		// 方式一：自己拼接JSON\n		c.JSON(http.StatusOK, gin.H{&quot;message&quot;: &quot;Hello world!&quot;})\n	})\n	r.GET(&quot;/moreJSON&quot;, func(c *gin.Context) {\n		// 方法二：使用结构体\n		var msg struct {\n			Name    string `json:&quot;user&quot;`\n			Message string\n			Age     int\n		}\n		msg.Name = &quot;小王子&quot;\n		msg.Message = &quot;Hello world!&quot;\n		msg.Age = 18\n		c.JSON(http.StatusOK, msg)\n	})\n	r.Run(&quot;:8080&quot;)\n}\n\n</code></pre>\n<h3 id=\"XML渲染\">XML渲染</h3>\n<p>注意需要使用具名的结构体类型。</p>\n<pre><code class=\"language-go\">func main() {\n	r := gin.Default()\n	// gin.H 是map[string]interface{}的缩写\n	r.GET(&quot;/someXML&quot;, func(c *gin.Context) {\n		// 方式一：自己拼接JSON\n		c.XML(http.StatusOK, gin.H{&quot;message&quot;: &quot;Hello world!&quot;})\n	})\n	r.GET(&quot;/moreXML&quot;, func(c *gin.Context) {\n		// 方法二：使用结构体\n		type MessageRecord struct {\n			Name    string\n			Message string\n			Age     int\n		}\n		var msg MessageRecord\n		msg.Name = &quot;小王子&quot;\n		msg.Message = &quot;Hello world!&quot;\n		msg.Age = 18\n		c.XML(http.StatusOK, msg)\n	})\n	r.Run(&quot;:8080&quot;)\n}\n\n</code></pre>\n<h3 id=\"YMAL渲染\">YMAL渲染</h3>\n<pre><code class=\"language-go\">r.GET(&quot;/someYAML&quot;, func(c *gin.Context) {\n	c.YAML(http.StatusOK, gin.H{&quot;message&quot;: &quot;ok&quot;, &quot;status&quot;: http.StatusOK})\n})\n\n</code></pre>\n<h3 id=\"protobuf渲染\">protobuf渲染</h3>\n<pre><code class=\"language-go\">r.GET(&quot;/someProtoBuf&quot;, func(c *gin.Context) {\n	reps := []int64{int64(1), int64(2)}\n	label := &quot;test&quot;\n	// protobuf 的具体定义写在 testdata/protoexample 文件中。\n	data := &amp;protoexample.Test{\n		Label: &amp;label,\n		Reps:  reps,\n	}\n	// 请注意，数据在响应中变为二进制数据\n	// 将输出被 protoexample.Test protobuf 序列化了的数据\n	c.ProtoBuf(http.StatusOK, data)\n})\n\n</code></pre>\n<h2 id=\"获取参数\">获取参数</h2>\n<h3 id=\"获取querystring参数\">获取querystring参数</h3>\n<p><code>querystring</code>指的是URL中 <code>?</code>后面携带的参数，例如：<code>/user/search?username=小王子&amp;address=沙河</code>。 获取请求的querystring参数的方法如下：</p>\n<pre><code class=\"language-go\">func main() {\n	//Default返回一个默认的路由引擎\n	r := gin.Default()\n	r.GET(&quot;/user/search&quot;, func(c *gin.Context) {\n        // 可以添加默认值\n		username := c.DefaultQuery(&quot;username&quot;, &quot;小王子&quot;)\n		//username := c.Query(&quot;username&quot;)\n		address := c.Query(&quot;address&quot;)\n		//输出json结果给调用方\n		c.JSON(http.StatusOK, gin.H{\n			&quot;message&quot;:  &quot;ok&quot;,\n			&quot;username&quot;: username,\n			&quot;address&quot;:  address,\n		})\n	})\n	r.Run()\n}\n\n</code></pre>\n<p>我们输入对应的URL，就能获取到对应的参数了</p>\n<pre><code class=\"language-bash\">http://localhost:9090/web?username=小王子&amp;address=沙河\n\n</code></pre>\n<h3 id=\"获取form参数\">获取form参数</h3>\n<p>请求的数据通过form表单来提交，例如向 <code>/user/search</code>发送一个POST请求，获取请求数据的方式如下：</p>\n<pre><code class=\"language-go\">func main() {\n	//Default返回一个默认的路由引擎\n	r := gin.Default()\n	r.POST(&quot;/user/search&quot;, func(c *gin.Context) {\n		// DefaultPostForm取不到值时会返回指定的默认值\n		//username := c.DefaultPostForm(&quot;username&quot;, &quot;小王子&quot;)\n		username := c.PostForm(&quot;username&quot;)\n		address := c.PostForm(&quot;address&quot;)\n		//输出json结果给调用方\n		c.JSON(http.StatusOK, gin.H{\n			&quot;message&quot;:  &quot;ok&quot;,\n			&quot;username&quot;: username,\n			&quot;address&quot;:  address,\n		})\n	})\n	r.Run(&quot;:8080&quot;)\n}\n\n</code></pre>\n<h3 id=\"获取path参数\">获取path参数</h3>\n<p>请求的参数通过URL路径传递，例如：<code>/user/search/小王子/沙河</code>。 获取请求URL路径中的参数的方式如下。</p>\n<pre><code class=\"language-go\">func main() {\n	//Default返回一个默认的路由引擎\n	r := gin.Default()\n	r.GET(&quot;/user/search/:username/:address&quot;, func(c *gin.Context) {\n		username := c.Param(&quot;username&quot;)\n		address := c.Param(&quot;address&quot;)\n		//输出json结果给调用方\n		c.JSON(http.StatusOK, gin.H{\n			&quot;message&quot;:  &quot;ok&quot;,\n			&quot;username&quot;: username,\n			&quot;address&quot;:  address,\n		})\n	})\n\n	r.Run(&quot;:8080&quot;)\n}\n\n</code></pre>\n<h3 id=\"参数绑定\">参数绑定</h3>\n<p>为了能够更方便的获取请求相关参数，提高开发效率，我们可以基于请求的 <code>Content-Type</code>识别请求数据类型并利用反射机制自动提取请求中 <code>QueryString</code>、<code>form表单</code>、<code>JSON</code>、<code>XML</code>等参数到结构体中。 下面的示例代码演示了 <code>.ShouldBind()</code>强大的功能，它能够基于请求自动提取 <code>JSON</code>、<code>form表单</code>和 <code>QueryString</code>类型的数据，并把值绑定到指定的结构体对象。</p>\n<pre><code class=\"language-go\">// Binding from JSON\ntype Login struct {\n	User     string `form:&quot;user&quot; json:&quot;user&quot; binding:&quot;required&quot;`\n	Password string `form:&quot;password&quot; json:&quot;password&quot; binding:&quot;required&quot;`\n}\n\nfunc main() {\n	router := gin.Default()\n\n	// 绑定JSON的示例 ({&quot;user&quot;: &quot;q1mi&quot;, &quot;password&quot;: &quot;123456&quot;})\n	router.POST(&quot;/loginJSON&quot;, func(c *gin.Context) {\n		var login Login\n\n		if err := c.ShouldBind(&amp;login); err == nil {\n			fmt.Printf(&quot;login info:%#v\\n&quot;, login)\n			c.JSON(http.StatusOK, gin.H{\n				&quot;user&quot;:     login.User,\n				&quot;password&quot;: login.Password,\n			})\n		} else {\n			c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})\n		}\n	})\n\n	// 绑定form表单示例 (user=q1mi&amp;password=123456)\n	router.POST(&quot;/loginForm&quot;, func(c *gin.Context) {\n		var login Login\n		// ShouldBind()会根据请求的Content-Type自行选择绑定器\n		if err := c.ShouldBind(&amp;login); err == nil {\n			c.JSON(http.StatusOK, gin.H{\n				&quot;user&quot;:     login.User,\n				&quot;password&quot;: login.Password,\n			})\n		} else {\n			c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})\n		}\n	})\n\n	// 绑定QueryString示例 (/loginQuery?user=q1mi&amp;password=123456)\n	router.GET(&quot;/loginForm&quot;, func(c *gin.Context) {\n		var login Login\n		// ShouldBind()会根据请求的Content-Type自行选择绑定器\n		if err := c.ShouldBind(&amp;login); err == nil {\n			c.JSON(http.StatusOK, gin.H{\n				&quot;user&quot;:     login.User,\n				&quot;password&quot;: login.Password,\n			})\n		} else {\n			c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})\n		}\n	})\n\n	// Listen and serve on 0.0.0.0:8080\n	router.Run(&quot;:8080&quot;)\n}\n\n</code></pre>\n<p><code>ShouldBind</code>会按照下面的顺序解析请求中的数据完成绑定：</p>\n<ol>\n<li>如果是<code>GET</code> 请求，只使用<code>Form</code> 绑定引擎（<code>query</code>）。</li>\n<li>如果是<code>POST</code> 请求，首先检查<code>content-type</code> 是否为<code>JSON</code> 或<code>XML</code>，然后再使用<code>Form</code>（<code>form-data</code>）。</li>\n</ol>\n<h2 id=\"文件上传\">文件上传</h2>\n<h3 id=\"单个文件上传\">单个文件上传</h3>\n<p>文件上传前端页面代码：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;zh-CN&quot;&gt;\n&lt;head&gt;\n    &lt;title&gt;上传文件示例&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;\n    &lt;input type=&quot;file&quot; name=&quot;f1&quot;&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n<p>后端gin框架部分代码：</p>\n<pre><code class=\"language-go\">func main() {\n	router := gin.Default()\n	// 处理multipart forms提交文件时默认的内存限制是32 MiB\n	// 可以通过下面的方式修改\n	// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB\n	router.POST(&quot;/upload&quot;, func(c *gin.Context) {\n		// 单个文件\n		file, err := c.FormFile(&quot;f1&quot;)\n		if err != nil {\n			c.JSON(http.StatusInternalServerError, gin.H{\n				&quot;message&quot;: err.Error(),\n			})\n			return\n		}\n\n		log.Println(file.Filename)\n		dst := fmt.Sprintf(&quot;C:/tmp/%s&quot;, file.Filename)\n		// 上传文件到指定的目录\n		c.SaveUploadedFile(file, dst)\n		c.JSON(http.StatusOK, gin.H{\n			&quot;message&quot;: fmt.Sprintf(&quot;\'%s\' uploaded!&quot;, file.Filename),\n		})\n	})\n	router.Run()\n}\n\n</code></pre>\n<h3 id=\"多个文件上传\">多个文件上传</h3>\n<pre><code class=\"language-go\">func main() {\n	router := gin.Default()\n	// 处理multipart forms提交文件时默认的内存限制是32 MiB\n	// 可以通过下面的方式修改\n	// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB\n	router.POST(&quot;/upload&quot;, func(c *gin.Context) {\n		// Multipart form\n		form, _ := c.MultipartForm()\n		files := form.File[&quot;file&quot;]\n\n		for index, file := range files {\n			log.Println(file.Filename)\n			dst := fmt.Sprintf(&quot;C:/tmp/%s_%d&quot;, file.Filename, index)\n			// 上传文件到指定的目录\n			c.SaveUploadedFile(file, dst)\n		}\n		c.JSON(http.StatusOK, gin.H{\n			&quot;message&quot;: fmt.Sprintf(&quot;%d files uploaded!&quot;, len(files)),\n		})\n	})\n	router.Run()\n}\n\n</code></pre>\n<h2 id=\"重定向\">重定向</h2>\n<h3 id=\"HTTP重定向\">HTTP重定向</h3>\n<p>HTTP 重定向很容易。 内部、外部重定向均支持。</p>\n<pre><code class=\"language-go\">r.GET(&quot;/test&quot;, func(c *gin.Context) {\n	c.Redirect(http.StatusMovedPermanently, &quot;http://www.sogo.com/&quot;)\n})\n\n</code></pre>\n<h3 id=\"路由重定向\">路由重定向</h3>\n<p>路由重定向，使用 <code>HandleContext</code>：</p>\n<pre><code class=\"language-go\">r.GET(&quot;/test&quot;, func(c *gin.Context) {\n    // 指定重定向的URL\n    c.Request.URL.Path = &quot;/test2&quot;\n    r.HandleContext(c)\n})\nr.GET(&quot;/test2&quot;, func(c *gin.Context) {\n    c.JSON(http.StatusOK, gin.H{&quot;hello&quot;: &quot;world&quot;})\n})\n\n</code></pre>\n<h2 id=\"Gin路由\">Gin路由</h2>\n<h3 id=\"普通路由\">普通路由</h3>\n<pre><code class=\"language-go\">r.GET(&quot;/index&quot;, func(c *gin.Context) {...})\nr.GET(&quot;/login&quot;, func(c *gin.Context) {...})\nr.POST(&quot;/login&quot;, func(c *gin.Context) {...})\n\n</code></pre>\n<p>此外，还有一个可以匹配所有请求方法的 <code>Any</code>方法如下：</p>\n<pre><code class=\"language-go\">r.Any(&quot;/test&quot;, func(c *gin.Context) {...})\n\n</code></pre>\n<p>为没有配置处理函数的路由添加处理程序，默认情况下它返回404代码，下面的代码为没有匹配到路由的请求都返回 <code>views/404.html</code>页面。</p>\n<pre><code class=\"language-go\">r.NoRoute(func(c *gin.Context) {\n		c.HTML(http.StatusNotFound, &quot;views/404.html&quot;, nil)\n	})\n\n</code></pre>\n<h3 id=\"路由组\">路由组</h3>\n<p>我们可以将拥有共同URL前缀的路由划分为一个路由组。习惯性一对 <code>{}</code>包裹同组的路由，这只是为了看着清晰，你用不用 <code>{}</code>包裹功能上没什么区别。</p>\n<pre><code class=\"language-go\">func main() {\n	r := gin.Default()\n	userGroup := r.Group(&quot;/user&quot;)\n	{\n		userGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...})\n		userGroup.GET(&quot;/login&quot;, func(c *gin.Context) {...})\n		userGroup.POST(&quot;/login&quot;, func(c *gin.Context) {...})\n\n	}\n	shopGroup := r.Group(&quot;/shop&quot;)\n	{\n		shopGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...})\n		shopGroup.GET(&quot;/cart&quot;, func(c *gin.Context) {...})\n		shopGroup.POST(&quot;/checkout&quot;, func(c *gin.Context) {...})\n	}\n	r.Run()\n}\n\n</code></pre>\n<p>路由组也是支持嵌套的，例如：</p>\n<pre><code class=\"language-go\">shopGroup := r.Group(&quot;/shop&quot;)\n	{\n		shopGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...})\n		shopGroup.GET(&quot;/cart&quot;, func(c *gin.Context) {...})\n		shopGroup.POST(&quot;/checkout&quot;, func(c *gin.Context) {...})\n		// 嵌套路由组\n		xx := shopGroup.Group(&quot;xx&quot;)\n		xx.GET(&quot;/oo&quot;, func(c *gin.Context) {...})\n	}\n\n</code></pre>\n<p>通常我们将路由分组用在划分业务逻辑或划分API版本时。</p>\n<h3 id=\"路由原理\">路由原理</h3>\n<p>Gin框架中的路由使用的是<a href=\"https://github.com/julienschmidt/httprouter\">httprouter</a>这个库。</p>\n<p>其基本原理就是构造一个路由地址的前缀树。</p>\n<h2 id=\"Gin中间件\">Gin中间件</h2>\n<p>Gin框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、记录日志、耗时统计等。</p>\n<h3 id=\"定义中间件\">定义中间件</h3>\n<p>Gin中的中间件必须是一个 <code>gin.HandlerFunc</code>类型。例如我们像下面的代码一样定义一个统计请求耗时的中间件。</p>\n<pre><code class=\"language-go\">// StatCost 是一个统计耗时请求耗时的中间件\nfunc StatCost() gin.HandlerFunc {\n	return func(c *gin.Context) {\n		start := time.Now()\n		c.Set(&quot;name&quot;, &quot;小王子&quot;) // 可以通过c.Set在请求上下文中设置值，后续的处理函数能够取到该值\n		// 调用该请求的剩余处理程序\n		c.Next()\n		// 不调用该请求的剩余处理程序\n		// c.Abort()\n		// 计算耗时\n		cost := time.Since(start)\n		log.Println(cost)\n	}\n}\n\n</code></pre>\n<h3 id=\"注册中间件\">注册中间件</h3>\n<p>在gin框架中，我们可以为每个路由添加任意数量的中间件。</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/9/23/1600821566511.png\" alt=\"image-20200917210942305\" /></p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/9/23/1600821566528.png\" alt=\"image-20200917211033323\" /></p>\n<p>中间的这个通过 Abort() 可以阻止执行</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/9/23/1600821566589.png\" alt=\"image-20200917211259531\" /></p>\n<h4 id=\"为全局路由注册\">为全局路由注册</h4>\n<pre><code class=\"language-go\">func main() {\n	// 新建一个没有任何默认中间件的路由\n	r := gin.New()\n	// 注册一个全局中间件\n	r.Use(StatCost())\n\n	r.GET(&quot;/test&quot;, func(c *gin.Context) {\n		name := c.MustGet(&quot;name&quot;).(string) // 从上下文取值\n		log.Println(name)\n		c.JSON(http.StatusOK, gin.H{\n			&quot;message&quot;: &quot;Hello world!&quot;,\n		})\n	})\n	r.Run()\n}\n\n</code></pre>\n<h4 id=\"为某个路由单独注册\">为某个路由单独注册</h4>\n<pre><code class=\"language-go\">// 给/test2路由单独注册中间件（可注册多个）\n	r.GET(&quot;/test2&quot;, StatCost(), func(c *gin.Context) {\n		name := c.MustGet(&quot;name&quot;).(string) // 从上下文取值\n		log.Println(name)\n		c.JSON(http.StatusOK, gin.H{\n			&quot;message&quot;: &quot;Hello world!&quot;,\n		})\n	})\n\n</code></pre>\n<h4 id=\"为路由组注册中间件\">为路由组注册中间件</h4>\n<p>为路由组注册中间件有以下两种写法。</p>\n<p>写法1：</p>\n<pre><code class=\"language-go\">shopGroup := r.Group(&quot;/shop&quot;, StatCost())\n{\n    shopGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...})\n    ...\n}\n\n</code></pre>\n<p>写法2：</p>\n<pre><code class=\"language-go\">shopGroup := r.Group(&quot;/shop&quot;)\nshopGroup.Use(StatCost())\n{\n    shopGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...})\n    ...\n}\n\n</code></pre>\n<h3 id=\"中间件注意事项\">中间件注意事项</h3>\n<h4 id=\"gin默认中间件\">gin默认中间件</h4>\n<p><code>gin.Default()</code>默认使用了 <code>Logger</code>和 <code>Recovery</code>中间件，其中：</p>\n<ul>\n<li><code>Logger</code>中间件将日志写入<code>gin.DefaultWriter</code>，即使配置了<code>GIN_MODE=release</code>。</li>\n<li><code>Recovery</code>中间件会recover任何<code>panic</code>。如果有panic的话，会写入500响应码。</li>\n</ul>\n<p>如果不想使用上面两个默认的中间件，可以使用 <code>gin.New()</code>新建一个没有任何默认中间件的路由。</p>\n<h4 id=\"gin中间件中使用goroutine\">gin中间件中使用goroutine</h4>\n<p>当在中间件或 <code>handler</code>中启动新的 <code>goroutine</code>时，<strong>不能使用</strong>原始的上下文（c *gin.Context），必须使用其只读副本（<code>c.Copy()</code>）。</p>\n<h2 id=\"运行多个服务\">运行多个服务</h2>\n<p>我们可以在多个端口启动服务，例如：</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n	&quot;log&quot;\n	&quot;net/http&quot;\n	&quot;time&quot;\n\n	&quot;github.com/gin-gonic/gin&quot;\n	&quot;golang.org/x/sync/errgroup&quot;\n)\n\nvar (\n	g errgroup.Group\n)\n\nfunc router01() http.Handler {\n	e := gin.New()\n	e.Use(gin.Recovery())\n	e.GET(&quot;/&quot;, func(c *gin.Context) {\n		c.JSON(\n			http.StatusOK,\n			gin.H{\n				&quot;code&quot;:  http.StatusOK,\n				&quot;error&quot;: &quot;Welcome server 01&quot;,\n			},\n		)\n	})\n\n	return e\n}\n\nfunc router02() http.Handler {\n	e := gin.New()\n	e.Use(gin.Recovery())\n	e.GET(&quot;/&quot;, func(c *gin.Context) {\n		c.JSON(\n			http.StatusOK,\n			gin.H{\n				&quot;code&quot;:  http.StatusOK,\n				&quot;error&quot;: &quot;Welcome server 02&quot;,\n			},\n		)\n	})\n\n	return e\n}\n\nfunc main() {\n	server01 := &amp;http.Server{\n		Addr:         &quot;:8080&quot;,\n		Handler:      router01(),\n		ReadTimeout:  5 * time.Second,\n		WriteTimeout: 10 * time.Second,\n	}\n\n	server02 := &amp;http.Server{\n		Addr:         &quot;:8081&quot;,\n		Handler:      router02(),\n		ReadTimeout:  5 * time.Second,\n		WriteTimeout: 10 * time.Second,\n	}\n   // 借助errgroup.Group或者自行开启两个goroutine分别启动两个服务\n	g.Go(func() error {\n		return server01.ListenAndServe()\n	})\n\n	g.Go(func() error {\n		return server02.ListenAndServe()\n	})\n\n	if err := g.Wait(); err != nil {\n		log.Fatal(err)\n	}\n}\n\n</code></pre>\n', '7e0e93ea6cdb44ae92e58f48e6496ed7', 1, 0, 'ffe1c088d99304a0c3e40e8421ccffbd', 0, '2020-09-23 08:39:29', '2020-10-07 16:28:33', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', 'db0d64ea7df409de5d2d747927cfa1a5', 0, '1', 0, 1, 0, NULL, 4, NULL, 0);
INSERT INTO `t_blog` VALUES ('34eb1b938fa734a52ce0f18a1b849685', '【阿里云】云服务器双11狂欢特惠，1核2G 最低仅需84.97元/年 ', '【阿里云】云服务器双11狂欢特惠，1核2G 最低仅需84.97元/年 ', '<p>【阿里云】云服务器双11狂欢特惠，1核2G 最低仅需84.97元/年&nbsp; <a href=\"https://www.aliyun.com/1111/home?userCode=w7aungxw\" target=\"_blank\">点我传送</a></p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 4, 0, 'ee5fd755a6f28df835361c005d0b867b', 1, '2020-11-07 11:09:10', '2020-12-05 11:18:35', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', '337806254f9c42999043de5c5ee09e77', 2, '1', 0, 1, 1, 'https://www.aliyun.com/1111/home?userCode=w7aungxw', 5, NULL, 0);
INSERT INTO `t_blog` VALUES ('3be04b35f76468aa2e5990afbfc9932a', '测试波尔克2', '测试博客2', '<p>测试博客2</p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 0, 0, 'dca06b7785df4434091e70a0527fd9a4', 0, '2020-10-13 09:12:03', '2020-10-13 09:27:36', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 6, NULL, 0);
INSERT INTO `t_blog` VALUES ('4137035efd12042f37b05450f095dd8f', 'go测试', 'go测试', '<p>go测试</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n	&quot;context&quot;\n	&quot;fmt&quot;\n	&quot;go.etcd.io/etcd/clientv3&quot;\n	&quot;time&quot;\n)\n\nfunc main() {\n	cli, err := clientv3.New(clientv3.Config {\n		Endpoints: []string{&quot;127.0.0.1:2379&quot;}, // etcd的节点，可以传入多个\n		DialTimeout: 5*time.Second, // 连接超时时间\n	})\n\n	if err != nil {\n		fmt.Printf(&quot;connect to etcd failed, err: %v \\n&quot;, err)\n		return\n	}\n	fmt.Println(&quot;connect to etcd success&quot;)\n\n	// 延迟关闭\n	defer cli.Close()\n\n	// put操作  设置1秒超时\n	ctx, cancel := context.WithTimeout(context.Background(), time.Second)\n	_, err = cli.Put(ctx, &quot;moxi&quot;, &quot;lalala&quot;)\n	cancel()\n	if err != nil {\n		fmt.Printf(&quot;put to etcd failed, err:%v \\n&quot;, err)\n		return\n	}\n\n	// get操作，设置1秒超时\n	ctx, cancel = context.WithTimeout(context.Background(), time.Second)\n	resp, err := cli.Get(ctx, &quot;q1mi&quot;)\n	cancel()\n	if err != nil {\n		fmt.Printf(&quot;get from etcd failed, err:%v \\n&quot;, err)\n		return\n	}\n	fmt.Println(resp)\n}\n</code></pre>\n', '5626932d452c2ad863d9b3cb0b69d22d', 1, 0, 'dca06b7785df4434091e70a0527fd9a4', 0, '2020-09-11 18:28:57', '2020-09-14 10:33:02', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 7, NULL, 0);
INSERT INTO `t_blog` VALUES ('44ad2dc4c6e70ad03983219b4823de91', '测试2', '测试2', '<p><img src=\"http://localhost:8600//blog/admin/png/2021/2/4/1612453829193.png\" /></p>\n\n<p>我的内容在那里</p>\n', '7e0e93ea6cdb44ae92e58f48e6496ed7', 5, 0, '567b035c506c1cb1ef117f68dcc23e2d', 1, '2021-02-04 23:50:33', '2021-04-09 20:38:12', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 3, '1', 0, 0, 0, NULL, 45, NULL, 0);
INSERT INTO `t_blog` VALUES ('463421a76f9bc5760c965a917153d2e0', 'README', 'README', '<blockquote>\n<p>大家好，我是陌溪，欢迎点击下方的公众号名片，关注陌溪，让我们一起成长~</p>\n</blockquote>\n\n<p>最近有读者问我平时是怎么记录视频笔记的，因为<strong>陌溪</strong>之前一直沉迷于<strong>B站视频</strong>学习，在很多热门的视频下都留下我写的视频学习笔记，也成功帮助小伙伴们节省了很多时间，这次陌溪把<strong>压箱底</strong>的<strong>记笔记</strong>操作分享给大家。</p>\n\n<p><img alt=\"宋红康老师的JVM视频\" src=\"http://localhost:8600//blog/admin/png/2021/4/9/1617972310747.png\" /></p>\n\n<p><img alt=\"周阳老师大厂面试题\" src=\"http://localhost:8600//blog/admin/png/2021/4/9/1617972310797.png\" /></p>\n\n<p>我们经常看到的<strong>B站学习视频</strong>大多数是不提供<strong>课件</strong>和 <strong>ppt</strong> 的，但是如果自己需要做笔记的话，要来回暂停视频，然后手动把一个个文字敲上去。虽然说。。这么一个动作可以加深一下学习记忆，但是也让陌溪<strong>苦不堪言</strong>，仿佛回到了高中时候：老师在黑板上写，我在下面抄写的情景，最后老师讲的啥也没听到，只看到满满的一本子笔记就感觉自己学会了。。</p>\n\n<p><img alt=\"img\" src=\"http://localhost:8600//blog/admin/png/2021/4/9/1617972310165.png\" /></p>\n\n<p>为了避免这类事情的再次重演，我决定寻找了几款 <strong>ORC</strong> 文字识别工具，帮助我提高生产力，同时花更多的时间在视频学习上。</p>\n\n<h2>树洞OCR</h2>\n\n<p>树洞 OCR 文字识别，是一款跨平台的 OCR 小工具，同时在Github上开源。</p>\n\n<blockquote>\n<p>官网地址：<a href=\"https://github.com/AnyListen/tools-ocr\">https://github.com/AnyListen/tools-ocr</a></p>\n</blockquote>\n\n<p>推荐等级：<img src=\"images/6.png\" /><img src=\"images/6.png\" /><img src=\"images/6.png\" /></p>\n\n<p>树洞 <strong>OCR</strong> 项目是基于 <strong>JavaFX</strong> 开发，如果想要运行源码的话，需要安装好 <strong>JDK1.8</strong> 环境。</p>\n\n<p><img alt=\"树洞OCR源码\" src=\"http://localhost:8600//blog/admin/png/2021/4/9/1617972308970.png\" /></p>\n\n<p>识别后的效果还是不错的，同时还能够保证原来的格式。</p>\n\n<p><img alt=\"识别结果\" src=\"http://localhost:8600//blog/admin/png/2021/4/9/1617972310095.png\" />我最开始尝试了一些，页面比较简陋，而且功能不是特别完善，截图翻译的时候比较难受，特别是在双屏的环境下</p>\n\n<p>在具体使用过程中，发现树洞 <strong>OCR</strong> 还有一些功能不是特别完善，比如截图翻译的时候比较难受，尤其是在双屏的环境下，不能像 <strong>QQ</strong> 截图那样自由切换。</p>\n\n<h2>QQ截图</h2>\n\n<p>QQ截图在最新的版本是提供了文件识别功能，在我们截图后点击 <strong>屏幕识图</strong>，即可完成识别</p>\n\n<p>推荐等级：<img src=\"images/6.png\" /><img src=\"images/6.png\" /><img src=\"images/6.png\" /><img src=\"images/6.png\" /></p>\n\n<p><img alt=\"QQ屏幕识图\" src=\"http://localhost:8600//blog/admin/png/2021/4/9/1617972310708.png\" /></p>\n\n<p>但是在具体使用的时候，用户体验不太行，首先是想要编辑的时候比较麻烦，如上图所示，感觉得到的结果有点像有道翻译，同时在截图提取的时候，接口请求耗时比较久，并且还需要自己手动点击内容才能够复制到剪切板。优点就是升级了新版 <strong>QQ</strong> 就能够直接使用，不需要额外下载安装。</p>\n\n<h2>雨梦OCR</h2>\n\n<p><strong>雨梦OCR文字提取</strong> 是一款免安装，易用的文字提取软件，目前支持截图、拖拽图片、导入图片等方式来提取文字，可以极大地提高工作效率。除OCR功能外，还包括了贴图、截图、翻译等功能。</p>\n\n<blockquote>\n<p>官网地址：<a href=\"http://hanxinyumeng.cn\">http://hanxinyumeng.cn</a></p>\n</blockquote>\n\n<p>推荐等级：<img src=\"images/6.png\" /><img src=\"images/6.png\" /><img src=\"images/6.png\" /><img src=\"images/6.png\" /></p>\n\n<p><img alt=\"雨梦OCR\" src=\"http://localhost:8600//blog/admin/png/2021/4/9/1617972310293.png\" /></p>\n\n<p>在设置中可以选择不同的 <strong>OCR</strong> 接口，选择需要识别的语言及标点类型。</p>\n\n<p><img alt=\"雨梦OCR设置\" src=\"http://localhost:8600//blog/admin/png/2021/4/9/1617972310858.png\" /></p>\n\n<p>在常规设置中，你可以对文本、字体、界面和自启动等进行设置</p>\n\n<p><img alt=\"雨梦OCR设置\" src=\"http://localhost:8600//blog/admin/png/2021/4/9/1617972310919.png\" /></p>\n\n<p>同时还支持默认快捷键设置</p>\n\n<p><img alt=\"设置快捷键\" src=\"http://localhost:8600//blog/admin/png/2021/4/9/1617972310095.png\" /></p>\n\n<p>雨梦 <strong>OCR</strong> 比 树洞 <strong>OCR</strong> 操作起来就更友好了，因为我主要的用处是用于<strong>截屏提取文字</strong>，这个在<strong>截屏提取文字</strong>这块做的还可以，能满足需求，但是存在一个问题就是，雨梦 <strong>OCR</strong> 是收费版本的，需要 <strong>1</strong> 年 <strong>19</strong> 元。但是每天会提供<strong>50</strong> 次免费使用，如果平时使用 <strong>OCR</strong> 不是特别频繁的话，是可以使用的。</p>\n\n<h2>天若OCR</h2>\n\n<p>天若 <strong>OCR</strong> 文字识别开源版保留了雨梦 <strong>OCR</strong> 的大部分功能，所以在使用体验上还是很舒服。同时还是开源免费的，平时我使用最多的就是这款了。</p>\n\n<blockquote>\n<p>官网地址：<a href=\"https://github.com/AnyListen/tianruoocr\">https://github.com/AnyListen/tianruoocr</a></p>\n</blockquote>\n\n<p>推荐等级：<img src=\"images/6.png\" /><img src=\"images/6.png\" /><img src=\"images/6.png\" /><img src=\"images/6.png\" /><img src=\"images/6.png\" /></p>\n\n<p>首先，选择天若 <strong>OCR</strong> 的<strong>release</strong>发行版，进行下载</p>\n\n<p><img alt=\"Github下载\" src=\"http://localhost:8600//blog/admin/png/2021/4/9/1617972310375.png\" /></p>\n\n<p>下面里面的 <strong>zip</strong> 文件进行解压</p>\n\n<p><img alt=\"选择压缩包\" src=\"http://localhost:8600//blog/admin/png/2021/4/9/1617972310448.png\" /></p>\n\n<p>然后运行里面的 <strong>exe</strong> 文件即可，运行后会创建一个状态栏图标，我们按 <strong>F4</strong> 即可截图，下面就是我识别蘑菇博客中的一篇文章，识别的准确率挺高的，并且还能自动复制到剪切板，非常方便。</p>\n\n<p><img alt=\"识别效果\" src=\"http://localhost:8600//blog/admin/png/2021/4/9/1617972308970.png\" /></p>\n\n<p>同时界面还是挺美观的，而且功能也很强大，还支持自定义接口，所以目前来说天若 <strong>OCR</strong> 是首选~</p>\n\n<p><img alt=\"设置页面\" src=\"http://localhost:8600//blog/admin/png/2021/4/9/1617972310581.png\" /></p>\n\n<p>好了，常见的 <strong>OCR</strong> 工具我就介绍到这里了，陌溪把自己压箱底的都拿出来了，我们下期再见~</p>\n\n<h2>往期推荐</h2>\n\n<ul>\n	<li><a href=\"https://mp.weixin.qq.com/s/3u6OOYkpj4_ecMzfMqKJRw\">蘑菇博客从0到2000Star，分享我的Java自学路线图</a></li>\n	<li><a href=\"https://mp.weixin.qq.com/s/c4rR_aWpmNNFGn-mZBLWYg\">从三本院校到斩获字节跳动后端研发Offer-讲述我的故事</a></li>\n	<li><a href=\"https://mp.weixin.qq.com/s/Jj1i-mD9Tw0vUEFXi5y54g\">陌溪在公众号摸滚翻爬半个月，整理的入门指南</a></li>\n</ul>\n\n<h2>结语</h2>\n\n<p><strong>陌溪</strong>是一个从三本院校一路摸滚翻爬上来的互联网大厂程序员。独立做过几个开源项目，其中<strong>蘑菇博客</strong>在码云上有 <strong>2K Star</strong> 。目前就职于<strong>字节跳动的Data广告部门</strong>，是字节跳动全线产品的商业变现研发团队。本公众号将会持续性的输出很多原创小知识以及学习资源。如果你觉得本文对你有所帮助，麻烦给文章点个「赞」和「在看」。同时欢迎各位小伙伴关注陌溪，让我们一起成长~</p>\n\n<p><img alt=\"和陌溪一起学编程\" src=\"http://localhost:8600//blog/admin/png/2021/4/9/1617972310648.png\" /></p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 1, 0, 'd134bdfe255b9aa8c2ce44da8297f6a6', 1, '2021-04-09 20:45:19', '2021-04-09 20:46:14', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 49, NULL, 0);
INSERT INTO `t_blog` VALUES ('4bf033dac92c2b40746fe6ba3ab97a6c', '测试博客', '测试博客', '<p>测试博客</p>\n', '7e0e93ea6cdb44ae92e58f48e6496ed7', 1, 0, '90dd6ac4d3e000b8ea2f7162201d6ace', 1, '2020-12-05 14:51:51', '2020-12-09 20:45:00', '1f01cd1d2f474743b241d74008b12333', '1', NULL, '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 27, NULL, 0);
INSERT INTO `t_blog` VALUES ('4f47070aa279f9d7dccdeb94fa2a24b1', '测试测试', 'JavaJava', '<p>概念概念概念概念概念概念概念概念概念概念概念概念概念</p>\n', '7e0e93ea6cdb44ae92e58f48e6496ed7', 3, 0, '567b035c506c1cb1ef117f68dcc23e2d', 1, '2020-12-26 15:48:38', '2021-04-09 20:43:27', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 33, NULL, 0);
INSERT INTO `t_blog` VALUES ('55b7b13a1661bb6827b9a81c01e60e8a', '用户投稿', '用户投稿', '<p>用户投稿</p>\n', '7e0e93ea6cdb44ae92e58f48e6496ed7', 1, 0, '567b035c506c1cb1ef117f68dcc23e2d', 1, '2021-04-11 16:39:03', '2021-04-11 16:40:38', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 51, 'b486735e7b914e366840d01f049306e4', 0);
INSERT INTO `t_blog` VALUES ('587eb2ff4670ce7561d771a5df40ee11', 'README', 'README', '<blockquote>\n<p>大家好，我是陌溪</p>\n</blockquote>\n<p>最近<strong>很长一段时间</strong>没有更新公众号了，陌溪在此特别<strong>冒个泡</strong>证明我还在..，其实陌溪这阵子一直都在拜年，下面给大家伙看看我最近一阵子的拜年安排表，简直被安排的明明白白的..</p>\n<p><img src=\"images/1.jpg\" alt=\"\" /></p>\n<ul>\n<li>初一：去家族起源地拜年</li>\n<li>初二：去<strong>外婆家</strong>拜年</li>\n<li>初三：在自己家里准备<strong>烧烤</strong></li>\n<li>初四：和小伙伴一块<strong>聚餐</strong></li>\n<li>初五：去<strong>第一个姑奶奶</strong>和<strong>舅爷家</strong>拜年</li>\n<li>初六：大哥和三哥家孩子<strong>满月酒</strong>去帮忙</li>\n<li>初七：去<strong>第二个姑奶奶</strong>家拜年</li>\n<li>初八：去<strong>第三个姑奶奶</strong>家拜年</li>\n<li>初九：去<strong>第一个姑姑</strong>家拜年</li>\n<li>初十：去<strong>第二个姑姑</strong>家拜年</li>\n</ul>\n<p>先说说我的老家吧，在江西赣州的一个<strong>小村</strong>里。小时候老爸和老妈还在广东打工，我就跟着奶奶在村子里长大。每到过年的时候，村里里是<strong>最热闹</strong>的时候了，在外务工的人员都会赶回家吃上一份<strong>团圆饭</strong>。</p>\n<p>下面这个就是老家的房子，是老爸在<strong>二零零几年</strong>的时候就建好了。我一直很敬佩老爸，因为爷爷在我4岁的时候因病走了，那会老爸才27/8岁，然后老爸作为家里的老大，初中毕业就肩负起重任外出打工，然后担任起照看我叔叔和姑姑的重任。老爸在外拼搏的几年里，也吃了没有文化的苦，做了很多累活，虽然现在自己弄了个小本生意，但是每天也很辛苦。因此老爸对于<strong>子女的教育</strong>抓的非常紧，我也很庆幸能够出生在一个<strong>注重教育的大家庭</strong>里。</p>\n<p><img src=\"images/image-20210220181914756.png\" alt=\"老家的房子\" /></p>\n<p>家门口这几年<strong>政府</strong>给铺好了路，交通也便捷了许多。原来我小时候那个桥还是个非常窄的小桥，记得小时候我去上小学的时候，小桥一下没站稳，把我摔下了桥底，那会哭的老惨了。</p>\n<p><img src=\"images/image-20210220183117827.png\" alt=\"门前的小河\" /></p>\n<p>吃年夜饭之前，按照惯例先打爆竹，<strong>爆竹声中一岁除</strong>，然后准备<strong>干饭</strong>咯~</p>\n<p><img src=\"images/image-20210220185400780.png\" alt=\"爆竹声中一岁除\" /></p>\n<p>老妈下厨制作的<strong>年夜饭</strong>，吃了这么多地方的饭菜，还是家里的饭菜香。</p>\n<p><img src=\"images/image-20210220185128587.png\" alt=\"团圆饭\" /></p>\n<p>我们这里比较注重<strong>传统文化传承</strong>-<strong>舞龙灯</strong>，大年初一的时候，我们都会组队去家族发源地，一起利用<strong>彩纸</strong>制作一个个的“<strong>龙灯</strong>”，都是使用彩纸和浆糊，将剪好的纸给糊住（ps: 今年因为疫情原因，活动取消了，所以都是用的是去年的照片....）。</p>\n<p><img src=\"images/image-20210220183542545.png\" alt=\"在一起剪纸\" /></p>\n<p>哈哈哈，下面几个<strong>五角星</strong>就是我剪的...</p>\n<p><img src=\"images/image-20210220183814687.png\" alt=\"我剪的五角星\" /></p>\n<p>在这里最难的就是这个大龙头了，每次我们需要花费很长的时间去制作</p>\n<p><img src=\"images/image-20210220184016843.png\" alt=\"正在制作的大龙\" /></p>\n<p>下面就是我们兄弟四个制作好的大龙了~，可以拿出去舞龙了。每年舞龙的时候是最热闹的时候了，整个村的人都会聚集在一起，这两年<strong>响应国家号召</strong>，所以聚会也<strong>取消了</strong>。</p>\n<p><img src=\"images/image-20210220184131850.png\" alt=\"制作好的大龙\" /></p>\n<p>这阵子老爸把他车子丢给我开，正好趁着过年的一阵时间，练习了一下<strong>开车技巧</strong>，先给车洗干净，然后准备拜年。</p>\n<p><img src=\"images/image-20210220172010984.png\" alt=\"洗车准备拜年\" /></p>\n<p>一上路，就在路上遭遇了<strong>大堵车</strong>，因为这里都是<strong>乡间小路</strong>，只是单行道，如果遇到对面过来了车辆就需要避让，但是可能有些地方不是很好的避开，在加上像我一样的新手司机太多，因此就造成了大堵车~，陌溪在这里堵了快半个多小时了...</p>\n<p><img src=\"images/image-20210220190539675.png\" alt=\"大堵车\" /></p>\n<p>然后就在家里开始了<strong>烧烤生活</strong>，首先准备食材</p>\n<p><img src=\"images/image-20210220191915876.png\" alt=\"制作食材\" /></p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/2/22/1613964913469.png\" alt=\"制作食材\" /></p>\n<p>然后开始准备木炭，用的都是一个不太大的烧烤炉，小朋友在边上都快馋哭了。</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/2/22/1613964934714.png\" alt=\"点燃木炭\" /></p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/2/22/1613964955891.png\" alt=\"烤中翅\" /></p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/2/22/1613964977074.png\" alt=\"香味扑鼻\" /></p>\n<p>我的春节生活就介绍到这里了，明天又要去姑姑家拜年了，这也是今年的<strong>最后一家</strong>了，后面就可以开始进入正常的搬砖生活了。</p>\n<p>我是<strong>陌溪</strong>，我们下期再见~</p>\n<h2>往期推荐</h2>\n<ul>\n<li>\n<p><a href=\"https://mp.weixin.qq.com/s/3u6OOYkpj4_ecMzfMqKJRw\">蘑菇博客从0到2000Star，分享我的Java自学路线图</a></p>\n</li>\n<li>\n<p><a href=\"https://mp.weixin.qq.com/s/c4rR_aWpmNNFGn-mZBLWYg\">从三本院校到斩获字节跳动后端研发Offer-讲述我的故事</a></p>\n</li>\n<li>\n<p><a href=\"https://mp.weixin.qq.com/s/Jj1i-mD9Tw0vUEFXi5y54g\">陌溪在公众号摸滚翻爬半个月，整理的入门指南</a></p>\n</li>\n</ul>\n<h2>结语</h2>\n<p><strong>陌溪</strong>是一个从三本院校一路摸滚翻爬上来的互联网大厂程序员。独立做过几个开源项目，其中<strong>蘑菇博客</strong>在码云上有 <strong>2K Star</strong> 。目前就职于<strong>字节跳动的Data广告部门</strong>，是字节跳动全线产品的商业变现研发团队。本公众号将会持续性的输出很多原创小知识以及学习资源。如果你觉得本文对你有所帮助，麻烦给文章点个「赞」和「在看」。同时欢迎各位小伙伴关注陌溪，让我们一起成长~</p>\n<p><img src=\"images/image-20210122092846701.png\" alt=\"和陌溪一起学编程\" /></p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 0, 0, 'd134bdfe255b9aa8c2ce44da8297f6a6', 1, '2021-02-22 11:36:47', '2021-02-22 11:36:47', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '0', 0, 1, 0, NULL, 46, NULL, 0);
INSERT INTO `t_blog` VALUES ('5adda57c05ec8ecb386a819375f328c0', '测试', '测试', '<p>大家好，我是<strong>陌溪</strong></p>\n\n<p>最近群里很有小伙伴问我有没有<strong>蘑菇博客</strong>的入门指南，因为蘑菇博客经过了两年的技术迭代，已经包含了非常多的知识点了，从<strong>SpringBoot</strong>&nbsp;到&nbsp;<strong>SpringCloud</strong>，从<strong>Solr</strong>&nbsp;到&nbsp;<strong>ElasticStack</strong>&nbsp;... 。里面的内容错综复杂，难免会让刚刚入门的&nbsp;<strong>Java小萌新</strong>&nbsp;束手无策，所以我就打算梳理一下博客中的知识点，<strong>方便萌新小伙伴入门</strong>&nbsp;~。</p>\n\n<p><img alt=\"蘑菇博客系统架构图\" src=\"http://localhost:8600//blog/admin/jpg/2021/1/1/1609508632528.jpg\" /></p>\n\n<p>经过我这两天的整理，下面把我学习&nbsp;<strong>Java</strong>&nbsp;的路线指南总结了一下，希望对小伙伴们有所帮助~</p>\n\n<p>下面我的内容主要以<strong>视频教程</strong>为主，因为我觉得<strong>通过视频</strong>来学习是<strong>一条非常适合新手入门的路</strong>。千万不要觉得看视频会显得自己学习能力不够强，因为编程本身是一个<strong>实践性特别强</strong>的科目，需要我们跟着老师的思路进行编码训练，从而加强自己的编码能力。因此我建议在观看视频的过程中，小伙伴们能够&nbsp;<strong>做好笔记</strong>，<strong>跟着老师一块写代码</strong>。</p>\n\n<p>本文主要针对<strong>萌新入门指南</strong>，如果是<strong>老司机可以结合视频和书籍进行学习</strong>，请<strong>萌新小伙伴</strong>坐稳扶好，我们发车~。</p>\n\n<h2>工欲善其事，必先利其器</h2>\n\n<p>在我们开工前，我们肯定要选择一款好的&nbsp;<strong>IDE</strong>&nbsp;编辑器，这样能让我们的编码达到<strong>事半功倍</strong>的效果。</p>\n\n<p>其实我是用过很多编辑器的，如&nbsp;<strong>Eclipse</strong>&nbsp;、<strong>MyEclipse</strong>、<strong>STS</strong>、<strong>VSCode</strong>、<strong>Intellij IDEA</strong></p>\n\n<p>首先&nbsp;<strong>Eclipse</strong>&nbsp;、<strong>MyEclipse</strong>、<strong>STS</strong>&nbsp;其实都是比较类似的，<strong>Eclipse</strong>&nbsp;被称为&nbsp;<strong>Java</strong>&nbsp;集成开发环境，并且是开源免费。MyEclipse在Eclipse基础增加了一些插件，而&nbsp;<strong>STS</strong>&nbsp;则是专用于&nbsp;<strong>Spring</strong>&nbsp;开发。</p>\n\n<p><strong>VSCode</strong>&nbsp;是由微软开发的一款跨平台编辑器，目前支持几乎所有的主流编程语言，不仅仅是开发&nbsp;<strong>Java</strong></p>\n\n<p><strong>Intellij IDEA</strong>&nbsp;是目前业界公认最好的&nbsp;<strong>Java</strong>&nbsp;开发工具，尤其是在智能代码助手、代码提示、版本控制等方面表示突出，并且<strong>GUI</strong>设计也非常符合审美规范，我从Eclipse 被小伙伴安利到了&nbsp;<strong>Intellij IDEA</strong>，特意花了几周适应快捷键</p>\n\n<p>目前我已经从&nbsp;<strong>Eclipse</strong>&nbsp;系 平稳过度到了<strong>Jetbrains</strong>&nbsp;全家桶，同时 J<strong>etbrains</strong>&nbsp;全家桶对<strong>学生免费开放</strong>，并且如果你拥有<strong>开源项目</strong>的话，也可以申请到一份免费的开源&nbsp;<strong>License</strong>&nbsp;。陌溪就是通过蘑菇博客申请到了两份&nbsp;<strong>License</strong>&nbsp;，用于两台电脑的&nbsp;<strong>IDEA</strong>&nbsp;登录。</p>\n\n<p><img alt=\"Jetbrains全家桶\" src=\"http://localhost:8600//blog/admin/jpg/2021/1/1/1609508634510.jpg\" /></p>\n\n<p>小伙伴如果第一次接触 Java，我推荐你直接上车&nbsp;<strong>Intellij IDEA</strong>&nbsp;。同时我强烈建议你<strong>花上几个小时</strong>的时间，学习一下&nbsp;<strong>IDEA</strong>&nbsp;的基础用法，这将会让你在后面的<strong>编码阶段健步如飞</strong>。</p>\n\n<blockquote>\n<p>Bilibili 宋红康老师 尚硅谷IDEA教程：</p>\n\n<p><a href=\"https://www.bilibili.com/video/BV1PW411X75p\">https://www.bilibili.com/video/BV1PW411X75p</a></p>\n</blockquote>\n\n<h2>JavaSE</h2>\n\n<p><strong>JavaSE</strong>是&nbsp;<strong>Java</strong>&nbsp;的核心和基础，我最早接触&nbsp;<strong>JavaSE</strong>&nbsp;是在&nbsp;<strong>2014年10月</strong>&nbsp;，那会刚刚上<strong>大二</strong>，学校刚刚开设&nbsp;<strong>Java</strong>&nbsp;课程。那会的老师在给我们讲解&nbsp;<strong>JavaGui</strong>&nbsp;编程的时候，我突然发现原来通过代码写出来的东西，不仅仅只是在黑框框上运行，也是有可视化的界面，从这一刻我突然对&nbsp;<strong>Java</strong>&nbsp;有了浓厚的兴趣。</p>\n\n<blockquote>\n<p>为啥学 C++ 的时候没有这感觉？因为觉得C++只能写出黑框框程序，还有就是指针&amp; * ...</p>\n</blockquote>\n\n<p>后面又通过网上冲浪，我发现了传智播客的视频教程，从此就开启了&nbsp;<strong>Java</strong>&nbsp;入门之旅。</p>\n\n<p><img alt=\"Java图片-来源网络\" src=\"http://localhost:8600//blog/admin/jpg/2021/1/1/1609508634298.jpg\" /></p>\n\n<p>我最先接触的是传智播客毕向东老师的&nbsp;<strong>Java基础视频教程</strong>&nbsp;，毕老师诙谐幽默的语言，然后丝毫感受不到学习的枯燥。在&nbsp;<strong>Java</strong>&nbsp;基础课程中，会学习到 Java环境的搭建、进制的转换、运算符、条件语句、数组、<strong>面向对象</strong>、多线程、<strong>集合类</strong>、<strong>IO流</strong>&nbsp;等内容。在基础部分是最花费时间的，我当初在大二的时候，学习基础就花费了两三个月才看完...。同时我也希望刚刚入门的小伙伴们，能够<strong>打好基础</strong>，这样才能<strong>走的更远</strong>。</p>\n\n<blockquote>\n<p>Bilibili 毕向东老师Java基础：</p>\n\n<p><a href=\"https://www.bilibili.com/video/BV1Rt411f7F5\">https://www.bilibili.com/video/BV1Rt411f7F5</a></p>\n</blockquote>\n\n<p>毕老师的&nbsp;<strong>Java</strong>&nbsp;基础视频，算的上是经典之作。不过视频课程诞生较早，在加上里面有些内容，例如&nbsp;<strong>JavaGui</strong>&nbsp;，其实在现在已经被淘汰了，同时那会比较主流的&nbsp;<strong>JDK</strong>&nbsp;版本还是基于&nbsp;<strong>Java 1.6</strong>&nbsp;。 而现在基本都已经升级到&nbsp;<strong>JDK 1.8</strong>&nbsp;了</p>\n\n<p>这里我推荐尚硅谷宋红康老师的&nbsp;<strong>Java</strong>&nbsp;零基础教程，本套视频在毕老师视频的基础上，摒弃了很多已经淘汰的技术，同时为了方便萌新入门，对计算机的发展史都做了讲解，同时还对&nbsp;<strong>Java</strong>&nbsp;的发展史都做了全局的概览，让我们在学习Java的时候，能够非常清楚的知道以后&nbsp;<strong>Java</strong>&nbsp;能用来做什么，最后对&nbsp;<strong>JDK 8</strong>&nbsp;~&nbsp;<strong>JDK 11</strong>&nbsp;等多个版本的新特性都做了讲解。</p>\n\n<blockquote>\n<p>Bilibili 宋红康老师 尚硅谷 Java零基础教程：</p>\n\n<p><a href=\"https://www.bilibili.com/video/BV1Kb411W75N\">https://www.bilibili.com/video/BV1Kb411W75N</a></p>\n</blockquote>\n\n<p>在&nbsp;<strong>JavaSE</strong>&nbsp;阶段，小伙伴们需要掌握一下几个重点部分</p>\n\n<blockquote>\n<p>面向对象、集合类、IO流、反射、泛型、异常处理</p>\n</blockquote>\n\n<h2>MySQL</h2>\n\n<p>在学习完&nbsp;<strong>JavaEE</strong>&nbsp;的课程后，我们就可以开始&nbsp;<strong>MySQL</strong>&nbsp;数据库的学习了。这门课程可能很多小伙伴在本科大二或者大三的时候会开设，如果已经学过的小伙伴，那么这个小节就可以直接跳过。</p>\n\n<p><img alt=\"MySQL图片-来源网络\" src=\"http://localhost:8600//blog/admin/jpg/2021/1/1/1609508634874.jpg\" /></p>\n\n<p>在这里，我们将学习数据库和表的常用操作、约束、视图、存储过程和函数、流程控制结构以及综合运用各种命令实现数据的增删改查操作。</p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 3, 0, '9437342be28f6a95852090786913929b', 1, '2021-01-01 21:44:18', '2021-01-14 22:58:51', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 36, NULL, 0);
INSERT INTO `t_blog` VALUES ('5c85fc5e0e17aea5251b5352f83885e8', '利用jenkins远程部署springcloud项目(1)', '利用jenkins远程部署springcloud项目(1)', '<h3>利用jenkins远程部署springcloud项目</h3>\n\n<h4><strong>在<a href=\"http://blog.chenmx.net/#/info?blogUid=4b937d9e117852b03f9b3476f9a38f8d\">上一篇</a>中介绍了如何自动构建Maven父项目，那具体的每个子项目该如何部署呢，怎么自动打包运行在docker中呢，下面我们来揭晓：</strong></h4>\n\n<ul>\n	<li>我们为每一个微服务新建一个自由风格的jenkins任务<img alt=\"image-20210410122651563\" src=\"C:\\Users\\Ray\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210410122651563.png\" /></li>\n	<li><img alt=\"image-20210410123017801\" src=\"C:\\Users\\Ray\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210410123017801.png\" /></li>\n	<li>这里我们不需要使用Gitee拉取代码，因为<a href=\"http://blog.chenmx.net/#/info?blogUid=4b937d9e117852b03f9b3476f9a38f8d\">上一篇</a>父项目已经替我们拉取并打包好了所有子项目的jar包<img alt=\"image-20210410123236224\" src=\"C:\\Users\\Ray\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210410123236224.png\" /></li>\n	<li>构建过程中我们需要shell替我们到父项目的工作空间中找到相应子项目的jar包及需要构建docker镜像的Dockerfile文件和部署脚本<img alt=\"image-20210410123434771\" src=\"C:\\Users\\Ray\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210410123434771.png\" /></li>\n</ul>\n\n<p>附上shell内容</p>\n\n<pre>\n<code>#!/bin/bash\n\n#目标服务器B,即要运行jar包的服务器\nserverB=\"49.233.0.67\"\n\n#目标服务器B存放jar包路径\nBpath=/home/mogu_blog/admin\n\n#jenkins工作目录\ncd ${WORKSPACE}\necho \"源服务器A上jenkins的工作目录：\"`pwd`\necho \"当前构建的任务名称：$JOB_NAME\"\n#传输jenkins构建好的jar包和Dockerfile到目标服务器B上\nfor host in $serverB\ndo\n	echo \"目标服务器：*********$host*********\"\n	echo \"目标服务器存放jar包位置：**************$Bpath**************\"\n	ssh root@$host \n	scp -r /home/jenkins/workspace/mogu/${JOB_NAME}/target/*.jar root@${host}:${Bpath}\n    scp -r /home/jenkins/workspace/mogu/${JOB_NAME}/src/main/resources/Dockerfile root@${host}:${Bpath}\n    scp -r /home/jenkins/workspace/mogu/${JOB_NAME}/src/main/resources/Jenkinsfile root@${host}:${Bpath}\n	echo \"文件传输完成！！！！\"\n	echo \"检查目标服务器$host-&gt;$Bpath路径下是否存在jar包和Dockerfile\"\ndone\n</code></pre>\n\n<ul>\n	<li>构建后的操作，进入B服务器的目录，执行jenkinsfile脚本，jenkinsfile这个脚本我是放在项目中的，项目结构图如下：<img alt=\"image-20210411173500274\" src=\"C:\\Users\\Ray\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210411173500274.png\" /><img alt=\"image-20210411172713993\" src=\"C:\\Users\\Ray\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210411172713993.png\" /></li>\n</ul>\n\n<p>远程部署到其他服务器，请参考这篇文章<a href=\"http://blog.chenmx.net/#/info?blogUid=9c0d9c5c3e82c357ab0e36b1b64d85aa\">publish over ssh实现Jenkins远程部署</a></p>\n\n<ul>\n	<li>jenkinsfile脚本如下</li>\n</ul>\n\n<pre>\n<code>#!/bin/sh\nNUM_1=`docker ps -a | grep admin | grep -vi grep |wc -l`\necho \"容器是否存活:******************\"${NUM_1}\"******************\"\nNUM_2=`docker images | grep admin | grep -v grep | wc -l`\necho \"镜像是否存在:******************\"${NUM_2}\"******************\"\nif [[ \"${NUM_2}\"!=\"0\" ]];then\n     echo \"---------镜像存在！！！，判断容器是否存活-----------\"\n     if [[ \"${NUM_1}\"!=\"0\" ]];then\n         echo \"---------容器存活，停止容器并删除容器---------\"\n        docker stop admin\n        docker rm admin\n     fi\n    echo \"--------删除镜像---------\"\n   docker rmi admin\nfi\necho \"----------开始构建镜像......--------------\"\ndocker build -t admin /home/mogu_blog/admin/\necho \"---------运行容器------------\"\ndocker run -dit --name admin -p 8601:8601 admin:latest\nrm -rf /home/mogu_blog/admin/*\n</code></pre>\n\n<ul>\n	<li>因为我是部署到远程服务器B，并在docker中运行，所以这里需要编写Dockerfile文件，代码如下：</li>\n</ul>\n\n<pre>\n<code>from java:8\n\n## 设置挂载点\nVOLUME /tmp\n\n## 复制并修改重命名\nADD mogu_admin-0.0.1-SNAPSHOT.jar admin.jar\n\n# 运行jar包\nRUN bash -c \'touch /admin.jar\'\nENTRYPOINT [\"java\",\"-Djava.security.egd=file:/dev/./urandom\",\"-jar\",\"/admin.jar\"]\n</code></pre>\n\n<ul>\n	<li>点击保存，子项目构建任务就完成了。只要在git上有新的代码提交，父项目会触发webhook自动构建，等待父项目构建后，需手动点击子任务，这样就可以远程部署服务到另一台服务器并运行了。</li>\n</ul>\n\n<p><a href=\"https://pan.baidu.com/s/1wDTRdH3wvlhF_bMDw_QvRA\">Jenkinsfile百度云盘地址</a>，提取码：fyrg</p>\n\n<p><a href=\"https://pan.baidu.com/s/1LO9oAb2AFGrMAuUQeHfeSw\">Dockerfile百度云地址</a>，提取码：x66y</p>\n\n<p>利用Jenkins构建Maven父子项目-父项目篇<a href=\"http://blog.chenmx.net/#/info?blogUid=4b937d9e117852b03f9b3476f9a38f8d\">利用jenkins自动构建springcloud项目（一）</a></p>\n', '5626932d452c2ad863d9b3cb0b69d22d,7e0e93ea6cdb44ae92e58f48e6496ed7,15721a34adba068763b5a2fb1991fc57', 1, 0, 'd134bdfe255b9aa8c2ce44da8297f6a6', 1, '2021-04-12 16:47:45', '2021-06-13 07:46:23', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 58, NULL, 0);
INSERT INTO `t_blog` VALUES ('63404f80664a5dc9ebf5ce45a748a058', 'Go语言发展简史', 'Go语言发展简史', '<h1>Go语言发展简史</h1>\n\n<h2>开发文档</h2>\n\n<p><a href=\"https://studygolang.com/pkgdoc\">https://studygolang.com/pkgdoc</a></p>\n\n<h2>Go语言核心开发团队</h2>\n\n<p>Ken Thompson（肯&middot;汤普森）：1983年图灵奖（Turing Award）和1998年美国国家技术奖（National Medal of Technology）得主。他与Dennis Ritchie是Unix的原创者。Thompson也发明了后来衍生出C语言的B程序语言，同时也是C语言的主要发明人。</p>\n\n<p>Rob Pike（罗布-派克）：曾是贝尔实验室（Bell Labs）的Unix团队，和Plan 9操作系统计划的成员。 他与Thompson共事多年，并共创出广泛使用的UTF-8字元编码。</p>\n\n<p>Robert Griesemer：曾协助制作Java的HotSpot编译器，和Chrome浏览器的JavaScript引擎V8。</p>\n\n<p><img alt=\"image-20200718103112309\" src=\"images/image-20200718103112309.png\" /></p>\n\n<h2>Google为什么要创建Go</h2>\n\n<ul>\n	<li>计算机硬件技术更新频繁，性能提高很快。目前主流的编程语言发展明显落后于硬件，不能合理利用多核多CPU的优势提升软件系统性能。</li>\n	<li>软件系统复杂度越来越高，维护成本越来越高，目前缺乏一个足够简洁高效的编程语言。\n	<ul>\n		<li>现有编程语言存在：风格不统一、计算能力不够、处理大并发不够好</li>\n	</ul>\n	</li>\n	<li>企业运行维护很多c/c++的项目，c/c++程序运行速度虽然很快，但是编译速度确很慢，同时还存在内存泄漏的一系列的困扰需要解决。</li>\n</ul>\n\n<h2>Go语言发展历史</h2>\n\n<ul>\n	<li>2007年，谷歌工程师Rob Pike，Ken Thompson和Robert Griesemer开始设计一门全新的语言，这是Go语言的最初原型。</li>\n	<li>2009年11月10日，Google将Go语言以开放源代码的方式向全球发布。</li>\n	<li>2015年8月19日，Go1.5版发布，本次更新中移除了&rdquo;最后残余的c代码&rdquo;</li>\n	<li>2017年2月17日，Go语言Go1.8版发布。</li>\n	<li>2017年8月24日，Go语言Go1.9版发布。</li>\n	<li>2018年2月16日，Go语言Go1.10版发布。</li>\n</ul>\n\n<h2>Go语言的特点</h2>\n\n<p>Go语言保证了既能到达静态编译语言的安全和性能，又达到了动态语言开发维护的高效率，使用一个表达式来形容Go语言：Go=C+Python，说明Go语言既有C静态语言程序的运行速度，又能达到Python动态语言的快速开发。</p>\n\n<ul>\n	<li>从c语言中继承了很多理念，包括表达式语法，控制结构，基础数据类型，调用参数传值，指针等等，也保留了和C语言一样的编译执行方式及弱化的指针。</li>\n</ul>\n\n<pre>\n<code class=\"language-go\">// go语言的指针使用特点\nfunc testPtr(num *int)  {\n	*num = 20\n}\n</code></pre>\n\n<ul>\n	<li>引入包的概念，用于组织程序结构，Go语言的一个文件都要归属于一个包，而不能单独存在。</li>\n	<li>垃圾回收机制，内存自动回收，不需开发人员管理 【稍微不注意就会出现内存泄漏】</li>\n	<li>天然并发【重要特点】\n	<ul>\n		<li>从语言层面支持并发，实现简单</li>\n		<li>goroutine，轻量级线程，可实现大并发处理，高效利用多核。</li>\n		<li>基于CPS并发模型（Communicating Sequential Processes）实现</li>\n	</ul>\n	</li>\n	<li>吸收了管道通信机制，形成go语言特有的管道channel，通过管道channel，可以实现不同的goroute之间的相互通信</li>\n	<li>函数返回多个值（实例代码）</li>\n	<li>新的创新：比如切片slice，延时执行defer等</li>\n</ul>\n\n<h2>Hello Go</h2>\n\n<p>我们写一个最简单的入门代码，在控制台输出hello go！</p>\n\n<pre>\n<code class=\"language-go\">package main\n// fmt包中提供格式化，输入和输出的函数\nimport \"fmt\"\nfunc main() {\n	fmt.Println(\"hello go!\")\n}\n</code></pre>\n\n<h2>Golang执行流程分析</h2>\n\n<p>我们可以通过以下命令来进行操作</p>\n\n<ul>\n	<li>go build hello.go -&gt; hello.exe</li>\n	<li>go run hello.go</li>\n</ul>\n\n<p><img alt=\"image-20200718161111596\" src=\"images/image-20200718161111596.png\" /></p>\n\n<h3>两种执行流程分析</h3>\n\n<ul>\n	<li>如果我们先编译生成了可执行文件，那么我们可以将该可执行文件拷贝到没有go开发环境的机器上，然可以运行</li>\n	<li>如果我们是直接go rungo源代码，那么如果要在另外一个机器上这么运行，也需要go开发环境，否则无法执行。</li>\n	<li>在编译时，编译器会将程序运行依赖的库文件包含在可执行文件中，所以，可执行文件变大了很多。</li>\n</ul>\n\n<h3>什么是编译</h3>\n\n<ul>\n	<li>有了go源文件，通过编译器将其编译成机器可以识别的二进制码文件。</li>\n	<li>在该源文件目录下，通过go build 对hello.go文件进行编译。可以指定生成的可执行文件名，在windows下必须是.exe后缀。</li>\n	<li>如果程序没有错误，没有任何提示，会在当前目录下会出现一个可执行文件（windows下是.exe Linux下是一个可执行文件），该文件是二进制码文件，也是可以执行的程序。</li>\n	<li>如果程序有错误，编译时，会在错误的那行报错。</li>\n</ul>\n\n<h2>Go语言开发注意事项</h2>\n\n<ul>\n	<li>Go源文件以&ldquo;go&rdquo;为扩展名</li>\n	<li>Go应用程序的执行入口是main()方法</li>\n	<li>Go语言严格区分大小写。</li>\n	<li>Go方法由一条条语句构成，每个语句后不需要分号（Go语言会在每行后自动加分号），这也体现出Golang的简洁性。</li>\n	<li>Go编译器是一行行进行编译的，因此我们一行就写一条语句，不能把多条语句写在同一个，否则报错</li>\n	<li>Go语言定义的变量或者import的包如果没有使用到，代码不能编译通过</li>\n	<li>大括号都是成对出现的，缺一不可。</li>\n</ul>\n\n<h2>Go语言中的转义字符</h2>\n\n<p>GoLang常用的转义字符（escape char）</p>\n\n<ul>\n	<li>\\t：一个制表位，实现对齐的功能</li>\n	<li>\\n：换行符</li>\n	<li>\\：一个\\</li>\n	<li>\\r：一个回车</li>\n</ul>\n', '5626932d452c2ad863d9b3cb0b69d22d', 0, 0, 'd134bdfe255b9aa8c2ce44da8297f6a6', 1, '2021-01-14 15:38:18', '2021-02-07 13:17:42', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 4, '0', 0, 1, 0, NULL, 43, NULL, 0);
INSERT INTO `t_blog` VALUES ('635fc430e3378403a7d3f1e2a4e726a9', '测试', '测试', '<ul>\n	<li>不错</li>\n	<li>代办事项</li>\n	<li>代办事项三</li>\n</ul>\n\n<h1>测试</h1>\n\n<p>今天是个好日志</p>\n\n<p><img src=\"http://101.132.122.175:8080/mogublog/1605773385877.png\" /></p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 10, 1, 'c7782d374ed2d4bff8e43164ece9244d', 1, '2020-10-17 15:02:23', '2021-04-12 11:30:14', '1f01cd1d2f474743b241d74008b12333', '0', '陌溪', 'http://www.baidu.com', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 8, NULL, 0);
INSERT INTO `t_blog` VALUES ('69eed1ef9ff92d4fbcdc4f5e633e026b', '今天的天气非常非常不错哦今天的天气非常非常不错哦', '今天的天气非常非常不错哦今天的天气非常非常不错哦', '<p>123</p>\n', '7e0e93ea6cdb44ae92e58f48e6496ed7', 0, 0, '1e9b54926b2a9d9c23e90ff8bf5abc21', 0, '2021-04-12 09:17:59', '2021-04-12 10:55:57', NULL, '1', 'mogu2018', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '0', 0, 1, 0, NULL, 53, 'b486735e7b914e366840d01f049306e4', 0);
INSERT INTO `t_blog` VALUES ('7135efc7f536769efd0d0483c687ba07', '蘑菇博客Sentinel安装指南', '蘑菇博客Sentinel安装指南', '<h1>蘑菇博客Sentinel安装指南</h1>\n\n<h2>前言</h2>\n\n<p>Sentinel被称为分布式系统的流量防卫兵，相当于Hystrix</p>\n\n<p>Hystrix存在的问题</p>\n\n<ul>\n	<li>需要我们程序员自己手工搭建监控平台</li>\n	<li>没有一套web界面可以给我们进行更加细粒度化的配置，流量控制，速率控制，服务熔断，服务降级。。</li>\n</ul>\n\n<p>这个时候Sentinel运营而生</p>\n\n<ul>\n	<li>单独一个组件，可以独立出来</li>\n	<li>直接界面化的细粒度统一配置</li>\n</ul>\n\n<p>更详细的介绍可以参考这篇博客，这里只是讲解一下Sentinel的安装过程</p>\n\n<p><a href=\"http://moguit.cn/#/info?blogUid=408e9c889ebf96a66af2adfdc258ba5f\">【SpringCloud】使用Sentinel实现熔断和限流</a></p>\n\n<h2>安装Sentinel</h2>\n\n<p>首先我们到Sentinel的<a href=\"https://github.com/alibaba/Sentinel/releases\">Github官网</a>，下载对应的jar包</p>\n\n<p><img alt=\"image-20200814152203586\" src=\"http://image.moguit.cn/a5b21f63ab4e4d03bdb4ca5cbd58a784\" /></p>\n\n<p>下载完成后，放到我们的Sentinel文件夹下</p>\n\n<p><img alt=\"image-20200814152301259\" src=\"http://image.moguit.cn/ee9315ea26c2415a8f473f840951a1ec\" /></p>\n\n<p>我们可以通过 java -jar命令来启动，但是每次输入命令也挺麻烦的，因此我们可以制作一个bat脚本，点击启动</p>\n\n<p>我们创建一个startup.bat脚本，然后写入以下内容，指定端口号为 8070</p>\n\n<pre>\n<code class=\"language-bash\">start java -jar sentinel-dashboard-1.6.3.jar --server.port=8070\n\n</code></pre>\n\n<p><img alt=\"image-20200814152808028\" src=\"http://image.moguit.cn/8b696ca582024c0da84ba15d759d658d\" /></p>\n\n<p>然后我们输入URL： http://localhost:8070/，然后输入默认的账号和密码</p>\n\n<blockquote>\n<p>账号：sentinel</p>\n\n<p>密码：sentinel</p>\n</blockquote>\n\n<p><img alt=\"image-20200814152900162\" src=\"http://image.moguit.cn/47be08b668284e50b04ab9eef81d5beb\" /></p>\n\n<p>进入后，因为我们的项目还没有启动，所以看不到对应的配置信息</p>\n\n<p><img alt=\"image-20200814153013010\" src=\"http://image.moguit.cn/56e18bf430204fc7b13886eabe774c87\" /></p>\n\n<p>到这里为止，Sentinel流控就已经安装完成了，后续的操作我们可以参考下面的博客进行</p>\n\n<p><a href=\"http://moguit.cn/#/info?blogUid=082ca226cf2e4103b0ffa6e6c13d7b14\">window环境下配置蘑菇博客环境</a></p>\n\n<blockquote>\n<p>因为我们将Eureka替换成Nacos，所以我们只需要启动服务为</p>\n\n<p>mogu-sms、mogu-picture、mogu-admin、mogu-web</p>\n</blockquote>\n\n<p><img alt=\"image-20200814154038280\" src=\"http://image.moguit.cn/18c469a48e104b08b7aec0629a02a1ed\" /></p>\n\n<p>然后在启动前端服务后，再次查看Sentinel，我们就看到了三个微服务被监控了</p>\n\n<p><img alt=\"image-20200814154404812\" src=\"http://image.moguit.cn/12ffd3a1805e4224acc546edf4d3f8f3\" /></p>\n\n<p>然后我们打开 mogu-web，点击系统规则，然后新增系统规则</p>\n\n<p><img alt=\"image-20200814154515420\" src=\"http://image.moguit.cn/9920ddf718cd4388958f3a38953fd128\" /></p>\n\n<p>我们设置一个入口QPS为 30，也就是每秒30个请求</p>\n\n<p><img alt=\"image-20200814155422571\" src=\"http://image.moguit.cn/9fea49c6b1ce4d1fb78663ad478bfcfe\" /></p>\n\n<p>然后我们打开首页 http://localhost:9527/，发现能够正常的访问，但是如果我们反复的刷新该页面，当超过对应的QPS数后，就会出现500页面了</p>\n\n<p><img alt=\"image-20200814155402193\" src=\"http://image.moguit.cn/e55920035780427d91586398fb90a4b3\" /></p>\n\n<p>到这里为止，Sentinel的安装就完成了，如果想要了解更加复杂的规则，可以参考上面提到的<a href=\"http://moguit.cn/#/info?blogUid=408e9c889ebf96a66af2adfdc258ba5f\">那篇博客</a></p>\n', 'e81bc2dca42c4031be7d66fef4a71e16', 36, 2, '828227a0f1c736ea393fa4a747b1c5d9', 1, '2020-08-19 06:20:31', '2021-03-16 19:45:42', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 2, '1', 2, 1, 0, NULL, 9, NULL, 0);
INSERT INTO `t_blog` VALUES ('7643e39b4b93dc14094c450234f5d66b', '测试博客2', '测试博客2', '<p>测试博客2</p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 0, 0, NULL, 1, '2020-12-05 14:53:56', '2020-12-05 14:53:56', '1f01cd1d2f474743b241d74008b12333', '1', NULL, '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 28, NULL, 0);
INSERT INTO `t_blog` VALUES ('780199d24cf5a46e18ca9f4ac7fc1312', '默认标题1', '默认简介1', '<p>我是一个table</p>\n<table>\n<thead>\n<tr>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>4</td>\n<td>5</td>\n<td>6</td>\n</tr>\n<tr>\n<td>7</td>\n<td>8</td>\n<td>9</td>\n</tr>\n<tr>\n<td>10</td>\n<td>11</td>\n<td>12</td>\n</tr>\n</tbody>\n</table>\n', '7e0e93ea6cdb44ae92e58f48e6496ed7', 2, 0, 'd134bdfe255b9aa8c2ce44da8297f6a6', 0, '2020-09-06 17:08:45', '2020-10-07 16:31:58', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 2, '1', 0, 1, 0, NULL, 10, NULL, 0);
INSERT INTO `t_blog` VALUES ('783b7e58396b40bf434073047fc9c6bf', '测试', '测试', '<p>测试~</p>\n', '7e0e93ea6cdb44ae92e58f48e6496ed7', 0, 0, '621de99c4a0ff0fab1d25f8425b2afb7', 1, '2021-04-11 15:51:48', '2021-04-11 15:51:48', NULL, '1', 'mogu2018', NULL, 'a03d7290b1c04b6eaf46659661b47032', 0, '0', 0, 1, 0, NULL, 50, NULL, 0);
INSERT INTO `t_blog` VALUES ('7a7ad19472d53147150eb7fdb0978bb2', 'CentOS下安装NacosCentOS下安装NacosCentOS下安装NacosCentOS下安装NacosCentOS下安装Nacos', 'CentOS下安装Nacos', '<h1>CentOS下安装Nacos</h1>\n\n<h2>前言</h2>\n\n<p>这阵子因为蘑菇博客的镜像越来越大，所以就打算重新构建一下蘑菇博客的Docker镜像，这里就打算在Centos下安装配置Nacos，之前写过一篇博客关于Window下配置蘑菇博客的Nacos，感兴趣的小伙伴可以参考一下</p>\n\n<p><a href=\"http://moguit.cn/#/info?blogUid=8dc52bd61e36fa56cfc7699815375572\">Window蘑菇博客Nacos部署指南</a></p>\n\n<p><a href=\"http://moguit.cn/#/info?blogUid=e6e619349d31dded928c9265c5a9c672\">【SpringCloud】使用Nacos实现服务注册发现以及配置中心等功能</a></p>\n\n<h2>下载Linux版Nacos</h2>\n\n<p>首先我们到Nacos的 <a href=\"https://github.com/alibaba/nacos/releases\">Github页面</a>，找到我们需要安装的版本</p>\n\n<p><img alt=\"image-20200822112106696\" src=\"http://image.moguit.cn/24b2f2832d764c58ace6fe4761a9bb14\" /></p>\n\n<p>我们也可以右键复制到链接，然后通过wget命令进行下载</p>\n\n<pre>\n<code class=\"language-bash\">wget https://github.com/alibaba/nacos/releases/download/1.3.2/nacos-server-1.3.2.tar.gz\n\n\n</code></pre>\n\n<p>下载完成后，我们使用下面的命令进行解压</p>\n\n<pre>\n<code class=\"language-bash\">#解压\ntar -zxvf nacos-server-1.3.2.tar.gz\n\n\n</code></pre>\n\n<p>解压完成后，进入nacos文件夹里</p>\n\n<pre>\n<code class=\"language-bash\">cd nacos/bin\n\n\n</code></pre>\n\n<p>然后修改startup.sh中jvm的内存大小，根据自己的机器情况决定。</p>\n\n<pre>\n<code class=\"language-bash\">vim startup.sh\n\n\n</code></pre>\n\n<p>这里我设置的是最小堆内存128m，最大堆内存256m</p>\n\n<pre>\n<code class=\"language-bash\">if [[ \"${MODE}\" == \"standalone\" ]]; then\n    JAVA_OPT=\"${JAVA_OPT} -Xms128m -Xmx256m -Xmn256m\"\n    JAVA_OPT=\"${JAVA_OPT} -Dnacos.standalone=true\"\nelse\n    if [[ \"${EMBEDDED_STORAGE}\" == \"embedded\" ]]; then\n        JAVA_OPT=\"${JAVA_OPT} -DembeddedStorage=true\"\n    fi\n    JAVA_OPT=\"${JAVA_OPT} -server -Xms256m -Xmx512m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m\"\n    JAVA_OPT=\"${JAVA_OPT} -XX:-OmitStackTraceInFastThrow -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=${BASE_DIR}/logs/java_heapdump.hprof\"\n    JAVA_OPT=\"${JAVA_OPT} -XX:-UseLargePages\"\n\n\n</code></pre>\n\n<h2>Nacos+MySQL配置持久化</h2>\n\n<p>原来的配置文件是存储在内置的数据库SQLite中，我们如果要移动起来，可能不方便，下面我们可以配置一下nacos的mysql存储，</p>\n\n<p>我们找到数据库新建脚本nacos/conf/nacos-mysql.sql，创建数据库nacos_config并执行脚本</p>\n\n<h3>导入遇到问题</h3>\n\n<p>tip：我们在导入的时候，可能会遇到这个错误</p>\n\n<blockquote>\n<p>Error occured at:2020-08-22 11:37:11 Line no.:190 Error Code: 1071 - Specified key was too long; max key length is 767 bytes</p>\n</blockquote>\n\n<p>先检查一下是不是数据库被限制了索引的大小</p>\n\n<pre>\n<code>SHOW variables like \'innodb_large_prefix\'\n\n\n</code></pre>\n\n<p>如果查询的值是OFF的话 执行下面命令</p>\n\n<pre>\n<code>SET GLOBAL INNODB_LARGE_PREFIX = ON;\n\n\n</code></pre>\n\n<p>执行完了 之后 还得查看当前的innodb_file_format引擎格式类型是不是BARRACUDA执行</p>\n\n<pre>\n<code>SHOW variables like \'innodb_file_format\'\n\n\n</code></pre>\n\n<p>如果不是的话则需要修改</p>\n\n<pre>\n<code>SET GLOBAL innodb_file_format = BARRACUDA;\n\n\n</code></pre>\n\n<p>然后再次尝试导入，则成功导入到数据库中</p>\n\n<h3>修改nacos配置</h3>\n\n<p>下面我们需要到nacos的配置目录</p>\n\n<pre>\n<code class=\"language-bash\">vim nacos/conf/application.properties\n\n\n</code></pre>\n\n<p>然后在末尾添加我们的mysql的配置信息</p>\n\n<pre>\n<code class=\"language-bash\">spring.datasource.platform=mysql\ndb.num=1\ndb.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC\ndb.user=root\ndb.password=mogu2018\n\n\n</code></pre>\n\n<p>修改完成后，回到bin目录，启动nacos，启动命令standalone代表着单机模式运行，非集群模式):</p>\n\n<pre>\n<code class=\"language-bash\">sh startup.sh -m standalone\n\n\n</code></pre>\n\n<p>然后我们输入地址</p>\n\n<pre>\n<code class=\"language-bash\">http://youip:8848/nacos\n\n\n</code></pre>\n\n<p>会跳转到登录页面，输入默认账号和密码 nacos nacos即可进入</p>\n\n<p><img alt=\"image-20200822115650579\" src=\"http://image.moguit.cn/217b883c57a14927b1138c9b8b981ac3\" /></p>\n\n<p>到这里linux下的nacos已经成功安装~</p>\n\n<p><img alt=\"image-20200822120856725\" src=\"http://image.moguit.cn/05cdd82ee6cf4f628dd61152649383cb\" /></p>\n', '1d1fd6d26c8e40a38637ef6126c45cd0', 17, 0, '2f84fab3b2ef5fa75206c596514d9004', 1, '2020-08-24 13:25:28', '2021-04-12 16:20:43', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 1, '1', 1, 1, 0, NULL, 11, NULL, 0);
INSERT INTO `t_blog` VALUES ('7ae21f92398d6bbb1dfb4738ef5a1e8b', '测试2', '测试2', '<p>测试2</p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 0, 0, 'cc9952f52c84dfa51d74ee35a1dc5367', 0, '2020-10-13 09:19:53', '2020-10-13 09:23:35', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 12, NULL, 0);
INSERT INTO `t_blog` VALUES ('7f333b42280b1540c6649a288844a74f', '默认标题1', '默认简介1', '<h1>从三本院校到斩获字节跳动Offer-讲述我的故事</h1>\n<blockquote>\n<p>友情提示本文内容较长，都是干货，希望小伙伴能够耐心食用~文末有个人学习路线记录和笔记</p>\n</blockquote>\n<h2>前言</h2>\n<p>大家好，我是 <strong>陌溪</strong>。之前一直在写开源博客系统( <strong>蘑菇博客</strong> ) 和 开源学习笔记( <strong>LearningNotes</strong> )，内容大多数是学习或者做项目遇到的问题为主。这次打算写了一篇关于我的 <strong>Java自学</strong> 经历，希望对小伙伴有所收获~。</p>\n<p>因为我本科就读于北方某三本院校，和别人交谈的时候也不太愿意过多介绍关于自己本科的情况，想着英雄不问出处。不过后面想想，通过将自己的一些生活和学习经历分享出来，如果在某个阶段开始迷茫的小伙伴，也可以通过阅读我的经历，避免一些我走过的弯路，从而找到适合自己的路。</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216194004085.png\" alt=\"我的Gitee主页\" /></p>\n<h2>关于我</h2>\n<p>我本科就读于三本的独立学院，那会因为高考考得不好，说白了就是初中和高中阶段不爱学习导致的。</p>\n<p>比如初中的时候，那会班级里流行用 <strong>MP4</strong>，我就用压岁钱给自己买了一个 <strong>MP4</strong> ，竟然在晚上蒙在被子里用它来看小说，有的时候看到小说高潮部分，基本上能看到凌晨四五点，掀开被子一看，都天亮了~。</p>\n<p>到了白天上课的时候就昏昏欲睡，所谓天高皇帝远，因为在最后一排老师也看不到，所以有时候就趴在桌子上睡觉。这种状态一直持续到了快中考的几个月前。后面如我所愿，差点没读上高中，就是刚刚在分数线上的那种...</p>\n<p>然后高中开始分班，进行了一次中考成绩排名，打开排名一看，班上倒数第2名，一共 <strong>60</strong> 多个人。后面我就默默发誓要好好努力，不要辜负家人的期待，然后开始好好努力学习听课，成绩也由原来的倒数第二名，一下到了班上<strong>20</strong> 名左右。</p>\n<p>因为我们是高中年级的普通班(大家水平都差太多的)，在我们上面有 实验班(冲 <strong>985</strong> <strong>211</strong> 的人)，重点班(冲一本)。在经过一年的学习，我也顺利的从普通班 提升到了 A班(A班从多个普通班选拔前15名组成，但是整体的水平 &lt; 重点班 )，最后我们学校其实有四种等级划分：普通班 -&gt; A班 -&gt; 重点班 -&gt; 实验班。</p>\n<p>你以为后面的故事就一帆风顺了么？不不不，到了后面随着手机的普及(那会还是国产手机)，班级里掀起了一个热潮，就是用国产系统登 <strong>QQ</strong>，那会掀起一股比 <strong>QQ</strong> 等级的热潮。还就就是玩抢车位、<strong>QQ</strong> 农场 和 Q宠大乐斗，我也是在那会，果断咬牙入手了一个，然后沉迷于其中。</p>\n<p>中间一段时间，也经常和班级里的小伙伴组队去网吧玩游戏，那会玩的游戏是由盛大代理的《<strong>龙之谷</strong>》，当时被绚丽的游戏情节所和自由的格斗所吸引，每天和几个小伙伴组队去网吧玩耍，乐此不疲 (前阵子好像还出龙之谷手游了，还特意体验了一下，回顾青春，不过最后感觉太氪了，就放弃了)</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/2481927812.jpg\" alt=\"龙之谷-来源网络\" /></p>\n<p>后面的阶段基本就是...   上课听讲，下课玩耍。。 伴随着高考的结束，顺利度过了高中的生涯，因为高考完是在 <strong>6</strong> 月份，那会还不知道高考成绩，想着可以离开家锻炼一下自己了，所以先找了个我们那边的电子厂打暑假工(那会刚刚 <strong>18</strong> 岁)。</p>\n<p>在七月的某一天，老爸打电话给我，说他通过电话查询到了我的高考分数，其实和我当初高考估分的差不多，没有到二本线，还差 <strong>10</strong> 多分，所以如果想去读的话，<strong>只能选择一个三本院校</strong> ，或者去再努力复读一年。</p>\n<p>最后录取通知书出来了，我被挑选的一所三本院校录取了，不过专业都不是自己报考的<strong>电气工程及自动化、工程造价、能源与动力</strong>之类的，而是令我意想不到的<strong>计算机科学与技术专业</strong>。后面我也才了解到，我是被调剂到我们学院的计算机专业的，计算机专业在我们院属于比较垫底的专业 ( 说白了，那会来计算机学院的都是调剂生 )。</p>\n<p>“ <strong>选择拿着录取通知书去上学，还是再读一年，你自己好好考虑一下</strong> ”  这是老爸给我说的话，我琢磨了好久想想还是直接拿着通知书去了北方(我南方人，本科学校在北方)，因为想着未来还有很多不确定性，能找一步走就先走了(那会可能想着去离家远的地方，去看看外面的世界)。</p>\n<p>后面考虑到学的是计算机专业，所以我觉得以后肯定少不了和电脑接触，因此想着第一件事就是学好打字(那会只熟悉 <strong>WASD</strong> ，典型的一指禅)，选择了<strong>金山打字通</strong>练习打字，花了一个月的时间进行打字训练。(后面写代码的时候，也让我因为提前熟悉了<strong>键盘盲打</strong>而重拾自信... ，敲代码的速度比同学更快...)</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216160127714.png\" alt=\"用金山打字通学习打字\" /></p>\n<h2>初出茅庐</h2>\n<p>九月份，带着行李箱就开始了学校了，因为中途需要在北京转车，所以就在北京玩了两天。从北京西站下来后，我是第一次感受到了<strong>大城市的繁华</strong>，也默默想着<strong>毕业后能够留在这里工作</strong> 。</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216161209146.png\" alt=\"北京西站-来源网络\" /></p>\n<p>在北京，我和老爸去了北京天安门、故宫和长城，也第一次坐上了地铁。</p>\n<p>最后辗转来到了我们的学校，老爸去参加学校组织的<strong>家长见面会</strong>后和我说：“我了解到你们学校可以转专业，你大一就好好学习，达到转专业要求后，申请转到电气专业”，我那会其实对所有专业是啥，没有太大的感觉，所以就答应了老爸。</p>\n<p>后面就进入了大学生活了，大学的生活比高中生活更加轻松，不过我也没有放松自己。大一的时候还不能带电脑，所以老爸也没有给我配电脑，平时老师代码都是给我们在<strong>PPT</strong>上演示，那会也对编程产生了浓厚的兴趣，经常老师上课讲完的代码，会用小本子记录下来，然后跑去图书馆在一行一行的敲上去，那会乐此不疲。</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/psb.png\" alt=\"大一在写C语言的时候拍摄\" /></p>\n<p>那会对于代码完全是不知所以然，不知道为什么要这么写，然后很多程序的<strong>API</strong> 和一些算法(冒泡排序，选择排序)基本上都是用小本本记起来，然后每天都看看。就这样的状态，很快大一的时间就过完了。</p>\n<p>大二开始，我们开设了 <strong>Java</strong> 课程，通过学习 <strong>Java</strong>，我发现了原来编程不仅仅只是做出黑框框的，在命令行上运行的东西，它还能制作出 计算器，甚至是游戏(<strong>JavaGui</strong>)。</p>\n<p>这里其实特别感谢 传智播客的毕向东老师讲解的java基础 ，那会视频资源特别匮乏，我有幸接触到了毕老师的视频教程，最后花费了大二一个学期才把 <strong>Java</strong> 基础视频学完(那会基本上一行一行的手敲)，后面又跟着传智播客的另外一门视频教程《 <strong>Java</strong> 贪吃蛇游戏》，我也是整整花费了1个月的时间，每一行代码都是跟着视频敲出来的。到最后游戏能运行的那一刻，我突然对编程有了更加浓厚的学习兴趣。</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216162731514.png\" alt=\"大二在写贪吃蛇小游戏的时候\" /></p>\n<p>对了，为啥我没有去转专业去电气呢？因为大一的时候体测没有过，所以导致体育挂科了，最后无法满足学校转专业的要求...，转专业要求必须满足成绩在前<strong>5</strong>%，并且没有挂科..。所以就被迫留在了计算机专业，然后就有了后面的故事，不然，陌溪可能毕业后就在爬电线杆了。</p>\n<h2>渐入佳境</h2>\n<p>大三的时候，我们开始了分班，就是选拔出一些人到卓越工程师班 ( <strong>专注于编程实践</strong> )，我和家里人商量了一下，说我准备去参加这个班级，因为我觉得在里面我能够学习到很多东西。。</p>\n<p>当然去的条件也很苛刻，需要先通过编程考试，如果通过了初试，还需要进行复试，复试是自主选题，我做的就是跟着传智播客做的贪吃蛇小游戏。最后通过一系列的排名下来，我最终的成绩是<strong>2/29</strong>，组成了新的<strong>29</strong>人小班级。</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216164848277.png\" alt=\"卓工班上课的时候\" /></p>\n<p>在新的班级里，老师的要求比原来更严格了，在保证正常学习本科教学工作的基础上，同时增加了更多的实践性的课程，例如：<strong>Java编程、HTML+CSS+JavaScript、C#编程、.NET编程、Android编程、嵌入式开发</strong></p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216165051497.png\" alt=\"电脑卡，自己动手拆机装固态\" /></p>\n<p>那会学习了很多不一样技术，我也很感谢老师那段时间的付出，因为每门课最后完成了，都需要制作一个案例，采取的是小组的形式，然后需要进行答辩讲解(从这个时候，我就明白了团队协作的重要性..)</p>\n<ul>\n<li><strong>Java</strong> 课程：做的是一个超市采购系统( <strong>Java GUI</strong> 界面，整个国庆七天都在写它，没有出门)</li>\n<li>前端课程：写的是一个播放器界面(那会跟着 <strong>潭州学院</strong> 的公开课做的)</li>\n<li><strong>C#</strong> 课程：做的是一个高校报修管理系统，和两个小伙伴组队完成的(有现成的拖拽控件，那会发现新大陆.)</li>\n<li><strong>Linux</strong> 课程：制作了一个基于 <strong>QT</strong> 的飞行棋游戏(需要定义通信协议啥的)</li>\n<li><strong>.NET</strong> 课程：和三个小伙伴制作的蘑菇音乐(那会就是以蘑菇来命名的，我主要负责前端页面编写)</li>\n<li><strong>Android</strong> 课程：做的是一个 蘑菇阅读APP(那会还拿去参加一个比赛，还获奖了)</li>\n</ul>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216170429141.png\" alt=\"和三个小伙伴完成的蘑菇音乐，答辩的时候界面惊艳了大家\" /></p>\n<p>当初做的蘑菇阅读 <strong>APP</strong>，那个时候加入了一些新的功能，比如听书功能(调用科大讯飞 <strong>API</strong> )还有 机器人聊天功能(调用图灵机器人 <strong>API</strong> )</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/clip_image002-1608109776613.jpg\" alt=\"蘑菇阅读\" /></p>\n<p>在卓工班里，我们每个人虽然每天很辛苦，但是我觉得是过的最有意思的一段时光了，因为在这里我体验到了团队协作，每个人分工明确，大家都是奔着一个目标前进，就是让自己的作品能够更加出色。</p>\n<p>经过了大三一年的学习，虽然现在感觉那个时候我们学的课程很多(就是什么都会学习，不像培训机构那样专注于某一门课程)，但是现在想想也正是因为当初学的内容多，才让以后我们的就业不在局限于某一个方向，让对前端感兴趣的同学最后从事了前端相关的工作，对 <strong>Java</strong> 刚兴趣的同学从事了 <strong>Java</strong> 相关的工作，对 <strong>C#</strong> 和  <strong>.NET</strong> 感兴趣的也有自己的选择。</p>\n<blockquote>\n<p>不过如果小伙伴一开始就有明确的目标的话，比如像从事Java，那么我推荐直接学习Java 相关的技能即可。</p>\n<p>目前来说，比较认可的是 <strong>黑马</strong> 和 <strong>尚硅谷</strong> 的课程，在bilibili他们都有公开了，尤其是尚硅谷视频教程做的很良心，对我后面就业帮助很大。</p>\n</blockquote>\n<h2>波光粼粼</h2>\n<p>转眼就来到了大三的暑假了，这个时间大伙参加工作的就已经开始着手实习了，而考研的也开始准备考研的复习了。我和家里人交谈了一波，那会我是觉得直接参加工作赚钱去也不错，不过家里人希望我能参加考研，等读完研之后在参加工作。</p>\n<p>我最终还是被家里说服了，然后开始着手考研的复习，但是心里还想着工作的事情... 也正因为这个导致我后面摔跟头了，<strong>小伙伴希望能以此为戒</strong>：在面对考研和工作的抉择时，需要了解到自己喜欢什么，并且能够坚定自己的目标，而不是随波逐流。</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216183237134.png\" alt=\"那会为了准备考研，特意报名了一个辅导班\" /></p>\n<p>但是那会考研也没有很专注，在面对其它同学在找工作的时候，又跟着一起凑热闹，一块参加面试(当初面试实习岗位，面了两家还都被录取了)。那会对考研的事情又产生了动摇心理，然后在家里人的劝告下，我又继续回到了考研课程的学习，同时那会考研也不是特别专心的准备，那会每天晚上八点钟就回到了寝室，继续玩着游戏..</p>\n<p>就这样一边复习考研，然后晚上八点就回来继续做梦幻西游的活动，这样的状态，一直持续到考研结束...，最后考研分数出来了，结果也正如大家所预料的那样，嗯，完蛋了....。</p>\n<h2>跋山涉水</h2>\n<p>考研成绩出来的那会，还处于大四的寒假，在得知自己无法读研的时候，毅然决定自己需要好好准备复习专业知识，然后去参加校园招聘。因为我们学院电气是王牌专业，所以基本上来的都是一些电力相关的，很少有计算机专业的招聘过来( 现在的话，推荐小伙伴们能够多多关注网站上的校园招聘平台，比如 <a href=\"https://www.nowcoder.com/recommend/campus\">牛客网</a> 等)。</p>\n<p>后面我决定和发小一块，去他的学校等待校园招聘 (发小在我们那边的一所 <strong>211</strong> 学校 )。然后在等待的过程中，也不断的学习相关的知识，因为之前的本科学习阶段，只了解了技术的广度，对某些技术不是很深入，而现在我可能专注于找 <strong>Java</strong>相关工作，所以我需要继续系统学习 <strong>JavaEE</strong> 相关的内容，所以后面就来到了发小的学校，和他一块准备通过校招来找工作。</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216185012032.png\" alt=\"在发小的宿舍进行学习\" /></p>\n<p>因为发小之前去参加过培训机构，专门培训的 <strong>Android</strong> 开发(但是培训完发现 <strong>Android</strong> 工作不好找，所以也准备转行 <strong>Java</strong> )，这个时候，他给我推荐了 <strong>Java1234</strong> 的学习网站，跟着 <strong>锋哥</strong> 幽默的话语，我学习了关于Java方面的进阶知识，同时也跟着做了几个实践项目。</p>\n<p>在发小那边大概呆了半个月，但是一直没有等到他们学校的校招的消息，这个时候因为经过半个月的学校，基本上对Java开发有一定的了解(现在想想，其实就是一些皮毛，只学了JSP和Servlet....，做了两个JSP相关的项目，想想那会也是太年轻.. )，所以就打算直接去深圳寻找公司实习。说走就走，和发小道别后，开始踏上了新的征途。</p>\n<p>因为我是南方人，想着以后就在深圳工作了，所以就先试着看能不能找到深圳的实习先做着，但事与愿违，后面并没有按照我理想的那样来...</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216190021186.png\" alt=\"在堂哥出租屋里学习\" /></p>\n<p>在深圳堂哥家里找到落脚点后，就开始了工作的简历投递，那会真是饥不择食，只要写的招收实习生的公司，基本上都投递，但是也遇到了很多坑.....就是要么面试一家就发现是培训机构，要求你先缴纳培训费，实训完成后给你安排工作；要么就是职场 <strong>PUA</strong>，首先给你特别难的面试题，来摧毁你的面试信心，最后在告诉你，即使不会这些也没关系，有专业的项目经理给你岗前实训....，有些说没钱也没关系，可以给你安排先培训，就业后还款....</p>\n<blockquote>\n<p>PS：后面我就知道了，可以先通过 <a href=\"https://www.tianyancha.com/\">天眼查</a>  先查公司的运营范围，如果这家公司运营范围包含了 技能培训，或者计算机培训，那么很大的概率就是培训机构...</p>\n</blockquote>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216191344572.png\" alt=\"使用天眼查看公司运营范围\" /></p>\n<p>在深圳的半个月里，参加了 <strong>10</strong> 场面试，其实有 <strong>8</strong> 家面试都是和培训机构有关的，两场是因为能力没有满足人家的要求(那会只学了 <strong>JSP</strong>、连 <strong>Spring</strong> 相关的框架都没了解过..)，因为离南山区比较远，那会也没有通地铁，基本上是面试 <strong>10</strong> 分钟，坐车 <strong>2</strong> 小时，那段时光也是最艰难的时光，不过我心态其实还挺好的，没有找到工作，就当去深圳玩了一阵子~。</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216191456847.png\" alt=\"在经过腾讯大厦的时候拍摄的\" /></p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216191706662.png\" alt=\"在中山公园逛了一圈\" /></p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216191948398.png\" alt=\"去深圳大学逛了一圈,对面就是腾讯大厦\" /></p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216192040885.png\" alt=\"去了爬凤凰山\" /></p>\n<p>在经过半个月的深圳找工作之旅，最后以失败告终，想想可能还是自己能力太弱(可能当初一开始就选错了方式，因为我走的这条路属于社招的道路，如果还没有毕业的小伙伴，还是要多多关注一些校招平台，以及对应的公众号：校招优选、校招薪水 等..，或者直接是访问人家的官网，有些公司会直接在官网上发布实习岗位)，后面在剩下的一阵子里，我开始继续强化自己的 <strong>Java</strong> 技能，那会跟着 <strong>黑马程序员</strong> 的培训视频进行学习。</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216192533681.png\" alt=\"黑马程序员的视频\" /></p>\n<blockquote>\n<p>bilibili黑马学习视频：<a href=\"https://space.bilibili.com/441640380\">https://space.bilibili.com/441640380</a></p>\n<p>bilibili尚硅谷学习视频：<a href=\"https://space.bilibili.com/302417610\">https://space.bilibili.com/302417610</a></p>\n</blockquote>\n<h2>健步如飞</h2>\n<p>在经过一段时间的强化学习后，本科的小伙伴邀请我去北京试试机会，后面我又踏上了北上的道路，来到了北京，这个时候只想着能找个管饭的工作，哈哈..</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216193040813.png\" alt=\"深圳开往北京西的火车站\" /></p>\n<p>来到了北京，和之前的同学一块去参加招聘，白天参加招聘，晚上就回来一块互相总结经验</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216193457868.png\" alt=\"去北京参加的招聘会现场\" /></p>\n<p>其中，中间还回学校参加了校园招聘，不过公司都不太合适，最后还是选择在北京寻找实习机会。大概在北京面试了一个礼拜后，终于通过了一家公司的面试，最后也顺利办理了实习入职手续，拥有了自己的工位。</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216193651195.png\" alt=\"第一天上班装系统\" /></p>\n<p>虽然实习的工资并不高，但是我也格外珍惜这来之不易的机会，所以在工作的时候，也比较认真的在学习，同时公司对于代码这块也有很多规范，每个一段时间就需要进行代码的 <strong>review</strong>，自己首次提交的代码，也都会经过同事的评审，审核通过后，才能提交。</p>\n<p>实习的几个月里，我真正了解到了企业级项目是如何开发的，同时加深了<strong>Git、Maven、Spring、Mybatis</strong> 等框架的使用。虽然公司很小，核心开发人员只有 <strong>7</strong> 个人，但做事都很有规范，并且每隔两天就会有一个 <strong>20</strong> 分钟的短会，介绍自己目前做了哪些工作，然后遇到了什么问题，未来将做什么？</p>\n<blockquote>\n<p>当然每个人都有进度的，如果你提前完成了，你就可以去看自己的东西，或者学习新知识(这方面我是觉得做得非常好的，因为公司也给了你成长的机会，而不是让你沉迷于业务代码)</p>\n<p>同时如果其它小伙伴遇到问题了，比如我开发某个模块卡住了，那么其它小伙伴可以协助一块进行开发，我也特别感谢另外两个实习小伙伴，帮助我一块解决项目中遇到的问题，尤其是前期在阅读项目时所遇到的。</p>\n</blockquote>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216194519225.png\" alt=\"同事指出我写的不规范的地方\" /></p>\n<p>关于每天的生活吃早餐的话，都是在路上来吃的，有的时候会在公司边上的麦当劳</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216195133159.png\" alt=\"早上八点多麦当劳的早餐：6元一份 汉堡+可乐\" /></p>\n<p>早上七点，排队进地铁站，有的时候人太多的话，可能需要排队半个小时才能进去(排队长度超过了500米..)，所以在北京其实都不容易的，因为实习工资低，那会住的都比较远，去上班的话，可能都需要乘坐三种交通工具：公交车 -&gt;地铁 -&gt; 单车，每天早上七点就要起床，路途花费大概快1个半小时</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216195833077.png\" alt=\"太早起来，大家都还没太睡醒\" /></p>\n<p>地铁换乘的时候，也是人山人海~</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216194834743.png\" alt=\"北京西二旗上班时的拍摄图片\" /></p>\n<p>有的时候来早了，公司可能还没开门，所以就在楼下坐着等待一会，看看技术相关的文章</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216203825109.png\" alt=\"公司的楼下\" /></p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216204709009.png\" alt=\"公司楼下一角\" /></p>\n<h2>卷土重来</h2>\n<p>后面毕业后，就在公司转正了，那会工资也很低，不过那会想着应届生毕业，先能好好学习到技术就好了，所以就留在公司继续做了几个月。后面家里人打电话跟我说不要因为一次的考研失败就放弃了，可以再去尝试尝试。我听了他们的话，也没有马上同意或者拒绝，而是静心的考虑了一段时间...</p>\n<p>在后面 <strong>9</strong> 月份的时候，坚定考研二战的想法，这个时候就想着在好好努力一下，所以就离职了，直接收拾东西，在 <strong>2017</strong>年 <strong>9</strong> 月 <strong>28</strong> 日，踏上了回家考研复习的征程...</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216205551007.png\" alt=\"北京西站准备回家\" /></p>\n<p>回到家里后，我哥他们邀请一起去附近的景点玩一天，调整一下心态</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216210019813.png\" alt=\"景点一角\" /></p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216210038889.png\" alt=\"景点一角\" /></p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216210054284.png\" alt=\"景点一角\" /></p>\n<p>考研的时间是 12月25日，回到家后是 10月1日，距离考研还有 80多天。因为有了之前的经验，所以现在复习也更加有了针对性，比如数学就跟着张宇、英语跟着刘晓燕，政治跟着肖秀荣，然后专业课因为有往年的真题，所以就结合课本和真题进行复习。下面是我考研时写的每日计划(请忽略我写的这么丑的字.....，在考政治上吃了大亏..)</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216210205139.png\" alt=\"考研报考界面\" /></p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216210653294.png\" alt=\"写的每日目标\" /></p>\n<p>然后开始刷题，背题...</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216211346375.png\" alt=\"狂背肖4-网图\" /></p>\n<p>这个状态一直持续到了考试结束，到后面成绩公布，出分数线了，有机会进入复试，所以后面就开始准备复试相关的了，因为之前参加过实习和工作，所以就先把自己的简历好好写写，把握好自己的优势。最后随着复试结果的公布，成功被学校录取了，最终考研一事尘埃落定。</p>\n<h2>新的旅途</h2>\n<p>在考研已经确定被录取后，那个时候是在 <strong>4</strong> 月份，而研究生入学是在 <strong>9</strong> 月份，这个时候有大概 <strong>5</strong> 个月的空窗期，如果是应届生的话，可能还需要回学校写毕业论文，而我属于往届生是没有这些操作的。因此，我又萌生出去打工的想法，找一份工作先做着，等到开学的时候在去入学。</p>\n<p>所以后面很快又来到了北京，开始寻找第二份工作，有了之前的经历，后面找工作就轻松了许多，面试了 <strong>10</strong> 天，最后拿了 <strong>3</strong> 家公司的 <strong>Offer</strong> ，最终选择了一家比较近的。</p>\n<p>在第二家公司，主要做的是小程序相关的业务，主要由我和另外一个小伙伴负责，但是技术经理考虑到扩展性和后期的维护，要求我们使用<strong>SpringBoot</strong> + <strong>Vue</strong> + <strong>微信小程序</strong> 来做，因为我之前实习的时候用的是 <strong>Spring</strong>，对于这一块比较新的技术还不是特别了解，所以后面就特意花了一段时间来学习。</p>\n<ul>\n<li><strong>SpringBoot</strong>：来源于 <strong>bilibili</strong> 尚硅谷的视频 ：<a href=\"https://www.bilibili.com/video/BV1Et411Y7tQ\">https://www.bilibili.com/video/BV1Et411Y7tQ</a></li>\n<li><strong>Vue</strong>：主要是根据Vue官方文档来学习的，因为中文文档比较友好：<a href=\"https://cn.vuejs.org\">https://cn.vuejs.org</a></li>\n<li><strong>ElementUi</strong>：<strong>Vue</strong> 的框架，也是直接看文档：<a href=\"https://element.eleme.cn\">https://element.eleme.cn</a></li>\n<li><strong>微信小程序</strong>：因为之前毕设是用微信小程序做的，所以还算有点熟悉</li>\n</ul>\n<p>项目经理把项目架构的搭建到业务编码开发，以及最后运维部署都交给了我们两个人，我们两个也是互相协同开发，来这四个月里，做到了从 0 ~ 1 完成整条开发流水线的工作。</p>\n<p>在新的工作中，没有了之前的迷茫，在做需求的时候，也懂得了如何将需求切分，更好的去完成每一项开发功能</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216214219555.png\" alt=\"用工资给自己换了一台新电脑和键盘\" /></p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216214320948.png\" alt=\"用工资，给自己买了一台平板娱乐\" /></p>\n<p>在北京的这几个月里也经历了很多，比如暴雨天的北京</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216214704116.png\" alt=\"暴雨天孤独无援的小哥\" /></p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216214802161.png\" alt=\"摊着水上班的我\" /></p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216215528799.png\" alt=\"和小伙伴在寝室一块改善伙食\" /></p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216215904699.png\" alt=\"在北京生日 小伙伴们送上蛋糕祝福\" /></p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216215937587.png\" alt=\"和寝室小伙伴一起组装电脑\" /></p>\n<p>四个月的时光，很快就过去了.....，又到了离开的时候，踏上旅途，开始去读研了，这次的离开，可能以后都很少有机会再回去了..</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216220135569.png\" alt=\"离开时的北京西站\" /></p>\n<h2>步履矫健</h2>\n<p>在进入研究生阶段后，我首先明确了自己的目标，比如：<strong>读博</strong> or <strong>就业</strong> ？我的选择是毕业后直接就业，因为之前经历了社招的痛苦，所以现在格外珍惜自己以后的校招机会。</p>\n<p>入学后的第一天我就给自己定下目标，能坚持做一款开源软件，用来记录自己学习中遇到的问题，最后经过敲定，决定还是以 <strong>蘑菇博客</strong> 为名。</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201218200306061.png\" alt=\"蘑菇博客的第一次代码提交\" /></p>\n<p><a href=\"https://gitee.com/moxi159753/mogu_blog_v2\">蘑菇博客</a> 项目最开始由我一个人开发，中间陆陆续续有一两个小伙伴参与其中，开发了一部分模块，我也想着能尽可能把更多的技术融合进来，毕竟通过自己手把手的操作一遍，也能够算是入门了。</p>\n<p>我也很庆幸我成功将自己的项目开源出来了，并且坚持下来，蘑菇博客起源是 <strong>2018</strong> 年 <strong>9</strong> 月，很感谢之前在公司里的同事和领导，是他们带我入门企业级的项目开发，让我养成了很多 <strong>Java</strong> 项目开发的规范，但是到真正在自己手把手搭建一个项目的时候，还是有很多的意外情况。</p>\n<p>起初项目开源在码云上，没有多少人关注，在<strong>2019</strong>年<strong>12</strong>月<strong>14</strong>日，蘑菇博客被码云推荐了，后面陆续有一些小伙伴关注了项目，并且参与到开发中，也提供了很多 <strong>issue</strong> ，在这里我也学习到了很多规范和功能的实现。</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/49865d11fd4c4b289d87bf305b2dde0a.png\" alt=\"蘑菇博客上首页了\" /></p>\n<blockquote>\n<p>蘑菇博客Gitee地址：<a href=\"https://gitee.com/moxi159753/mogu_blog_v2\">https://gitee.com/moxi159753/mogu_blog_v2</a></p>\n</blockquote>\n<p>然后项目的关注度就开始上升了，有些小伙伴就开始关注，所以我也花费了一些时间，整理了博客的开发、运行、部署的文档，希望每个小伙伴都能够通过本项目一起学习、。</p>\n<p>因为更新比较勤快，项目也在码云 &quot;<strong>博客</strong>&quot;  关键字搜索的第一个，不过未来要走得路还很长，我也希望能够认识更多志同道合的小伙伴，然后一起学习和交流。</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/36588a0c8bf04e9bb103eac0f432bfa7.png\" alt=\"搜索博客\" /></p>\n<p><strong>2020</strong>年<strong>7</strong>月<strong>28</strong>日，蘑菇博客成功达到<strong>1000star</strong>，也完成了我之前定下的一个小目标，这也是一个新的起点，后面我还需要更加努力。</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/727ee054ed214bf9ba6540413497c9a9.png\" alt=\"蘑菇博客项目\" /></p>\n<p><strong>2020</strong>年<strong>9</strong>月<strong>7</strong>号收到了码云邮寄过来的<strong>Gitee 1000 Star</strong>奖杯~</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/c24305a6c0124747945bb9bf53530a2c.png\" alt=\"蘑菇博客1000Star奖杯\" /></p>\n<p><strong>2020</strong>年<strong>12</strong>月<strong>16</strong>日，到目前为止，蘑菇博客已经<strong>2K Star</strong>了</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216222644401.png\" alt=\"我的Gitee首页\" /></p>\n<p>并且后面开源的 <strong>LearningNotes项目</strong> (学习笔记，记录平时的博客)，也已经收获了 <strong>1.5K Star</strong></p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201218201058254.png\" alt=\"学习笔记1000Star奖杯\" /></p>\n<blockquote>\n<p>学习笔记Gitee地址：<a href=\"https://gitee.com/moxi159753/LearningNotes\">https://gitee.com/moxi159753/LearningNotes</a></p>\n</blockquote>\n<h2>关于博客</h2>\n<p>蘑菇博客( <strong>MoguBlog</strong> )，一个基于微服务架构的前后端分离博客系统。<strong>Web</strong>端使用 <strong>Vue</strong> + <strong>Element</strong> , 移动端使用<strong>Uniapp</strong> 和 <strong>ColorUI</strong> 。后端使用 <strong>Spring Cloud</strong> + <strong>Spring boot</strong> + <strong>Mybatis-plus</strong> 进行开发，使用 <strong>Jwt</strong> + <strong>Spring Security</strong> 做登录验证和权限校验，使用 <strong>ElasticSearch</strong> 和 <strong>Solr</strong> 作为全文检索服务，使用 <strong>Github Actions</strong> 完成博客的持续集成，使用ELK收集博客日志，文件支持上传 <strong>七牛云</strong> 和 <strong>Minio</strong>。</p>\n<p>欢迎大家能 <strong>Star</strong> 支持一下下哦，同时也可以参与到蘑菇博客的开源贡献中，如果想要体验完整的内容，欢迎关注Gitee中的演示环境，直接登录进行体验~</p>\n<blockquote>\n<p>蘑菇博客Gitee地址：<a href=\"https://gitee.com/moxi159753/mogu_blog_v2\">https://gitee.com/moxi159753/mogu_blog_v2</a></p>\n<p>蘑菇博客Github地址：<a href=\"https://github.com/moxi624/mogu_blog_v2\">https://github.com/moxi624/mogu_blog_v2</a></p>\n</blockquote>\n<h3>摘要</h3>\n<p>蘑菇博客( <strong>MoguBlog</strong> )，一个基于微服务架构的前后端分离博客系统。<strong>Web</strong>端使用 <strong>Vue</strong> + <strong>Element</strong> , 移动端使用<strong>Uniapp</strong> 和 <strong>ColorUI</strong> 。后端使用 <strong>Spring Cloud</strong> + <strong>Spring boot</strong> + <strong>Mybatis-plus</strong> 进行开发，使用 <strong>Jwt</strong> + <strong>Spring Security</strong> 做登录验证和权限校验，使用 <strong>ElasticSearch</strong> 和 <strong>Solr</strong> 作为全文检索服务，使用 <strong>Github Actions</strong> 完成博客的持续集成，使用ELK收集博客日志，文件支持上传 <strong>七牛云</strong> 和 <strong>Minio</strong></p>\n<h3>项目起源</h3>\n<p>蘑菇博客大部分功能是我个人进行开发的，因能力有限，其中很多技术都是一边学习一边使用的，可以说蘑菇博客也是一个我用来熟悉技术的项目，所以很多地方可能考虑不周，故有能改正的地方，还请各位老哥能够指出~</p>\n<p>现在挺多是 <strong>SSM</strong> 或者 <strong>SSH</strong> 的博客管理系统，想用 <strong>Spring boot</strong> + <strong>Spring Cloud</strong> + <strong>Vue</strong> 的微服务架构进行尝试项目的构建，里面很多功能可能只是为了满足自己的学习需求而引入的，大家可以根据自己服务器配置来选择启动的服务，因此本博客也是一个非常好的 <strong>SpringBoot</strong> 、<strong>SpringCloud</strong> 以及 <strong>Vue</strong> 技术的入门学习项目。</p>\n<p>原来做过 <strong>Vue</strong> + <strong>Element-Ui</strong> 做过管理系统，所以现在打算做一套自己的、基于当前最新技术栈、前后端分离的微服务博客系统。</p>\n<h3>项目特点</h3>\n<ul>\n<li>友好的代码结构及注释，便于阅读及二次开发</li>\n<li>实现前后端分离，通过 <strong>Json</strong> 进行数据交互，前端再也不用关注后端技术</li>\n<li>页面交互使用 <strong>Vue2.x</strong>，极大的提高了开发效率。</li>\n<li>引入<strong>Swagger</strong> 文档支持，方便编写API接口文档。</li>\n<li>引入 <strong>RabbitMQ</strong> 消息队列，用于邮件发送、更新 <strong>Redis</strong> 、<strong>Solr</strong> 和 <strong>ElasticSearch</strong></li>\n<li>引入 <strong>JustAuth</strong> 第三方登录开源库，支持 <strong>Gitee</strong>、<strong>Github</strong> 账号登录。</li>\n<li>引入<strong>ElasticSearch</strong> 和 <strong>Solr</strong> 作为全文检索服务，并支持可插拔配置</li>\n<li>引入<strong>Github Actions</strong> 工作流，完成蘑菇博客的持续集成、持续部署。</li>\n<li>引入 <strong>七牛云</strong> 和 <strong>Minio</strong> 对象存储，同时支持本地文件存储</li>\n<li>引入<strong>RBAC</strong> 权限管理设计，灵活的权限控制，按钮级别的细粒度权限控制，满足绝大部分的权限需求</li>\n<li>引入 <strong>Zipkin</strong> 链路追踪，聚合各业务系统调用延迟数据，可以一眼看出延迟高的服务</li>\n<li>采用自定义参数校验注解，轻松实现后端参数校验</li>\n<li>采用 <strong>AOP</strong> + <strong>自定义注解</strong> + <strong>Redis</strong> 实现限制IP接口访问次数</li>\n<li>采用自研的评论模块，实现评论邮件通知</li>\n<li>采用 <strong>Nacos</strong> 作为服务发现和配置中心，轻松完成项目的配置的维护</li>\n<li>采用 <strong>Sentinel</strong> 流量控制框架，通过配置轻松实现网站限流</li>\n<li>采用 <strong>uniapp</strong> 和 <strong>ColorUi</strong> 完成蘑菇博客的移动端门户页面搭建</li>\n<li>支持多种文本编辑器，<strong>Markdown</strong> 编辑器(<a href=\"https://github.com/Vanessa219/vditor\">Vditor</a>)和富文本编辑器(<a href=\"https://github.com/ckeditor/ckeditor4\">CKEditor</a>)随心切换</li>\n<li>采用 <strong>ElasticStack</strong>【ElasticSearch+Beats+Kibana+Logstash】搭建蘑菇博客日志收集</li>\n<li>采用 <strong>Docker Compose</strong> 完成容器编排，<strong>Portainer</strong> 实现容器可视化，支持一键部署线上环境</li>\n</ul>\n<h3>后端技术</h3>\n<table>\n<thead>\n<tr><th align=\"center\">技术</th><th align=\"center\">说明</th></tr>\n</thead>\n<tbody>\n<tr><td align=\"center\">SpringBoot</td><td align=\"center\">MVC框</td></tr>\n<tr><td align=\"center\">SpringCloud</td><td align=\"center\">微服务框架</td></tr>\n<tr><td align=\"center\">SpringSecurity</td><td align=\"center\">认证和授权框架</td></tr>\n<tr><td align=\"center\">MyBatis-Plus</td><td align=\"center\">ORM框架</td></tr>\n<tr><td align=\"center\">Swagger-UI</td><td align=\"center\">文档生产工具</td></tr>\n<tr><td align=\"center\">Kibana</td><td align=\"center\">分析和可视化平台</td></tr>\n<tr><td align=\"center\">Elasticsearch</td><td align=\"center\">搜索引擎</td></tr>\n<tr><td align=\"center\">Beats</td><td align=\"center\">轻量型数据采集器</td></tr>\n<tr><td align=\"center\">Logstash</td><td align=\"center\">用于接收Beats的数据并处理</td></tr>\n<tr><td align=\"center\">Solr</td><td align=\"center\">搜索引擎</td></tr>\n<tr><td align=\"center\">RabbitMQ</td><td align=\"center\">消息队列</td></tr>\n<tr><td align=\"center\">Redis</td><td align=\"center\">分布式缓存</td></tr>\n<tr><td align=\"center\">Docker</td><td align=\"center\">容器化部署</td></tr>\n<tr><td align=\"center\">Druid</td><td align=\"center\">数据库连接池</td></tr>\n<tr><td align=\"center\">七牛云</td><td align=\"center\">七牛云 - 对象储存</td></tr>\n<tr><td align=\"center\">JWT</td><td align=\"center\">JWT登录支持</td></tr>\n<tr><td align=\"center\">SLF4J</td><td align=\"center\">日志框架</td></tr>\n<tr><td align=\"center\">Lombok</td><td align=\"center\">简化对象封装工具</td></tr>\n<tr><td align=\"center\">Nginx</td><td align=\"center\">HTTP和反向代理web服务器</td></tr>\n<tr><td align=\"center\">JustAuth</td><td align=\"center\">第三方登录的工具</td></tr>\n<tr><td align=\"center\">Hutool</td><td align=\"center\">Java工具包类库</td></tr>\n<tr><td align=\"center\">阿里大于</td><td align=\"center\">短信发送平台</td></tr>\n<tr><td align=\"center\">Github Actions</td><td align=\"center\">自动化部署</td></tr>\n<tr><td align=\"center\">Zipkin</td><td align=\"center\">链路追踪</td></tr>\n<tr><td align=\"center\">Flexmark-java</td><td align=\"center\">Markdown转换Html</td></tr>\n<tr><td align=\"center\">Ip2region</td><td align=\"center\">离线IP地址定位库</td></tr>\n<tr><td align=\"center\">Minio</td><td align=\"center\">本地对象存储服务</td></tr>\n<tr><td align=\"center\">Docker Compose</td><td align=\"center\">Docker容器编排</td></tr>\n<tr><td align=\"center\">Portainer</td><td align=\"center\">Docker可视化管理</td></tr>\n</tbody>\n</table>\n<h3>前端技术</h3>\n<table>\n<thead>\n<tr><th align=\"center\">技术</th><th align=\"center\">说明</th></tr>\n</thead>\n<tbody>\n<tr><td align=\"center\">Vue.js</td><td align=\"center\">前端框架</td></tr>\n<tr><td align=\"center\">Vue-router</td><td align=\"center\">路由框架</td></tr>\n<tr><td align=\"center\">Vuex</td><td align=\"center\">全局状态管理框架</td></tr>\n<tr><td align=\"center\">Nuxt.js</td><td align=\"center\">创建服务端渲染 (SSR) 应用</td></tr>\n<tr><td align=\"center\">Element</td><td align=\"center\">前端ui框架</td></tr>\n<tr><td align=\"center\">Axios</td><td align=\"center\">前端HTTP框架</td></tr>\n<tr><td align=\"center\">Echarts</td><td align=\"center\">图表框架</td></tr>\n<tr><td align=\"center\">CKEditor</td><td align=\"center\">富文本编辑器</td></tr>\n<tr><td align=\"center\">Highlight.js</td><td align=\"center\">代码语法高亮插件</td></tr>\n<tr><td align=\"center\">Vditor</td><td align=\"center\">Markdown编辑器</td></tr>\n<tr><td align=\"center\">vue-cropper</td><td align=\"center\">图片裁剪组件</td></tr>\n<tr><td align=\"center\">vue-image-crop-upload</td><td align=\"center\">vue图片剪裁上传组件</td></tr>\n<tr><td align=\"center\">vue-emoji-comment</td><td align=\"center\">Vue Emoji表情评论组件</td></tr>\n<tr><td align=\"center\">clipboard.js</td><td align=\"center\">现代化的拷贝文字</td></tr>\n<tr><td align=\"center\">js-beautify</td><td align=\"center\">美化JavaScript代码</td></tr>\n<tr><td align=\"center\">FileSaver.js</td><td align=\"center\">保存文件在客户端</td></tr>\n<tr><td align=\"center\">SortableJS</td><td align=\"center\">功能强大的JavaScript 拖拽库</td></tr>\n<tr><td align=\"center\">vue-side-catalog</td><td align=\"center\">目录导航栏</td></tr>\n<tr><td align=\"center\">uniapp</td><td align=\"center\">移动端跨平台语言</td></tr>\n<tr><td align=\"center\">colorUi</td><td align=\"center\">专注视觉的小程序组件库</td></tr>\n<tr><td align=\"center\">showdown</td><td align=\"center\">用Javascript编写的Markdown 到Html转换器</td></tr>\n<tr><td align=\"center\">turndown</td><td align=\"center\">用JavaScript编写的HTML到Markdown转换器</td></tr>\n</tbody>\n</table>\n<h3>项目架构图</h3>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/server.jpg\" alt=\"项目架构图\" /></p>\n<h3>部分截图</h3>\n<p>此处只是列举了部分截图，如果想要体验完整的内容，欢迎关注Gitee中的演示环境，直接登录进行体验~</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/index.png\" alt=\"门户页面\" /></p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201218202417475.png\" alt=\"关于我\" /></p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201218202438433.png\" alt=\"归档页面\" /></p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201218202536293.png\" alt=\"后台仪表盘\" /></p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201218202618987.png\" alt=\"博客管理\" /></p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201218202641551.png\" alt=\"编辑文章\" /></p>\n<h3>关于开源</h3>\n<p>从开源的过程中，不仅自己的能力能得到提升，同时也能认识非常多志同相合的小伙伴，包括在群里的小伙伴们，也有一些一块参与到项目的维护和开发中，也有一些给我们提供 <strong>issue</strong> 和 <strong>idea</strong> ，同时能够和一些参加多年工作经验的老哥交流，也是受益匪浅的。</p>\n<p>通过开源，我也获得了很多工作机会。就本次秋招来讲，其实很多面试官对我做的开源项目比较感兴趣，所以面试上其实很多时间都在交流这个开源项目。同时，我也收到过猎头通过 <strong>Github</strong> 上的邮箱给我发的邮件，期望我去参加他们推荐的工作 ( 哈哈哈，后面通过交流知道我还没有毕业的事情，就没有后续的安排了，因为他们招的是5年工作经验的..就因为这个原因错过了<strong>阿里P6-P7</strong>的岗位了，简直太亏了啊....，以后要好好努力积攒经验)</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/20201218222526.png\" alt=\"猎头推荐邮件\" /></p>\n<h2>举目远望</h2>\n<p>研究生的生涯，基本上在看论文、做实验、写博客中度过...，2020年因为疫情的原因，整个寒假都是在家里度过的，直到2020年5月份才开学。在2月份的时候，我就听到有的小伙伴在准备寻找实习了，后面我想了想，正式的秋招大约是在8月份左右，有些公司如果有提前批的话，可能从6月底就开始了(今年字节跳动6月底就开始提前批)。所以从2月到7月，有5个月的时间进行学习，在加上疫情原因，无法正常返校，所以就刚刚好可以开始为面试而学习的阶段。</p>\n<p>首先明确自己需要找哪方面的工作，因为我平时都是学习Java相关的，所以以后打算找后端开发，因此我的投递的岗位基本上都是顶着后台岗位的要求来的，加上我之前编程技术也算可以，所以就没有从头开始学习Java，而是主要关注于java进阶方面的内容。</p>\n<p>因为我都是偏向于从视频中获取知识，虽然有的时候比较慢，但是这个可能会帮助我更快的理解其中的内容，因此，后面的一些推荐，基本上是以视频为主，如果基础较好的，可以直接2倍速刷视频，等待视频学完，时间还充裕的话，可以结合书本进行</p>\n<h3>JUC</h3>\n<p><strong>JUC</strong> 进阶 <strong>Java</strong> 相关的基础内容，因为我之前一直都做 <strong>Java</strong> 开发这块，所以对于 <strong>JavaSE</strong> 方面的还是比较熟悉，首先学习的就是Java并发包，以及一些大厂常见的面试题。</p>\n<blockquote>\n<p>来源Bilibili尚硅谷周阳老师学习视频：<a href=\"https://www.bilibili.com/video/BV15J4112785\">https://www.bilibili.com/video/BV15J4112785</a></p>\n<p>主要包括Volatile、CAS、JAVA锁、阻塞队列、线程池 等...</p>\n<p>笔记地址：<a href=\"https://gitee.com/moxi159753/LearningNotes\">https://gitee.com/moxi159753/LearningNotes</a></p>\n</blockquote>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216224004405.png\" alt=\"大厂面试第二季学习笔记\" /></p>\n<h3>JVM</h3>\n<p>在学习完并发包后，接着就是JVM相关的知识了，这是面试的高频点</p>\n<blockquote>\n<p>来源Bilibili尚硅谷宋红康老师JVM教程：<a href=\"https://www.bilibili.com/video/BV1PJ411n7xZ\">https://www.bilibili.com/video/BV1PJ411n7xZ</a></p>\n<p>主要包括：JVM每个组成部分的作用，垃圾回收算法 和 垃圾回收器</p>\n<p>笔记地址：<a href=\"https://gitee.com/moxi159753/LearningNotes/tree/master/JVM\">https://gitee.com/moxi159753/LearningNotes/tree/master/JVM</a></p>\n</blockquote>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216224344666.png\" alt=\"JVM学习笔记\" /></p>\n<h3>Java8新特性</h3>\n<p>有些可能会问你关于 <strong>Java8</strong> 的新特性，为啥是 <strong>Java8</strong> 呢？因为从 <strong>Java8</strong> 以后的版本就是收费版本了，因此基本上企业的最新版都是基于 <strong>Java8</strong> 来的。</p>\n<blockquote>\n<p>来源Bilibili尚硅谷李贺飞老师学习视频：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1ut411g7E9\">https://www.bilibili.com/video/BV1ut411g7E9</a></p>\n<p>主要包括：HashMap变化、Lambda表达式、Stream流 等</p>\n<p>笔记地址：</p>\n<p><a href=\"https://gitee.com/moxi159753/LearningNotes\">https://gitee.com/moxi159753/LearningNotes</a></p>\n</blockquote>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216224841300.png\" alt=\"Java8新特性\" /></p>\n<h3>SpringCloud</h3>\n<p>在复习完 <strong>Java</strong> 进阶的知识后，下面就需要进入到框架的复习了，因为我使用的是微服务框架 <strong>SpringCloud</strong>来开发的蘑菇博客，所以在面试的时候，肯定会问到微服务框架相关的知识，而且不可能只是停留在简单的使用，更多的是需要了解其原理。因此，我又系统性的学习了一下<strong>SpringCloud</strong>，以及最新版的<strong>SpringCloudAlibaba</strong>(以后蘑菇博客就是基于Alibaba版本做迁移的)</p>\n<blockquote>\n<p>来源Bilibili尚硅谷周阳老师学习视频：</p>\n<p><a href=\"https://www.bilibili.com/video/BV18E411x7eT\">https://www.bilibili.com/video/BV18E411x7eT</a></p>\n<p>主要包括：SpringCloud全家桶组件，服务发现和注册、负载均衡、服务降级和限流、服务网关和配置中心</p>\n<p>笔记地址：</p>\n<p><a href=\"https://gitee.com/moxi159753/LearningNotes/tree/master/SpringCloud/SpringCloud2020\">https://gitee.com/moxi159753/LearningNotes/tree/master/SpringCloud/SpringCloud2020</a></p>\n</blockquote>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216225206883.png\" alt=\"SpringCloud学习笔记\" /></p>\n<p>其实这部分也可以选择性的看，因为我个人是打算从中学习到编码的知识，而不是说知识背面试题。这篇教程其实我觉得是非常不错的，它基本上把概念 和 代码 都讲的很清楚，学习完成后，基本上能够对SpringCloud相关的问题都能回答出来~。</p>\n<h3>中间件</h3>\n<p>中间件的学习，主要就包括 <strong>MQ</strong>(消息队列)、<strong>Redis、MySQL</strong> 等，这个如果只想使用的话，其实挺简单的，调用一下对应的<strong>API</strong>就行，但是这里面的原理其实很多。这里我是跟着视频进行学习，授课老师通过讲解实际案例，非常的通俗易懂。</p>\n<blockquote>\n<p>来源Bilibili学习视频：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1UJ411X7M1\">https://www.bilibili.com/video/BV1UJ411X7M1</a></p>\n<p>面试扫盲，基本上关于中间件以及在服务开发中遇到的疑难问题都有讲解到(学习到了很多知识)</p>\n</blockquote>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201216230006976.png\" alt=\"面试突学习笔记\" /></p>\n<h3>算法学习</h3>\n<p>关于算法这块，其实那在秋招的时候就是准备不太充足，所以在最后就吃亏了，因为现在的面试，基本上都会重点考察你的算法功底，像字节跳动的面试，每一面基本上都会考察。其它的包括 腾讯、阿里都是有的，所以如果你打算冲击大厂，一定要好好的准备算法的知识</p>\n<p>首先我推荐的就是剑指<strong>Offer</strong>，里面都是一些经典的题型大概67题(如果小伙伴时间紧迫，那就先把这个刷完。我当初就是因为轻视了算法，所以导致有些题不能很快给出面试官满意的答案..，需要后面的小伙伴不要和我一样犯同样的错误)</p>\n<blockquote>\n<p>Bilibili视频学习解题思路(Python版本)：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1K4411o7KP\">https://www.bilibili.com/video/BV1K4411o7KP</a></p>\n<p>牛客网剑指offer专题：</p>\n<p><a href=\"https://www.nowcoder.com/ta/coding-interviews\">https://www.nowcoder.com/ta/coding-interviews</a></p>\n</blockquote>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201217102342632.png\" alt=\"剑指Offer学习笔记\" /></p>\n<p>同时，如果剑指Offer的算法题刷完的话，那就可以继续去 <strong>LeetCode</strong> 上刷题了。<strong>LeetCode</strong> 上刷题的话，也是要有针对性，比如，你可以优先选择热门的题目</p>\n<blockquote>\n<p>leetcode: <a href=\"https://leetcode-cn.com/problemset/all\">https://leetcode-cn.com/problemset/all</a></p>\n</blockquote>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201217104934378.png\" alt=\"LeetCode热门题目\" /></p>\n<p>如果时间允许的话，当然可以采用题海战术，把<strong>Leetcode</strong>的中等题目都进行扫盲式的学习。</p>\n<p>如果时间不允许的话，那就需要站在别人的肩膀上学习了，比如可以合理的使用 牛客网搜索，根据前面人面试总结出的高频题，来进行突击性的训练(临时抱佛脚...)</p>\n<blockquote>\n<p>以字节跳动为例：搜索  字节跳动  高频</p>\n</blockquote>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201217105228691.png\" alt=\"高频题搜索\" /></p>\n<p>看到会有人总结出来，其它小伙伴在面试时候遇到的原题，而且这些题目会反复的出现，大家如果就打算冲某些大厂的话，就需要把他们都了解一遍</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201217105314626.png\" alt=\"收集的高频题\" /></p>\n<p>通过别人汇总的，就发现了有几题在我之前面试的时候就出现过.....(不过我面试的早，成功当了炮灰，如果是后面面试的小伙伴，一定要站在前人的肩膀上进行学习）</p>\n<h3>计算机基础课程</h3>\n<p>前面讲的都是关于Java方面的，但是并不是说计算机基础(数据结构、操作系统、计算机网络、数据库)，就可以放下警惕了，其实他们同样也是高频的考点，非常的重要。</p>\n<p>当然如果你有比较丰富的项目经验的话，有些面试可能就会比较弱化计算机基础知识，更多的挖掘你简历中使用的技术(字节跳动的面试很多面试问题就是结合我简历上写的项目来展开的)，不过最后也会问到一些基础的知识，看看你的掌握情况</p>\n<p>比如计算机网络：<strong>HTTPS</strong> 和 <strong>HTTP、TCP</strong>和 <strong>UDP</strong> 相关知识点，同时随着面试的内卷化，难度也会不断加深，关于三次握手和四次挥手，要求你能描述每次状态码的变化，可能还会问 为什么<strong>TCP</strong>连接是三次握手，而不是两次；为什么是四次挥手而不是三次.. 等等一系列的连环套路。</p>\n<p>计算机网络，主要就是跟着Bilibili韩立刚老师的视频教程来学习的 ，还有就是 谢希仁老师的计算机网络</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201217111258064.png\" alt=\"谢希仁 计算机网络\" /></p>\n<blockquote>\n<p>Bilibili韩立刚老师的视频教程：<a href=\"https://www.bilibili.com/video/BV1WK4y1f71A\">https://www.bilibili.com/video/BV1WK4y1f71A</a></p>\n</blockquote>\n<p>关于操作系统，我之前都是根据博客来进行学习的，比如看一些：线程和进程的区别，以及如何通信，然后死锁相关、银行家算法、虚拟内存、磁盘调度等..</p>\n<p>如果时间充裕，还是推荐进行系统的学习一下，小伙伴推荐的操作系统课程，B站第一中文操作系统当之无愧~</p>\n<blockquote>\n<p>操作系统(哈工大李治军老师) ：<a href=\"https://www.bilibili.com/video/BV1d4411v7u7\">https://www.bilibili.com/video/BV1d4411v7u7</a></p>\n</blockquote>\n<p>问到数据库的话，可能会叫你写SQL语句，或者讲述一下MySQL的索引，然后就能讲到B树 、B+树、聚簇索引和非聚簇索引、MySQL索引优化，分析某条SQL语句走了那些索引(explain)、MySQL行锁 和 表锁 等..</p>\n<p>如果是项目做的比较多的话，可能还会问你数据库的分库分表操作，或者MySQL的主从复制。</p>\n<p>同时关于数据库，可能还会问到你缓存相关，比如<strong>Redis</strong>。从<strong>Redis</strong>就能延伸出很多知识点了，<strong>Redis</strong>底层数据结构、跳跃表的实现、<strong>Redis</strong>的持久化策略<strong>AOF和RDB</strong>、<strong>Redis</strong>的缓存穿透、缓存雪崩、<strong>Redis</strong>的主从复制原理 和 <strong>Redis</strong>的哨兵原理，同时像<strong>Redis</strong>的一致性<strong>Hash</strong>问题都有可能问到。</p>\n<p>可能还会结合项目来问，比如问你项目中，高并发环境下，先操作数据库还是先删除缓存？或者在Redis主备切换时的数据丢失问题，异步复制 和 集群脑裂等等。</p>\n<p>上次字节跳动的时候，就从<strong>Redis</strong> 问到了过期策略，最后叫我讲解一下LRU算法，并要求我能手动实现...</p>\n<blockquote>\n<p>尚硅谷MySQL数据库高级：<a href=\"https://www.bilibili.com/video/BV1KW411u7vy\">https://www.bilibili.com/video/BV1KW411u7vy</a></p>\n<p>尚硅谷超经典Redis教程：<a href=\"https://www.bilibili.com/video/BV1oW411u75R\">https://www.bilibili.com/video/BV1oW411u75R</a></p>\n</blockquote>\n<p><strong>Linux</strong> 也会经常在面试中提到，同时在项目部署也会用到，比如 蘑菇博客 其实就是部署在 <strong>CentOS</strong> 下的。因此，在面试的时候，也会根据你的简历情况，而采取不同的面试方式。例如，我简历上写着：熟悉 <strong>Linux</strong> 、<strong>Docker</strong>，能使用 <strong>XShell</strong> ，<strong>Xftp</strong> 等工具进行线上项目部署和调试。那么面试的时候，面试官可能就会比较侧重于实践方面的，比如</p>\n<blockquote>\n<p>生产环境服务器变慢，知道如何排查么？</p>\n</blockquote>\n<p>关于Linux在面试这块，一般问到 <strong>Linux</strong> 下的一些指令，例如：如何查看日志，查看端口，查看系统负载情况，个人的话，如果想要系统的学习Linux，推荐阅读：鸟哥的Linux私房菜，这本书我是购买过的。</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201217201712684.png\" alt=\"鸟哥的Linux私房菜\" /></p>\n<blockquote>\n<p>鸟哥的Linux私房菜(在线)：<a href=\"http://cn.linux.vbird.org/\">http://cn.linux.vbird.org/</a></p>\n</blockquote>\n<h2>收获果实</h2>\n<p>我整个秋招其实只面试了三家公司：字节跳动、京东、滴滴出行</p>\n<ul>\n<li>字节跳动：三天走完面试流程，最后拿了Offer</li>\n<li>京东：两轮技术面通过，HR面挂 (这个挂的莫名其妙，感觉被KPI了..)</li>\n<li>滴滴出行：一天完成三轮技术面试，最后拿到意向书。</li>\n</ul>\n<p>从<strong>2020</strong>年<strong>2</strong>月份开始为秋招而准备，到我们学校开学后，大概在<strong>6</strong>月<strong>20</strong>号左右，就开始准备投递简历了(在这里我特别建议小伙伴们把握好提前批，因为有些公司的提前批是直接免笔试的)。</p>\n<p>字节跳动是我面试的第一家公司。当初面试字节很大的原因还是我的本科小伙伴找他同学帮我内推的，在这里特别感谢尧尧和大壮。因为字节跳动的提前批开启的比较早，本来抱着试一试的态度，没想到竟然一下就拿了Offer。</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201217202713272.png\" alt=\"小伙伴帮我咨询内推情况\" /></p>\n<p>在等待一段时间后，收到了字节跳动 <strong>Data</strong> 广告部门面试的通知。</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201217202956693.png\" alt=\"面试邀约\" /></p>\n<p>不得不说，字节跳动的效率还是非常的快，很快就完成了流程：6月28日：第一面 + 第二面；6月30日：第三面 + HR面；7月7日：意向书。</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/1/image-20201217203603811.png\" alt=\"面试通过发放意向书\" /></p>\n<p>下面是我的一些面试总结，发布在我的蘑菇博客上，感兴趣的小伙伴可以去看看</p>\n<blockquote>\n<p>字节跳动后端面经：<a href=\"http://www.moguit.cn/#/info?blogOid=184\">http://www.moguit.cn/#/info?blogOid=184</a></p>\n<p>京东零售后端面经：<a href=\"http://www.moguit.cn/#/info?blogOid=26\">http://www.moguit.cn/#/info?blogOid=26</a></p>\n<p>滴滴出行后端面经：<a href=\"http://www.moguit.cn/#/info?blogOid=143\">http://www.moguit.cn/#/info?blogOid=143</a></p>\n</blockquote>\n<p>其实在拿到字节跳动的<strong>Offer</strong>后，就准备躺平了，因为字节也是之前一直心心念念的公司，这也算了却了一桩心愿。不过，如果如果小伙伴想冲击更高的薪资的话，那么我建议你可以多面几家，因为这样在面对公司给予的薪资，才有可以商量的余地。</p>\n<h2>结语</h2>\n<p>其实，最后我觉得我能够通过字节跳动和滴滴出行的面试，其实很大程度上也得益于我做的开源博客系统</p>\n<blockquote>\n<p>Talk is cheap. Show me the code</p>\n</blockquote>\n<p>在我和面试官之间，还不是和了解的时候，那么像 <strong>Github</strong> 或者 <strong>Gitee</strong> 的主页就很有说服力；例如，在面试字节的一面的时候，一面的面试官全程就在和我聊项目，同时后面的面试也在深挖项目细节。</p>\n<p>我在面试滴滴出行的时候，面试官直接打开我的笔记仓库，然后从里面选出几篇博客，来和我一起探讨，最后面试完后，滴滴面试官觉得这是一件非常有意义的事情，希望我能够坚持下去。</p>\n<p>所以我觉得，如果你和我一样，本科出生不好，研究生也读了一个双非的学校。那么我们就更需要趁早准备，学历不行，那么就靠能力吃饭。好在就互联网公司而言，其实不是特别看重学历，只要你拥有本科学历，然后拥有比较强的能力的话，都可以吃上互联网这碗饭。</p>\n<p>但是既然选择了从事IT开发 ，那么我们就需要时刻有危机意识。也就是在要求我们需要终生学习，不断的去学习和挑战新的难题。就拿<strong>Java</strong>开发来说，你可能学习了<strong>SpringBoot+MySQL</strong>就可以开发了，但是我们不能仅仅满足于此，我们还需要去尝试着去了解微服务相关的知识。</p>\n<p>在我们业务只用<strong>MySQL</strong>的时候，我们可以去学习<strong>Redis、Memcached</strong>相关的知识，只有这样我们才能不断保持自己的核心竞争力，让自己立于不败之地，只有这样我们才能够去冲击高薪，而不是等到 <strong>35</strong> 岁就被优化。我们要知道，<strong>五年工作经验不等于 一年工作经验用五年</strong>，而是在这五年的时光里，不断的去学习新的知识，去解决各种问题，最后积累出来的经验。</p>\n<p>最后，如果你和我一样出身不好，家里也没有矿，并且决心从事软件开发，那么我希望你能够和我一起，投入时间，投入精力去学习，现在多流汗，回头多拿钱！</p>\n<h2>参考</h2>\n<p><strong>开源蘑菇博客</strong>：</p>\n<p><a href=\"https://gitee.com/moxi159753/mogu_blog_v2\">https://gitee.com/moxi159753/mogu_blog_v2</a></p>\n<p><strong>开源学习笔记</strong>：</p>\n<p><a href=\"https://gitee.com/moxi159753/LearningNotes\">https://gitee.com/moxi159753/LearningNotes</a></p>\n<p><strong>bilibili黑马学习视频</strong>：</p>\n<p><a href=\"https://space.bilibili.com/441640380\">https://space.bilibili.com/441640380</a></p>\n<p><strong>bilibili尚硅谷学习视频</strong>：</p>\n<p><a href=\"https://space.bilibili.com/302417610\">https://space.bilibili.com/302417610</a></p>\n<p><strong>bilibili尚硅谷SpringBoot视频</strong>：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1Et411Y7tQ\">https://www.bilibili.com/video/BV1Et411Y7tQ</a></p>\n<p><strong>Vue文档</strong>：</p>\n<p><a href=\"https://cn.vuejs.org\">https://cn.vuejs.org</a></p>\n<p><strong>ElementUI文档</strong>：</p>\n<p><a href=\"https://element.eleme.cn\">https://element.eleme.cn</a></p>\n<p><strong>尚硅谷周阳大厂面试第二季</strong>：</p>\n<p><a href=\"https://www.bilibili.com/video/BV15J4112785\">https://www.bilibili.com/video/BV15J4112785</a></p>\n<p><strong>尚硅谷宋红康老师JVM教程</strong>：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1PJ411n7xZ\">https://www.bilibili.com/video/BV1PJ411n7xZ</a></p>\n<p><strong>尚硅谷周阳SpringCloud2020</strong>：</p>\n<p><a href=\"https://www.bilibili.com/video/BV18E411x7eT\">https://www.bilibili.com/video/BV18E411x7eT</a></p>\n<p><strong>Java面试突击</strong>：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1UJ411X7M1\">https://www.bilibili.com/video/BV1UJ411X7M1</a></p>\n<p><strong>剑指Offer学习视频</strong>：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1K4411o7KP\">https://www.bilibili.com/video/BV1K4411o7KP</a></p>\n<p><strong>韩立刚老师的计算机网络</strong>：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1WK4y1f71A\">https://www.bilibili.com/video/BV1WK4y1f71A</a></p>\n<p><strong>哈工大李治老师操作系统</strong>：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1d4411v7u7\">https://www.bilibili.com/video/BV1d4411v7u7</a></p>\n<p><strong>尚硅谷MySQL数据库高级</strong>：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1KW411u7vy\">https://www.bilibili.com/video/BV1KW411u7vy</a></p>\n<p><strong>尚硅谷超经典Redis教程</strong>：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1oW411u75R\">https://www.bilibili.com/video/BV1oW411u75R</a></p>\n<p><strong>鸟哥的Linux私房菜(在线)</strong>：</p>\n<p><a href=\"http://cn.linux.vbird.org/\">http://cn.linux.vbird.org/</a></p>\n<p>陌溪是一个从三本院校一路摸滚翻爬上来的互联网大厂程序员。独立做过几个开源项目，其中<strong>蘑菇博客</strong>在码云上有 <strong>2K Star</strong> 了。目前就职于字节跳动的Data广告部门，是字节跳动全线产品的商业变现研发团队。同时本公众号将会持续性的输出很多原创小知识以及学习资源。欢迎各位小伙伴关注陌溪，让我们一起成长~</p>\n<p><img src=\"https://gitee.com/moxi159753/wx_picture/raw/master/picture/长按关注二维码.jpg\" alt=\"和陌溪一起学编程\" /></p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 0, 0, 'd134bdfe255b9aa8c2ce44da8297f6a6', 1, '2020-12-26 16:22:11', '2020-12-26 16:22:11', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '0', 0, 1, 0, NULL, 34, NULL, 0);
INSERT INTO `t_blog` VALUES ('80842d10c24545da75227b7942bff73c', '今天的天气非常非常不错哦今天的天气非常非常不错哦', '今天的天气非常非常不错哦今天的天气非常非常不错哦', '<p>啦啦啦啦</p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 0, 0, '1e9b54926b2a9d9c23e90ff8bf5abc21', 0, '2021-04-12 10:13:35', '2021-04-12 10:55:53', NULL, '1', 'mogu2018', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '0', 0, 1, 0, NULL, 55, 'b486735e7b914e366840d01f049306e4', 0);
INSERT INTO `t_blog` VALUES ('80d3eae77c16cea10e119b9f1a1da4c8', '蘑菇博客QQ小程序发布指南', '蘑菇博客QQ小程序发布指南', '<h1>蘑菇博客QQ小程序发布指南</h1>\n\n<h2>前言</h2>\n\n<p>这阵子使用 <a href=\"https://uniapp.dcloud.io/\">uniapp</a> 和 <a href=\"https://github.com/weilanwl/ColorUI\">ColorUI</a> 搭建了蘑菇博客的移动端应用，uniapp是使用vue.js开发的前端应用框架，可以做到开发一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉/淘宝）、快应用等多个平台，下面演示一下uniapp打包成QQ小程序后的效果图。</p>\n\n<p><img alt=\"uniapp\" src=\"http://image.moguit.cn/86b526dc728645a6a8823a0041308d70\" /></p>\n\n<h2>下载HbuildX</h2>\n\n<p>我们首先下载uniapp推荐的编辑器 <a href=\"https://www.dcloud.io/hbuilderx.html\">HbuildX</a></p>\n\n<h2>导入项目</h2>\n\n<p>下载完成后，我们将uniapp_mogu_web项目导入到我们的HbuildX编辑器中，然后点击上方的发布按钮</p>\n\n<p><img alt=\"image-20200814161009006\" src=\"http://image.moguit.cn/7fe82b54e5034fc08621efe460532727\" /></p>\n\n<p>然后选择 chrome，等待一段时间后，就会弹出页面</p>\n\n<blockquote>\n<p>tip：需要注意，我们启动uniapp项目的时候，必须确保我们的后台服务已经成功启动了</p>\n\n<p>同时我们还需要打开 index/ index页面</p>\n</blockquote>\n\n<p>运行成功后的页面如下所示</p>\n\n<p><img alt=\"image-20200814161424623\" src=\"http://image.moguit.cn/269c0a228dd0490595fa22d375c9fae9\" /></p>\n\n<p>这个时候，我们就需要打开F12的页面，然后点击手机端，这个时候就能够看到项目已经成功运行了</p>\n\n<p><img alt=\"image-20200814161914608\" src=\"http://image.moguit.cn/5688c92f57dc42aaa34807913160b0d0\" /></p>\n\n<h2>QQ小程序</h2>\n\n<p>uniapp可以打包成QQ小程序、微信小程序、APP等，但是因为微信小程序需要交费 300元，本着省钱的原则，决定就发布成QQ小程序，因为小程序支持个人发布</p>\n\n<h3>下载QQ小程序开发者工具</h3>\n\n<p>因为uniapp需要转换成QQ小程序的代码，因此我们首先需要下载 <a href=\"https://q.qq.com/wiki/tools/devtool/\">QQ小程序开发工具</a></p>\n\n<p><img alt=\"image-20200814164442612\" src=\"http://image.moguit.cn/7ffee65b92ed4712b5c4a2ac8e469f3c\" /></p>\n\n<h3>修改配置</h3>\n\n<p>如果我们发布一个QQ小程序体验版本，这个时候就可以使用 IP+端口的方式，如下我们首先找到config文件，修改里面的配置，改成自己的线上的ip</p>\n\n<pre>\n<code class=\"language-js\">export const appConfig = {\n\n    tokenKey: \'Authorization\',\n\n	// 开发环境\n    // WEB_API: \'http://localhost:8603\',\n	// PICTURE_API: \'http://localhost:8602\',\n\n	// 演示环境\n	WEB_API: \'http://120.78.126.96:8603\',\n	PICTURE_API: \'http://120.78.126.96:8602\',\n\n	// 正式环境\n	// WEB_API: \'https://apiweb.moguit.cn\',\n	// PICTURE_API: \'https://apipicture.moguit.cn\',\n}\n\n</code></pre>\n\n<p>如果你想发布项目的话，那么就需要拥有域名 和 配置对应的https了，关于如何配置，可以参考这篇博客</p>\n\n<p>Linux下通过nginx配置https</p>\n\n<h3>打包</h3>\n\n<p>下载完成后，我们回到HbuildX页面，然后点击 发行 -&gt; 小程序-QQ</p>\n\n<p><img alt=\"image-20200814164605313\" src=\"http://image.moguit.cn/e533d9135bb545fdaa407cfb02d7992b\" /></p>\n\n<p>然后填写小程序名称和小程序AppID</p>\n\n<p><img alt=\"image-20200814164729544\" src=\"http://image.moguit.cn/4104a372ab124f0fa64aaa683f82f06e\" /></p>\n\n<p>关于AppId的获取，我们需要到 <a href=\"https://q.qq.com/\">https://q.qq.com/</a> 页面进行申请，然后完成后，我们找到AppID</p>\n\n<p><img alt=\"image-20200814165006063\" src=\"http://image.moguit.cn/8141d2fc947f456cb0519a2adb3b08f0\" /></p>\n\n<p>复制到对应的AppID到我们的HbuildX中，点击发行</p>\n\n<p><img alt=\"image-20200814165139237\" src=\"http://image.moguit.cn/bc56586c627c4e0f95814ec1dcfd2f06\" /></p>\n\n<p>下面就得到了我们QQ小程序开发工具，然后打开我们的上面路径中的程序</p>\n\n<p><img alt=\"image-20200814165321545\" src=\"http://image.moguit.cn/d90c8c8633a447699dbeec1e78c49cb9\" /></p>\n\n<p>打开程序后，我们选择详情，然后点击不校验域名</p>\n\n<p><img alt=\"image-20200814165614236\" src=\"http://image.moguit.cn/4f3f807786a74795b48bb32fae4aec9a\" /></p>\n\n<p>然后在看左边的项目，就能够成功运行项目了</p>\n\n<p><img alt=\"image-20200814165649487\" src=\"http://image.moguit.cn/b685eed936114d4fb011ad9566279caf\" /></p>\n\n<p>这个时候，我们就需要点击右上角的上传</p>\n\n<p><img alt=\"image-20200814165747527\" src=\"http://image.moguit.cn/c3dbdccdc3bb452181edbf5eba5b97c9\" /></p>\n\n<p>然后在到我们的QQ小程序页面，找到刚刚的QQ小程序页面，选择设为体验版本，扫描即可进行体验</p>\n\n<p><img alt=\"image-20200814165838142\" src=\"http://image.moguit.cn/37a921a5b59b4f278018a5eb3b292680\" /></p>\n\n<h2>发布QQ小程序</h2>\n\n<p>我们点击开发版本上的提交审核按钮，即可发布小程序。但是在发布小程序的时候，我也遇到了好几个坑，首先是第一次发布的时候</p>\n\n<p><img alt=\"image-20200814172123614\" src=\"http://image.moguit.cn/b5ae28a089a447b09798de2d8b17e6c7\" /></p>\n\n<p>也就是因为申请的是个人小程序，因此不支持打赏和评论的功能，所以为了解决这个问题，我们将增加开关语句用来控制小程序的评论和打赏模块的显示，我们到 系统配置 -&gt; 网站配置 -&gt; 评论&amp;打赏</p>\n\n<p><img alt=\"image-20200814172412680\" src=\"http://image.moguit.cn/1ac0e38319474158ada493e53459cd68\" /></p>\n\n<p>然后在看我们的小程序端，这个时候就没有评论和打赏相关功能了</p>\n\n<p><img alt=\"image-20200814172448046\" src=\"http://image.moguit.cn/ba1ddd905d594da0a026a99376416eae\" /></p>\n\n<p>我们对比之前的页面，发现已经将评论和打赏功能给关闭了，达到审核的要求</p>\n\n<p><img alt=\"image-20200814172640019\" src=\"http://image.moguit.cn/220e1b0bb4c0423ea664966ac9e8952b\" /></p>\n\n<p>当我修改完上述的问题后，再次提交代码</p>\n\n<p><img alt=\"image-20200814173026185\" src=\"http://image.moguit.cn/1ba29e06bd6e4b0c82ebbb95591ed574\" /></p>\n\n<p>提示小程序还需要支持QQ授权登录，这个时候我们就需要去申请QQ授权，我们到<a href=\"https://connect.qq.com/\">QQ互联</a></p>\n\n<p>然后创建我们的小程序，在这之前，我们需要进行审核，按照要求完成QQ互联的审核即可</p>\n\n<p><img alt=\"image-20200814173203070\" src=\"http://image.moguit.cn/75803ae22b9840f1aed45a71cd0512fc\" /></p>\n\n<p>然后我们点击查看按钮，点击申请unionid</p>\n\n<p><img alt=\"image-20200814173328196\" src=\"http://image.moguit.cn/dd469c8eb42b40168e7a0f14dbc821fe\" /></p>\n\n<p>完成这一系列的操作后，我们回到QQ小程序页面</p>\n\n<p><img alt=\"image-20200814173521763\" src=\"http://image.moguit.cn/fa6a671efba641f08b6145b76ea87221\" /></p>\n\n<p>最后到我们的nacos页面，http://localhost:8848/nacos/#/login，找到 mogu-web-dev.yaml配置，然后修改 appid 和 secret，也就是上面我们复制的</p>\n\n<pre>\n<code class=\"language-bash\"># uniapp相关配置\nuniapp:\n  qq:\n    appid: XXXXXXXXXXXXXX  # 改成自己的\n    secret: XXXXXXXXXXXXXX  # 改成自己的\n    grant_type: authorization_code\n\n</code></pre>\n\n<p>修改完成后，我们到我们的小程序登录页面，进行QQ一键登录</p>\n\n<p><img alt=\"image-20200814173940059\" src=\"http://image.moguit.cn/1f12640a5b2e4df4ab1a649bb23335f5\" /></p>\n\n<p>如果能够成功登录，代表配置已经正常</p>\n\n<p><img alt=\"image-20200814173917783\" src=\"http://image.moguit.cn/c811f49b0e85435fbe8503ea0b12fe22\" /></p>\n\n<p>这个时候我们就可以重新打包程序了，然后点击发布，最后在提交审核</p>\n', '7e0e93ea6cdb44ae92e58f48e6496ed7', 47, 1, 'c7782d374ed2d4bff8e43164ece9244d', 1, '2020-08-19 06:35:24', '2020-11-07 11:09:44', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 1, 1, 0, NULL, 13, NULL, 0);
INSERT INTO `t_blog` VALUES ('8100dcb585fff77e3fa25eed50e3708e', '使用Docker快速搭建蘑菇博客（Nacos分支）', '使用Docker快速搭建蘑菇博客（Nacos分支）', '<h1>使用Docker快速搭建蘑菇博客（Nacos分支）</h1>\n\n<p>最近几天一直在研究怎么样才能够快速搭建蘑菇博客项目，对了，我的服务器是阿里云购买的云服务器ECS，配置是 1核2G ，学生优惠价，100多一年。。。 嗯，这应该是搭建蘑菇博客的最低配置了，内存少于2G的话，可能会启动不起来，本来2G也是不够用的，我是把所有的微服务和solr都放到一个tomcat中，才勉强跑起来的。 目前为了更加方便大家的部署，我已经修改成jar包的方式进行部署启动了，tomcat仅用于作为solr启动的web容器。</p>\n\n<p>如果你的服务器内存也是2G的话，请务必先配置一下交换内存：<a href=\"http://www.moguit.cn/#/info?blogUid=36ee5efa56314807a9b6f1c1db508871\">CentOS如何增加虚拟内存</a></p>\n\n<p>如果你也拥有对应的域名并且备案了的话，可以给蘑菇博客配置域名的方式访问：<a href=\"http://moguit.cn/#/info?blogUid=06565868c0e86fe8125a9d55430cd266\">蘑菇博客配置域名解析</a></p>\n\n<p>如果你的服务器带宽只有1M，可以使用免费的百度云加速，加快页面渲染速度：<a href=\"http://www.moguit.cn/#/info?blogUid=af053959672343f8a139ec27fd534c6c\">如何使用百度云加速提升网站访问速度</a></p>\n\n<blockquote>\n<p>tip：特别注意，因为镜像中的代码可能不是最新版本，因此推荐在按照本篇博客，安装好docker环境后，需要在参考下面蘑菇博客部署阿里云这篇博客，重新将前后端代码都重新部署一遍，同时也记得把doc中的两个SQL文件也重新导入，确保服务器为最新代码</p>\n</blockquote>\n\n<p>如果你之前安装好了蘑菇博客的docker环境，修改的博客的源码，想要重新发布到自己服务器上：<a href=\"http://moguit.cn/#/info?blogUid=89defe3f4a3f317cba9aa0cdb9ff879e\">蘑菇博客如何部署到阿里云服务器</a></p>\n\n<p>因为配置那些环境比较麻烦，（主要包括Nginx，Solr，Redis，Tomcat，Mysql，RabbitMQ）当然如果小伙伴喜欢自己配置的话，也可以不使用我搭建好的镜像，可以参考下面几篇博客哦，希望你也能够配置成功的~！（想直接通过Docker部署的，可以忽略下面几步..）</p>\n\n<p>1、<a href=\"http://www.moguit.cn/#/info?blogUid=e8d3e38ba35b4765ae128256eb44e341\">CentOS下如何安装Nginx</a></p>\n\n<p>2、<a href=\"http://www.moguit.cn/#/info?blogUid=d0e2c4337d7a4a85b176834c8c674fdf\">CentOS下Rdeis的安装和部署</a></p>\n\n<p>3、<a href=\"http://www.moguit.cn/#/info?blogUid=7c7404c456904be5b7736238f28d2515\">CentOS下Solr的安装和部署</a>（可选）</p>\n\n<p>4、<a href=\"http://www.moguit.cn/#/info?blogUid=d5b6dff48e5d42b1afcbf6ab591bdab1\">CentOS下Mariadb的安装和部署</a></p>\n\n<p>5、<a href=\"http://www.moguit.cn/#/info?blogUid=f346267364024e78844d459be2f6f528\">CentOS7下RabbitMQ的安装步骤</a></p>\n\n<p>6、<a href=\"http://moguit.cn/#/info?blogUid=ee342088a5d0f5b96bcb4582d9b563aa\">CentOS下ElasticSearch的安装和部署</a>（可选）</p>\n\n<p>7、<a href=\"http://moguit.cn/#/info?blogUid=ee342088a5d0f5b96bcb4582d9b563aa\">Elasticsearch介绍和安装</a>（可选）</p>\n\n<p>8、<a href=\"http://moguit.cn/#/info?blogUid=7a7ad19472d53147150eb7fdb0978bb2\">CentOS下安装Nacos</a>（Nacos分支需要）</p>\n\n<p>9、<a href=\"http://moguit.cn/#/info?blogUid=b100fde21ac0b61414dbaa74d2db7192\">CentOS下安装Sentinel</a>（Nacos分支需要）</p>\n\n<p>好了。下面我介绍的是用Docker快速搭建蘑菇博客。话不多说，下面我就直接进入正题。</p>\n\n<h2>注册Docker账号</h2>\n\n<p>首先大家先去DockerHub注册账号，用于拉取Docker镜像和存储镜像</p>\n\n<p>注意：注册DockerHub的目的，是为了能够方便以后大家把自己的镜像上传上去，如果DockerHub无法访问，或者不想上传镜像的话，可以忽略这一步，同时在3步 也忽略 docker login，直接进行Docker pull 拉取我的镜像即可</p>\n\n<p>DockerHub官网：<a href=\"https://hub.docker.com/\">点我传送</a></p>\n\n<p>关于更多docker命令和介绍，可以看这篇博客：<a href=\"http://www.moguit.cn/#/info?blogUid=8974a6ce5bae4bf68f1aa37f07c96d0f\">Docker常用命令</a></p>\n\n<h2>Docker安装和启动</h2>\n\n<p>注册成功后，进入我们的CentOS系统中（如果是Ubuntu的话，可能安装docker的方式不同，请自行百度安装）</p>\n\n<p>下面介绍的是使用yum方式安装docker</p>\n\n<h3>配置docker的阿里云yum源</h3>\n\n<pre>\n<code>cat &gt;&gt;/etc/yum.repos.d/docker.repo&lt;&lt;EOF\n[docker-ce-edge]\nname=Docker CE Edge - \\$basearch\nbaseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/7/\\$basearch/edge\nenabled=1\ngpgcheck=1\ngpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg\nEOF\n</code></pre>\n\n<h3>安装docker</h3>\n\n<pre>\n<code># yum安装\nyum -y install docker-ce\n\n#查看docker版本\ndocker --version  \n\n# 设置开机自启\nsystemctl enable docker\n\n# 启动docker\nsystemctl start docker\n</code></pre>\n\n<p>启动完成后，因为需要到Dockerhub拉取镜像，而DockerHub部署在国外，大家还可以配置一下阿里的Docker国内源，这样可以达到加速的效果~</p>\n\n<h2>Docker login登录</h2>\n\n<p>使用Docker login命令登录，需要输入刚刚注册的账号和密码（ps：如果不想发布镜像到dockerhub，可以忽略）</p>\n\n<pre>\n<code># 登录dockerhub\ndocker login\n</code></pre>\n\n<h2>拉取蘑菇博客的镜像</h2>\n\n<p>Nacos版本使用下面命令：</p>\n\n<pre>\n<code class=\"language-bash\">docker pull moxi/mogu_blog_nacos\n</code></pre>\n\n<p>因为镜像有点大，所以拉取的话，可能会有点慢，所以耐下等待下</p>\n\n<p>如果拉取失败，或者出现超时的情况、或者拉取过慢，可以尝试使用下面的方法： <a href=\"http://www.moguit.cn/#/info?blogUid=5296cfe28b35caa808a5387ff95734c7\">CentOS7中Docker拉取镜像失败的解决方法</a></p>\n\n<p>如果还是拉取速度很慢的话，推荐在早上的时候拉取镜像，因为DockerHub是国外的网站，早上的时候，他们美国这边都已经到了晚间了，基本不占用太多带宽，拉取速度会更快一些~</p>\n\n<h2>查看镜像</h2>\n\n<p>拉取成功后，使用命令查看已经拉取的镜像</p>\n\n<pre>\n<code>docker images\n</code></pre>\n\n<p><img alt=\"image-20200903160432721\" src=\"http://image.moguit.cn/d737b804a63247bc80868df01073771c\" /></p>\n\n<p>好了，能看到刚刚拉取的镜像，大概有3.97G，因为这里面包含了项目完整的运行环境。</p>\n\n<h2>制作蘑菇博客docker容器</h2>\n\n<p>Nacos版本使用下面的命令：</p>\n\n<pre>\n<code class=\"language-bash\">docker run --privileged -d -it -h mogu_blog_2 --name mogu_blog_2 -v /etc/localtime:/etc/localtime:ro -p 11122:22 -p 15672:15672 -p 8600:8600 -p 9527:9527 -p 9528:9528 -p 6379:6379 -p 3306:3306 -p 80:80 -p 8080:8080 -p 8601:8601 -p 8602:8602 -p 8603:8603 -p 8604:8604 -p 8605:8605 -p 8606:8606 -p 8607:8607 -p 5601:5601 -p 9411:9411 -p 465:465 -p 8848:8848 -p 8070:8070 moxi/mogu_blog_nacos /usr/sbin/init\n</code></pre>\n\n<p>使用下面的命令，就能够制作成一个docker容器了，他会将上面写的一些端口号都映射到宿主机中，所以宿主机那些端口号不能别占用了哦。</p>\n\n<p>当然同时，宿主机的那些端口号也必须开放，如果是使用阿里云的小伙伴，必须在 阿里云的官网，配置相应的安全组，不然外面是没办法访问的。</p>\n\n<p>关于安全组的配置，在云服务器ECS的管理页面</p>\n\n<p><img alt=\"image-20200209125847329\" src=\"http://image.moguit.cn/87afbd80f53241bf88643371e5d4fa07\" /></p>\n\n<p>在点击配置规则</p>\n\n<p><img alt=\"image-20200209125905430\" src=\"http://image.moguit.cn/02e85ef9931e4d0cb633a0b93831beac\" /></p>\n\n<p>然后点击右上角按钮，把需要用到的端口号都导入进去</p>\n\n<p><img alt=\"image-20200209125919324\" src=\"http://image.moguit.cn/8d33bf7bcc6548109e931e8f687c6c2f\" /></p>\n\n<p>安装下面的规则，把每一个添加进去即可, 需要添加的端口号有：</p>\n\n<pre>\n<code class=\"language-bash\">蘑菇Docker内部容器SSH连接：11122\nRabbitMQ消息队列：15672\nZipkin链路追踪: 9411\n发Email端口：465   \n图片资源：8600   \n前端Web页面:9527    \n后端Admin页面：9528  \nRedis:6379   \nMysql:3306   \nTomcat(里面部署的solr):8080\nHTTP端口：80\nKibana端口：5601\nmogu_admin端口：8601\nmogu_picture端口：8602\nmogu_web端口：8603\nmogu_sms端口：8604\nmogu_search端口：8605\nmogu_monitor端口：8606\nmogu_gateway端口：8607\nnacos端口: 8848\nsentinel端口: 8070\n</code></pre>\n\n<p><img alt=\"image-20200209125938397\" src=\"http://image.moguit.cn/f9632cf3b2b9452194eaa5c7e0a3c0de\" /></p>\n\n<h2>查看容器状态</h2>\n\n<p>好了，回到刚刚的内容，我们在执行第六步的时候，已经制作好了容器了，使用下面的命令，查看容器状态</p>\n\n<pre>\n<code># 查看容器状态\ndocker ps -a\n</code></pre>\n\n<p><img alt=\"image-20200209125953803\" src=\"http://image.moguit.cn/c9a8a60c6dc94ef8b81db576bb3398c0\" /></p>\n\n<h2>打开XShell，连接</h2>\n\n<p><img alt=\"image-20200209130011043\" src=\"http://image.moguit.cn/f8ee8df900ff44e58529778ffe5f1829\" /></p>\n\n<p>输入用户名： root</p>\n\n<p><img alt=\"image-20200209130023427\" src=\"http://image.moguit.cn/6cde2e182f7640c2a5c2ec086044320e\" /></p>\n\n<p>输入密码：mogu2018</p>\n\n<p><img alt=\"image-20200209130036402\" src=\"http://image.moguit.cn/6693ea998f514121bee50b1e23bed041\" /></p>\n\n<p>成功进入系统，下面我们就需要把对应的服务都开启</p>\n\n<p>注意：该密码是docker镜像的初始密码，如果需要更改的话，可以使用下列命令更改密码</p>\n\n<pre>\n<code>passwd\n</code></pre>\n\n<h2>启动对应的服务</h2>\n\n<h3>启动Nginx</h3>\n\n<pre>\n<code># 进入nginx的安装目录下\ncd /soft/nginx/sbin/\n\n# 启动nginx\n./nginx\n</code></pre>\n\n<p>好吧，启动报错</p>\n\n<p><img alt=\"image-20200209130104979\" src=\"http://image.moguit.cn/0a2713041ad14c63bee0ba26d74f38cd\" /></p>\n\n<p>看问题需要创建一个目录，那么就开始创建吧</p>\n\n<pre>\n<code>mkdir -p /var/run/nginx\n</code></pre>\n\n<p>再次使用启动命令，启动成功</p>\n\n<p><img alt=\"image-20200209130124155\" src=\"http://image.moguit.cn/88fe50aad73449958de74bdf0560e463\" /></p>\n\n<p>我们在使用命令 ，查看已经启动的端口号</p>\n\n<pre>\n<code>netstat -tunlp\n</code></pre>\n\n<p>我们已经看到了，现在已经开机自启了 RabbitMQ的 5672 15672 ， mysql的 3306， 其他的一些就是项目的端口，现在我们还需要启动 redis的 6379 和 tomcat的 8080</p>\n\n<p><img alt=\"image-20200209130139403\" src=\"http://image.moguit.cn/2276f331273c434b90b446f79a3f2d37\" /></p>\n\n<p>注意：如果我们查看端口号没有RabbitMQ，我们需要手动启动对应的服务</p>\n\n<p>新开一个xshell连接，启动rabbitmq：</p>\n\n<pre>\n<code># 后台启动RabbitMQ\nrabbitmq-server -detached\n</code></pre>\n\n<h3>启动redis</h3>\n\n<pre>\n<code># 进入redis的安装目录\ncd /soft/redis/bin/\n\n# 后台启动redis\n./redis-server redis.conf\n\n# 查看启动端口号\nnetstat -tunlp\n</code></pre>\n\n<p>我们看到redis已经正常启动了</p>\n\n<p><img alt=\"image-20200209130156442\" src=\"http://image.moguit.cn/3384caf9ab99427a960c34a0bd726ff1\" /></p>\n\n<h3>启动tomcat中的solr（可选）</h3>\n\n<p>tip：如果配置了Solr作为全文检索，那么需要启动Solr，否则可以忽略这一步（默认使用的是SQL搜索）</p>\n\n<pre>\n<code># 进入tomcat目录\ncd /soft/tomcat/bin\n\n# 启动\n./startup.sh\n\n# 查看启动信息\ntail -f ../logs/catalina.out\n</code></pre>\n\n<h3>启动Nacos</h3>\n\n<p>Nacos是由SpringCloudAlibaba开发的服务注册和配置中心，关于更多的操作可以查看这两篇博客</p>\n\n<ul>\n	<li><a href=\"http://moguit.cn/#/info?blogUid=e6e619349d31dded928c9265c5a9c672\">【SpringCloud】使用Nacos实现服务注册发现以及配置中心等功能</a></li>\n	<li><a href=\"http://moguit.cn/#/info?blogUid=7a7ad19472d53147150eb7fdb0978bb2\">CentOS下安装Nacos</a></li>\n</ul>\n\n<p>下面我们只需要进入Nacos的目录下，然后启动即可</p>\n\n<pre>\n<code class=\"language-bash\"># 进入nacos目录\ncd /soft/nacos/bin\n# 启动Nacos\n./startup.sh -m standalone\n</code></pre>\n\n<p>启动后，会有如下提示</p>\n\n<p><img alt=\"image-20200903161239748\" src=\"http://image.moguit.cn/e35db8d846f94198b9cb53ae71613f91\" /></p>\n\n<p>我们可以通过查看日志进行判断nacos是否启动成功</p>\n\n<p><img alt=\"image-20200903161406977\" src=\"http://image.moguit.cn/da043c4c0f894b778c8211367d92f075\" /></p>\n\n<p>如果没有报错信息，说明Nacos已经启动成功了，下面我们可以进入到Nacos的图形化管理页面</p>\n\n<pre>\n<code class=\"language-bash\">http://your_ip:8848/nacos\n</code></pre>\n\n<p>打开后，输入默认账号密码：nacos nacos，即可进入系统，查看到项目的配置</p>\n\n<p><img alt=\"image-20200903161619843\" src=\"http://image.moguit.cn/6b5028c5baeb43bdbc27f01bfcd302bb\" /></p>\n\n<p>如果需要更改配置，以后到这里完成就可以了，修改配置后，重启服务即可生效</p>\n\n<h3>启动Sentinel（可选）</h3>\n\n<p>Sentinel是用来做服务的熔断、雪崩、限流，相当于原来的Hystrix，但是提供了更加强大的功能，如果想要了解Sentinel的更多操作，可以参考这两篇博客</p>\n\n<ul>\n	<li><a href=\"http://moguit.cn/#/info?blogUid=408e9c889ebf96a66af2adfdc258ba5f\">【SpringCloud】使用Sentinel实现熔断和限流</a></li>\n	<li><a href=\"http://moguit.cn/#/info?blogUid=b100fde21ac0b61414dbaa74d2db7192\">CentOS下安装Sentinel</a></li>\n</ul>\n\n<p>首先进入到Sentinel的启动目录下进行启动</p>\n\n<pre>\n<code class=\"language-bash\"># 进入到sentinel目录\ncd /soft/sentinel\n# 启动Sentinel\n./startup.sh\n# 查看日志\n</code></pre>\n\n<p>然后进入到Sentinel的图形化界面</p>\n\n<pre>\n<code class=\"language-bash\">http://your_ip:8070\n</code></pre>\n\n<p>输入默认账号密码：sentinel sentinel，进入到管理界面，更多关于Sentinel的操作，可以查看<a href=\"http://moguit.cn/#/info?blogUid=408e9c889ebf96a66af2adfdc258ba5f\">这篇博客</a></p>\n\n<p><img alt=\"image-20200903162631281\" src=\"http://image.moguit.cn/1486759c1c194743a0ba47d556e431d8\" /></p>\n\n<h3>启动微服务</h3>\n\n<p>启动 mogu_picture &amp; mogu_sms &amp; mogu_admin &amp; mogu_web</p>\n\n<pre>\n<code>#进入到项目目录\ncd /home/mogu_blog\n</code></pre>\n\n<p>我们查看项目结构，有以下几个文件夹</p>\n\n<p><img alt=\"image-20200903163514966\" src=\"http://image.moguit.cn/6d1ce7fe90ab45068da2995227176da0\" /></p>\n\n<p>下面说明每个文件夹的作用</p>\n\n<pre>\n<code>mogu_admin：admin端API接口服务\nmogu_data：存在蘑菇博客的图片资源\nmogu_monitor：服务监控\nmogu_picture: 图片服务器，用于图片上传和下载\nmogu_sms: 消息发送服务器，用于邮件和短信发送\nmogu_web：web端API接口服务\nmogu_zipkin：链路追踪模块\nvue_mogu_admin：VUE的后台管理页面\nvue_mogu_web：VUE的门户网站\n</code></pre>\n\n<h4>启动Admin后台服务</h4>\n\n<p>首先进入mogu_admin目录下</p>\n\n<p>我们查看一下目录结构</p>\n\n<p><img alt=\"image-20200209130224724\" src=\"http://image.moguit.cn/e3cfe89eb47e44acba9c2a20686b9a30\" /></p>\n\n<pre>\n<code>./startup.sh  #启动脚本\n./shutdown.sh #关闭脚本\nmogu_admin***.jar #springboot打包的可执行jar包\n/config #外部配置文件\ncatalina.out #启动脚本后，生成的日志文件\n</code></pre>\n\n<p>然后我们使用下面的命令进行启动</p>\n\n<pre>\n<code># 进入mogu_admin目录\ncd mogu_admin\n# 启动项目\n./startup.sh\n</code></pre>\n\n<blockquote>\n<p>tip：因为镜像中的代码可能不是最新版本，因此推荐在按照本篇博客，安装好docker环境后，需要在参考下面蘑菇博客部署阿里云这篇博客，重新将前后端代码都重新部署一遍，同时也记得把doc中的三个SQL文件也重新导入，确保服务器为最新代码~</p>\n</blockquote>\n\n<h3>mogu_web修改配置</h3>\n\n<p>我们进入到nacos配置文件管理界面，找到的 mogu_web_prod.yaml文件</p>\n\n<p><img alt=\"image-20200903164514073\" src=\"http://image.moguit.cn/95308e71b99846a5998efc4983fa2a9f\" /></p>\n\n<p>我们需要将下面的域名，改成自己的</p>\n\n<pre>\n<code>data:\n  # 门户页面\n  webSite:\n    url: http://101.132.122.175/:9527/#/\n    # 有域名可以改成如下\n    # url: http://www.moguit.cn/#/\n    \n  # mogu_web网址，用于第三方登录回调\n  web:\n    url: http://101.132.122.175/:8603\n</code></pre>\n\n<p>同时在配置文件的最下面，还需要修改第三方注册需要的 clientId 和 ClientSecret：如果不清楚如何获取的小伙伴，可以查看我的这篇博客，在后面部分对ID的获取有相关介绍：<a href=\"http://moguit.cn/#/info?blogUid=8cbadb54967257f12d6cc7eb1a58a361\">SpringBoot+Vue如何集成第三方登录JustAuth</a></p>\n\n<pre>\n<code class=\"language-yml\"># 第三方登录\njustAuth:\n  clientId:\n    gitee: XXXXXXXXXXXXXXXXXXXXXX\n    github: XXXXXXXXXXXXXXXXXXXXXX\n  clientSecret:\n    gitee: XXXXXXXXXXXXXXXXXXXXXX\n    github: XXXXXXXXXXXXXXXXXXXXXX\n</code></pre>\n\n<p>修改完成后，启动项目</p>\n\n<pre>\n<code class=\"language-bash\"># 进入mogu_web目录\ncd mogu_web\n# 启动项目\n./startup.sh\n</code></pre>\n\n<h3>mogu_sms修改配置</h3>\n\n<p>我们进入到nacos配置文件管理界面，找到的 mogu_sms_prod.yaml文件</p>\n\n<p><img alt=\"image-20200903164316451\" src=\"http://image.moguit.cn/4f8f8ad92d3b47f1b28768f02167a334\" /></p>\n\n<p>在mogu_sms中，主要修改的就是邮箱的配置，我们将发送邮件的信息改成自己的</p>\n\n<pre>\n<code class=\"language-yml\">#mail\nmail:\n    username: XXXXXXX@163.com\n    password: XXXXXXX #授权码开启SMTP服务里设置\n</code></pre>\n\n<p>注意，上面的password是授权码，授权码不是密码，以163邮箱为例，我们需要开启SMTP服务，然后设置授权码</p>\n\n<p><img alt=\"image-20200722090457339\" src=\"http://image.moguit.cn/c1f29c98397442c385cfb151ae5a76fc\" /></p>\n\n<p>修改完成后，我们启动对应的项目即可，最终我们需要启动的项目有： mogu_picture, mogu_sms, mogu_admin, mogu_web</p>\n\n<p><strong>tip:（用于以后使用图形化客户端进行连接）</strong></p>\n\n<p>mysql的账号和密码是 root mogu2018</p>\n\n<p>redis的密码是 mogu2018</p>\n\n<h2>验证是否后台是否启动成功</h2>\n\n<p>等服务器都启动完成后，下面我们验证一下后台是否正常启动，回到我们的Nacos管理界面</p>\n\n<pre>\n<code>http://your_ip:8848/nacos\n</code></pre>\n\n<p>如果我们看到下面四个服务都注册到eureka中，那说明启动成功</p>\n\n<p><img alt=\"image-20200903165638594\" src=\"http://image.moguit.cn/509f9f106f664a728e2ac3522e75892b\" /></p>\n\n<p>我们在通过访问下列swagger接口，测试接口是否正常</p>\n\n<pre>\n<code>http://your_ip:8601/swagger-ui.html\nhttp://your_ip:8603/swagger-ui.html\n</code></pre>\n\n<p>如果能够进入下面页面的话，说明后台是没有问题的了，下面我们可以验证一下接口</p>\n\n<p><img alt=\"image-20200209130313977\" src=\"http://image.moguit.cn/994ecf0c0a9040b6b717be2caa5e508f\" /></p>\n\n<p>验证登录</p>\n\n<p><img alt=\"image-20200209130324333\" src=\"http://image.moguit.cn/c4f2f21cc03849cea6eae28248e6911f\" /></p>\n\n<p>登录功能正常使用，我们把token复制到来，然后在swagger页面的右上角，有一个authorize的按钮，点击后，将token粘贴进去，即可操作全部接口进行测试了~</p>\n\n<p><img alt=\"image-20200209130336478\" src=\"http://image.moguit.cn/ce79f64b7c04464eb7626cc1373fd7f7\" /></p>\n\n<h2>修改前端项目配置</h2>\n\n<p>我们现在需要修改两个地方的配置，分别是：vue_mogu_admin 和 vue_mogu_web\\</p>\n\n<blockquote>\n<p>tip：以下配置的修改，需要在我们本地的编辑器下进行修改，修改完成后在打包发送到服务器,也就是我们下载的源码目录，注意不是在linux服务器下的dist文件夹内！！！</p>\n</blockquote>\n\n<p>下面我们到 vue_mogu_web/config/目录下，修改prod.env.js文件</p>\n\n<p><img alt=\"image-20200903165911938\" src=\"http://image.moguit.cn/6ebf5b1512ea46a79e4faf89bb55a307\" /></p>\n\n<p>把里面的ip地址换成你主机的地址即可</p>\n\n<pre>\n<code>//配置线上环境\nVUE_MOGU_WEB: \'\"http://101.132.122.175:9527\"\',\nPICTURE_API: \'\"http://101.132.122.175:8602\"\',\nWEB_API: \'\"http://101.132.122.175:8603\"\',\nELASTICSEARCH: \'\"http://101.132.122.175:8605\"\',\n</code></pre>\n\n<p>同理，在修改 vue_mogu_admin下的地址，把里面的ip地址，换成你服务器的ip即可</p>\n\n<p><img alt=\"image-20200903165947652\" src=\"http://image.moguit.cn/eab30c98aa20408e8b088d60bf704ade\" /></p>\n\n<p>修改完成后，需要进行重新编译~ 打包~ 部署~</p>\n\n<p>我们首先在 vue_mogu_admin 目录下，执行下列命令进行打包（打包过程中.....可能会遇到一些语法规范错误，请无视~）</p>\n\n<pre>\n<code># 安装依赖\nnpm install --registry=https://registry.npm.taobao.org\n\n# 打包\nnpm run build\n</code></pre>\n\n<p>打包完成后，会生成一个dist目录，我们将整个dist目录，压缩成 zip格式</p>\n\n<p><img alt=\"image-20200209130425874\" src=\"http://image.moguit.cn/7eef98a3bf804b93ac7547ab12300f18\" /></p>\n\n<p>然后使用xftp工具，丢入到我们的前端目录下，目录在 /home/mogu_blog/vue_mogu_admin</p>\n\n<p><img alt=\"image-20200209130438506\" src=\"http://image.moguit.cn/acbcb43c40b8475197a4736f09cb1ece\" /></p>\n\n<p>注意：如果该文件夹下存在 dist文件夹，我们需要将其删除，然后在解压</p>\n\n<p>然后使用下面命令进行解压</p>\n\n<pre>\n<code>unzip dist.zip\n</code></pre>\n\n<p>同理的操作，在执行一下上述操作，将vue_mogu_web项目也进行打包，部署到 /home/mogu_blog/vue_mogu_web目录下即可</p>\n\n<h2>访问蘑菇博客项目</h2>\n\n<h3>访问前端项目</h3>\n\n<p>例如： 192.168.1.101:9527</p>\n\n<p><img alt=\"image-20200209130524162\" src=\"../../杂记/Docker搭建蘑菇博客/images/image-20200209130524162.png\" /></p>\n\n<p>tip：需要注意的是，如果图片无法正常显示，请先登录后台管理页面，然后修改对应的域名</p>\n\n<p>关于具体的配置，参考这篇博客：<a href=\"http://www.moguit.cn/#/info?blogUid=735ed389c4ad1efd321fed9ac58e646b\">蘑菇博客配置七牛云存储</a></p>\n\n<p><img alt=\"image-20200903170244575\" src=\"http://image.moguit.cn/ed45cff257e744eda9a170d1c15ddd56\" /></p>\n\n<h3>访问后端项目</h3>\n\n<p>ip地址:9528 用户名和密码是： admin mogu2018</p>\n\n<p><img alt=\"image-20200209130547785\" src=\"http://image.moguit.cn/a4c7917cd4524c1d9334b7e071db8da0\" /></p>\n\n<h2>总结：</h2>\n\n<p>好了，到目前为止，蘑菇博客已经搭建完成。当然小伙伴并不是拉取来就能直接用的， 如果ip地址不一样的话，是不能直接使用的，后面的话，需要拉取源码后，修改对应的配置信息后，然后在打包部署，才能够使用的。</p>\n', '7e0e93ea6cdb44ae92e58f48e6496ed7,ebf63989f11741bc89494c52fc6bae4c', 6, 0, 'c7782d374ed2d4bff8e43164ece9244d', 0, '2020-09-04 09:56:24', '2020-10-07 16:32:38', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 1, '1', 4, 1, 0, NULL, 14, NULL, 0);
INSERT INTO `t_blog` VALUES ('81641369c197c49ad1155327655653c4', 'Go语言中的变量和常量', 'Go语言中的变量和常量', '<h1>Go语言中的变量和常量</h1>\n\n<h2>Go语言中变量的声明</h2>\n\n<p>Go语言变量是由字母、数字、下划线组成，其中首个字符不能为数字。Go语言中关键字和保留字都不能用作变量名</p>\n\n<p>Go语言中变量需要声明后才能使用，同一作用域内不支持重复声明。并且Go语言的变量声明后必须使用。</p>\n\n<p>变量声明后，没有初始化，打印出来的是空</p>\n\n<h2>如何定义变量</h2>\n\n<h3>方式1：</h3>\n\n<pre>\n<code class=\"language-go\">var name = \"zhangsan\"\n</code></pre>\n\n<h3>方式2：带类型</h3>\n\n<pre>\n<code class=\"language-go\">var name string = \"zhangsan\"\n</code></pre>\n\n<h3>方式3：类型推导方式定义变量</h3>\n\n<p>a在函数内部，可以使用更简略的 := 方式声明并初始化变量</p>\n\n<p>注意：短变量只能用于声明局部变量，不能用于全局变量声明</p>\n\n<pre>\n<code class=\"language-go\">变量名 := 表达式\n</code></pre>\n\n<h3>方式4：声明多个变量</h3>\n\n<p>类型都是一样的变量</p>\n\n<pre>\n<code class=\"language-go\">var 变量名称， 变量名称 类型\n</code></pre>\n\n<p>类型不一样的变量</p>\n\n<pre>\n<code class=\"language-go\">var (\n	变量名称 类型\n    变量名称 类型\n)\n</code></pre>\n\n<p>案例</p>\n\n<pre>\n<code class=\"language-go\">var a1, a2 string\na1 = \"123\"\na2 = \"123\"\nfmt.Printf(a1)\nfmt.Printf(a2)\n</code></pre>\n\n<h3>总结</h3>\n\n<p>全部的定义方式</p>\n\n<pre>\n<code class=\"language-go\">package main\nimport \"fmt\"\n\nfunc main() {\n	fmt.Println(\"hello\")\n	fmt.Print(\"A\", \"B\", \"C\")\n	fmt.Println()\n	var a = 10\n	fmt.Printf( \"%d\", a )\n\n	var name = \"zhangsan1\"\n	var name2 string = \"zhangsan2\"\n	name3 := \"zhangsan3\"\n\n	fmt.Println(name)\n	fmt.Println(name2)\n	fmt.Println(name3)\n	fmt.Printf(\"name1=%v name2=%v name3=%v \\n\", name, name2, name3)\n}\n</code></pre>\n\n<h2>如何定义常量</h2>\n\n<p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。常量的声明和变量声明非常类似，只是把var换成了const，常量在定义的时候必须赋值。</p>\n\n<pre>\n<code class=\"language-go\">// 定义了常量，可以不用立即使用\nconst pi = 3.14\n\n// 定义两个常量\nconst(\n    A = \"A\"\n    B = \"B\"\n)\n\n// const同时声明多个常量时，如果省略了值表示和上面一行的值相同\nconst(\n    A = \"A\"\n    B\n    C\n)\n</code></pre>\n\n<h2>Const常量结合iota的使用</h2>\n\n<p>iota是golang 语言的常量计数器，只能在常量的表达式中使用</p>\n\n<p>iota在const关键字出现时将被重置为0（const内部的第一行之前），const中每新增一行常量声明将使iota计数一次（iota可理解为const语句块中的行索引）。</p>\n\n<p>每次const出现，都会让iota初始化为0【自增长】</p>\n\n<pre>\n<code class=\"language-go\">const a = iota // a = 0\nconst (\n	b = iota // b=0\n    c        // c = 1\n    d        // d = 2\n)\n</code></pre>\n\n<p>const iota使用_跳过某些值</p>\n\n<pre>\n<code class=\"language-go\">const (\n	b = iota // b=0\n    _\n    d        // d = 2\n)\n</code></pre>\n', '7e0e93ea6cdb44ae92e58f48e6496ed7', 2, 0, 'ee5fd755a6f28df835361c005d0b867b', 0, '2020-09-08 09:54:01', '2020-09-14 10:35:25', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 15, NULL, 0);
INSERT INTO `t_blog` VALUES ('8dc52bd61e36fa56cfc7699815375572', '蘑菇博客Nacos部署指南', '蘑菇博客Nacos部署指南', '<h1 id=\"蘑菇博客Nacos部署指南\">蘑菇博客Nacos部署指南</h1>\n<h2 id=\"前言\">前言</h2>\n<p>蘑菇博客这阵子将部分SpringCloud组件替换成了SpringCloudAlibaba组件，其中包括注册中心由Eureka替换成Nacos、新增了Sentinel作为熔断和限流组件</p>\n<p>关于Nacos和Sentinel的使用可以参考下面两篇博客</p>\n<ul>\n<li><a href=\"http://moguit.cn/#/info?blogUid=e6e619349d31dded928c9265c5a9c672\">【SpringCloud】使用Nacos实现服务注册发现以及配置中心等功能</a></li>\n<li><a href=\"http://moguit.cn/#/info?blogUid=408e9c889ebf96a66af2adfdc258ba5f\">【SpringCloud】使用Sentinel实现熔断和限流</a></li>\n</ul>\n<h2 id=\"安装Nacos\">安装Nacos</h2>\n<p>首先我们到Nacos的 <a href=\"https://github.com/alibaba/nacos/releases\">Github页面</a>，找到我们需要安装的版本</p>\n<p><img src=\"http://image.moguit.cn/df299cd97ca04c51a9d6ad46259223aa\" alt=\"image-20200814144224359\" /></p>\n<p>因为我现在用的是window，所以我下载了windows版本，也就是 nacos-server.zip</p>\n<blockquote>\n<p>如果国内环境下载过慢，可以使用下面的这个地址 链接：<a href=\"https://pan.baidu.com/s/1oTYQuqz1oMM5kTE\">https://pan.baidu.com/s/1oTYQuqz1oMM5kTE</a>_tl-8JQ 提取码：92gx</p>\n</blockquote>\n<p>下载完成后，我们进行解压缩，然后进入 conf目录，打开 application.properties文件</p>\n<p><img src=\"http://image.moguit.cn/053d912d9fd84c1e90221828b26a5fda\" alt=\"image-20200814144515174\" /></p>\n<p>打开后，我们在文件的末尾添加mysql的配置信息，注意mysql的账号和密码</p>\n<pre><code class=\"language-bash\"># mysql配置\nspring.datasource.platform=mysql\ndb.num=1\ndb.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC\ndb.user=root\ndb.password=root\n\n</code></pre>\n<p>配置完成后，我们到项目的doc文件夹，找到数据库脚本 nacos_config.sql</p>\n<p><img src=\"http://image.moguit.cn/c48ad210858d412c9254e616961cbebd\" alt=\"image-20200814150620395\" /></p>\n<p>然后创建一个数据库脚 nacos_config，将配置导入到mysql中，然后我们到nacos目录，双击startup.bat启动</p>\n<p><img src=\"http://image.moguit.cn/cee3dcdc2c8b40f992aac959c729cd1e\" alt=\"image-20200814150743682\" /></p>\n<p><img src=\"http://image.moguit.cn/56fec6e3a74842b39c90c2e8ad34be0b\" alt=\"image-20200814150938013\" /></p>\n<p>项目启动成功后，我们访问 http://localhost:8848/nacos，输入下方的默认密码</p>\n<blockquote>\n<p>账号：nacos</p>\n<p>密码：nacos</p>\n</blockquote>\n<p><img src=\"http://image.moguit.cn/c14a178fa20343899e678d6d7dc6239c\" alt=\"image-20200814151027589\" /></p>\n<p>然后我们点击 配置列表 -&gt; dev，即可查看到我们的配置文件了，如果我们需要修改配置的话，只需要点击编辑</p>\n<p><img src=\"http://image.moguit.cn/0eb5be4bee844b49bd498cd90e80e4f9\" alt=\"image-20200814151141045\" /></p>\n<p>到这里为止，Nacos服务注册中心就已经安装完成了，后续的操作我们可以参考下面的博客进行</p>\n<p><a href=\"http://moguit.cn/#/info?blogUid=082ca226cf2e4103b0ffa6e6c13d7b14\">window环境下配置蘑菇博客环境</a></p>\n<blockquote>\n<p>因为我们将Eureka替换成Nacos，所以我们只需要启动服务为</p>\n<p>mogu-sms、mogu-picture、mogu-admin、mogu-web</p>\n</blockquote>\n<p><img src=\"http://image.moguit.cn/e36915b0af384a4da5cb471ba1e301de\" alt=\"image-20200814154136820\" /></p>\n', 'e81bc2dca42c4031be7d66fef4a71e16', 28, 0, 'ffe1c088d99304a0c3e40e8421ccffbd', 1, '2020-08-19 06:11:47', '2020-11-20 22:05:49', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 16, NULL, 0);
INSERT INTO `t_blog` VALUES ('9221570803479553d25f7211e9330d31', 'Go语言安装', 'Go语言安装', '<h1>Windows下Go语言的安装</h1>\n<h2>前言</h2>\n<p>这阵子因为以后工作的原因，所以开始了go语言的学习之旅，工欲善其事必先利其器，首先就得把go语言环境搭建完成</p>\n<h2>下载Go</h2>\n<p>因为go语言的官网经常打不开，所以我就找了一个 <a href=\"https://studygolang.com/dl\">镜像网站</a>，里面有很多版本的Go语言，选择自己合适的，比如我的是Windows电脑，所以我选中里面的Windows版本的</p>\n<p><img src=\"images/image-20200718111751694.png\" alt=\"image-20200718111751694\" /></p>\n<p>下载完成是一个安装文件，我们需要进行安装，同时需要注意的就是安装目录，因为事后还需要配置环境变量，下面是安装成功后的图片</p>\n<p><img src=\"images/image-20200718111822269.png\" alt=\"image-20200718111822269\" /></p>\n<h2>配置环境变量</h2>\n<p>根据windows系统在查找可执行程序的原理，可以将Go所在路径定义到环境变量中，让系统帮我们去找运行的执行程序，这样在任何目录下都可以执行go指令，需要配置的环境变量有：</p>\n<table>\n<thead>\n<tr><th>环境变量</th><th>说明</th></tr>\n</thead>\n<tbody>\n<tr><td>GOROOT</td><td>指定SDK的安装目录</td></tr>\n<tr><td>Path</td><td>添加SDK的/bin目录</td></tr>\n<tr><td>GOPATH</td><td>工作目录</td></tr>\n</tbody>\n</table>\n<p>这里面有几个重要的环境变量</p>\n<ul>\n<li><strong>GOPATH</strong>：在1.11版本之前，是我们书写项目的工作目录。在1.11版本之后它内部存储的是我们go.mod下载的依赖包。</li>\n<li><strong>GOROOT</strong>：Go语言的安装目录，不需要我们配置</li>\n<li><strong>GOPROXY</strong>：使用mod进行包管理时候的代理</li>\n</ul>\n<p>首先我们需要打开我们的环境变量，然后添加上GOROOT</p>\n<p><img src=\"images/image-20200718151418230.png\" alt=\"image-20200718151418230\" /></p>\n<p>然后我们在PATH上添加我们的bin目录</p>\n<p><img src=\"images/image-20200718151503318.png\" alt=\"image-20200718151503318\" /></p>\n<p>添加完成后，我们输入下面的命令，查看是否配置成功</p>\n<pre><code class=\"language-bash\">go version\n</code></pre>\n<p><img src=\"images/image-20200718112254366.png\" alt=\"image-20200718112254366\" /></p>\n<h2>下载Jetbrain下的GoLang</h2>\n<p>在我们配置好环境，我们就可以使用Jetbrain公司开发的Goland编辑器了，首先进入官网下载</p>\n<p><a href=\"https://www.jetbrains.com/\">https://www.jetbrains.com/</a></p>\n<p>下载完成后，进行启动</p>\n<p><img src=\"images/image-20200718150736688.png\" alt=\"image-20200718150736688\" /></p>\n<p>启动完成后，我们需要配置一下环境，点击：File -&gt;settings -&gt; GOROOT，配置一下刚刚go安装的目录</p>\n<p><img src=\"images/image-20200718151701767.png\" alt=\"image-20200718151701767\" /></p>\n<p>以及GOPATH项目所在的目录</p>\n<p><img src=\"images/image-20200718151733127.png\" alt=\"image-20200718151733127\" /></p>\n<h2>hello world</h2>\n<p>在上面的方法都完成以后，我来来输出hello world吧~</p>\n<pre><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc main() {\n	fmt.Println(&quot;hello world!&quot;)\n}\n</code></pre>\n<p>代码的说明</p>\n<ul>\n<li>go文件的后缀是.go</li>\n<li>package main：表示该hello.go文件所在的包是main，在go中，每个文件都归属与一个包</li>\n<li>import &quot;fmt&quot;：表示引入一个包，可以调用里面的函数</li>\n<li>func main()：表示程序入口，是一个主函数</li>\n</ul>\n<p>输出结果</p>\n<p><img src=\"images/image-20200718151850083.png\" alt=\"image-20200718151850083\" /></p>\n<h2>编译和执行</h2>\n<p>我们可以通过使用下面命令进行编译和执行</p>\n<pre><code class=\"language-bash\"># 编译 hello.go 后 会生成一个 hello.exe文件\ngo build hello.go\n# 运行 hello.ext\nhello.ext\n</code></pre>\n<p>需要注意的是，我们也可以使用下面的方式，来直接运行的（使用go run会比较慢，因为内部有个编译的过程）</p>\n<pre><code class=\"language-bash\">go run hello.go\n</code></pre>\n<p>但是在生产环境中，是需要先编译在执行的</p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 0, 0, 'd134bdfe255b9aa8c2ce44da8297f6a6', 1, '2021-01-14 15:38:18', '2021-01-14 15:38:18', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '0', 0, 1, 0, NULL, 42, NULL, 0);
INSERT INTO `t_blog` VALUES ('94ba19fb60e4cc7a4c096e4acf27714c', '默认标题1', '默认简介1', '<h1>Gin内容介绍</h1>\n<h2>参考</h2>\n<p>参考博客和文档：</p>\n<ul>\n<li><a href=\"https://www.liwenzhou.com/posts/Go/Gin_framework/\">Gin框架介绍及使用</a></li>\n<li><a href=\"https://gin-gonic.com/zh-cn/docs/\">Gin中文文档</a></li>\n</ul>\n<h2>主要内容</h2>\n<p>本教程主要从下面几个方面来进行讲解</p>\n<ul>\n<li>Gin框架基本使用</li>\n<li>GORM基本使用</li>\n<li>Web开发项目实战</li>\n</ul>\n<h2>关于Web</h2>\n<ul>\n<li>Web是基于HTTP协议进行交互的应用网络</li>\n<li>Web就是通过使用浏览器/APP访问的各种资源</li>\n</ul>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/10/13/1602552095534.png\" alt=\"image-20200913201627904\" />一个请求对应一个响应，以淘宝网为例，我们输入一个url，就会返回一个页面</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/10/13/1602552096461.png\" alt=\"image-20200913201929752\" /></p>\n<h2>创建项目</h2>\n<p>首先我们使用Goland创建一个Go项目</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/10/13/1602552096545.png\" alt=\"image-20200913202119089\" /></p>\n<p>创建完成后，打开命令窗口，输入下面的命令，创建一个依赖管理</p>\n<pre><code class=\"language-bash\">go mod init gin_demo\n</code></pre>\n<p>然后打开setting页面，勾选这个选项【不勾选会导致go.mod依赖爆红】</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/10/13/1602552096677.png\" alt=\"image-20200913210316077\" /></p>\n<p>我们创建一个main.go文件，然后使用go代码实现一个请求和响应</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n	&quot;fmt&quot;\n	&quot;net/http&quot;\n)\n\n// http.ResponseWriter：代表响应，传递到前端的\n// *http.Request：表示请求，从前端传递过来的\nfunc sayHello(w http.ResponseWriter, r *http.Request) {\n	_, _ = fmt.Fprintln(w, &quot;hello Golang!&quot;);\n}\n\nfunc main() {\n	http.HandleFunc(&quot;/hello&quot;, sayHello)\n	err := http.ListenAndServe(&quot;:9090&quot;, nil)\n	if err != nil {\n		fmt.Println(&quot;http server failed, err:%v \\n&quot;, err)\n		return\n	}\n}\n</code></pre>\n<p>在浏览器访问如下地址</p>\n<pre><code class=\"language-bash\">http://localhost:9090/hello\n</code></pre>\n<p>就能打开我们的hello golang页面了</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/10/13/1602552096583.png\" alt=\"image-20200913203807251\" /></p>\n<p>我们可以给文字添加色彩</p>\n<pre><code class=\"language-bash\">// http.ResponseWriter：代表响应，传递到前端的\n// *http.Request：表示请求，从前端传递过来的\nfunc sayHello(w http.ResponseWriter, r *http.Request) {\n	_, _ = fmt.Fprintln(w, &quot;&lt;h1 style=\'color:red\'&gt;hello Golang!&lt;h1&gt;&quot;);\n}\n</code></pre>\n<p>然后重启后，在刷新</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/10/13/1602552096611.png\" alt=\"image-20200913203922973\" /></p>\n<p>我们还可以把里面的字符串放在一个文件里，我们定义一个 hello.html文件</p>\n<pre><code class=\"language-html\">&lt;html&gt;\n    &lt;title&gt;hello golang&lt;/title&gt;\n    &lt;body&gt;\n        &lt;h1 style=\'color:red\'&gt;\n            hello Golang!\n        &lt;/h1&gt;\n        &lt;h1&gt;\n            hello gin!\n        &lt;/h1&gt;\n        &lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600011052622&amp;di=9aeee5de695a40c8d469f0c3980c2d48&amp;imgtype=0&amp;src=http%3A%2F%2Fa4.att.hudong.com%2F22%2F59%2F19300001325156131228593878903.jpg&quot;&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n<p>然后修改刚刚的main.go，使用  ioutil解析文件</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n	&quot;fmt&quot;\n	&quot;io/ioutil&quot;\n	&quot;net/http&quot;\n)\n\n// http.ResponseWriter：代表响应，传递到前端的\n// *http.Request：表示请求，从前端传递过来的\nfunc sayHello(w http.ResponseWriter, r *http.Request) {\n	html, _ := ioutil.ReadFile(&quot;./template/hello.html&quot;)\n	_, _ = fmt.Fprintln(w, string(html));\n}\n\nfunc main() {\n	http.HandleFunc(&quot;/hello&quot;, sayHello)\n	err := http.ListenAndServe(&quot;:9090&quot;, nil)\n	if err != nil {\n		fmt.Println(&quot;http server failed, err:%v \\n&quot;, err)\n		return\n	}\n}\n</code></pre>\n<p>最后刷新我们的页面，就出来这样的效果了，这就是我们通过golang开发的一个Web页面</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/10/13/1602552096639.png\" alt=\"image-20200913204456513\" /></p>\n<h2>为什么要用框架</h2>\n<p>我们通过上面的http包，就能够实现一个web的开发，那为什么还要用gin呢？</p>\n<p>其实框架的好处，就是别人帮我们搭建了一个舞台，同时提供了很多现成的轮子，让我们专注于业务的开发，同时让开发效率更高。</p>\n<h2>Gin框架介绍</h2>\n<p><code>Gin</code>是一个用Go语言编写的web框架。它是一个类似于<code>martini</code>但拥有更好性能的API框架, 由于使用了<code>httprouter</code>，速度提高了近40倍。 如果你是性能和高效的追求者, 你会爱上<code>Gin</code>。</p>\n<p>Go世界里最流行的Web框架，<a href=\"https://github.com/gin-gonic/gin\">Github</a>上有<code>32K+</code>star。 基于<a href=\"https://github.com/julienschmidt/httprouter\">httprouter</a>开发的Web框架。 <a href=\"https://gin-gonic.com/zh-cn/docs/\">中文文档</a>齐全，简单易用的轻量级框架。</p>\n<h2>Gin框架安装与使用</h2>\n<h3>安装</h3>\n<p>下载并安装<code>Gin</code>:</p>\n<pre><code class=\"language-bash\">go get -u github.com/gin-gonic/gin\n</code></pre>\n<h3>第一个Gin示例：</h3>\n<pre><code class=\"language-golang\">package main\n\nimport (\n	&quot;github.com/gin-gonic/gin&quot;\n)\n\nfunc main() {\n	// 创建一个默认的路由引擎\n	r := gin.Default()\n	// GET：请求方式；/hello：请求的路径\n	// 当客户端以GET方法请求/hello路径时，会执行后面的匿名函数\n	r.GET(&quot;/hello&quot;, func(c *gin.Context) {\n		// c.JSON：返回JSON格式的数据\n		c.JSON(200, gin.H{\n			&quot;message&quot;: &quot;Hello world!&quot;,\n		})\n	})\n	// 启动HTTP服务，默认在0.0.0.0:8080启动服务\n	r.Run()\n}\n</code></pre>\n<p>将上面的代码保存并编译执行，然后使用浏览器打开<code>127.0.0.1:8080/hello</code>就能看到一串JSON字符串。</p>\n<h2>RESTful API</h2>\n<p>REST与技术无关，代表的是一种软件架构风格，REST是Representational State Transfer的简称，中文翻译为“表征状态转移”或“表现层状态转化”。</p>\n<p>推荐阅读<a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\">阮一峰 理解RESTful架构</a></p>\n<p>简单来说，REST的含义就是客户端与Web服务器之间进行交互的时候，使用HTTP协议中的4个请求方法代表不同的动作。</p>\n<ul>\n<li><code>GET</code>用来获取资源</li>\n<li><code>POST</code>用来新建资源</li>\n<li><code>PUT</code>用来更新资源</li>\n<li><code>DELETE</code>用来删除资源。</li>\n</ul>\n<p>只要API程序遵循了REST风格，那就可以称其为RESTful API。目前在前后端分离的架构中，前后端基本都是通过RESTful API来进行交互。</p>\n<p>例如，我们现在要编写一个管理书籍的系统，我们可以查询对一本书进行查询、创建、更新和删除等操作，我们在编写程序的时候就要设计客户端浏览器与我们Web服务端交互的方式和路径。按照经验我们通常会设计成如下模式：</p>\n<table>\n<thead>\n<tr><th align=\"center\">请求方法</th><th align=\"center\">URL</th><th align=\"center\">含义</th></tr>\n</thead>\n<tbody>\n<tr><td align=\"center\">GET</td><td align=\"center\">/book</td><td align=\"center\">查询书籍信息</td></tr>\n<tr><td align=\"center\">POST</td><td align=\"center\">/create_book</td><td align=\"center\">创建书籍记录</td></tr>\n<tr><td align=\"center\">POST</td><td align=\"center\">/update_book</td><td align=\"center\">更新书籍信息</td></tr>\n<tr><td align=\"center\">POST</td><td align=\"center\">/delete_book</td><td align=\"center\">删除书籍信息</td></tr>\n</tbody>\n</table>\n<p>同样的需求我们按照RESTful API设计如下：</p>\n<table>\n<thead>\n<tr><th align=\"center\">请求方法</th><th align=\"center\">URL</th><th align=\"center\">含义</th></tr>\n</thead>\n<tbody>\n<tr><td align=\"center\">GET</td><td align=\"center\">/book</td><td align=\"center\">查询书籍信息</td></tr>\n<tr><td align=\"center\">POST</td><td align=\"center\">/book</td><td align=\"center\">创建书籍记录</td></tr>\n<tr><td align=\"center\">PUT</td><td align=\"center\">/book</td><td align=\"center\">更新书籍信息</td></tr>\n<tr><td align=\"center\">DELETE</td><td align=\"center\">/book</td><td align=\"center\">删除书籍信息</td></tr>\n</tbody>\n</table>\n<p>Gin框架支持开发RESTful API的开发。</p>\n<pre><code class=\"language-go\">func main() {\n	r := gin.Default()\n	r.GET(&quot;/book&quot;, func(c *gin.Context) {\n		c.JSON(200, gin.H{\n			&quot;message&quot;: &quot;GET&quot;,\n		})\n	})\n\n	r.POST(&quot;/book&quot;, func(c *gin.Context) {\n		c.JSON(200, gin.H{\n			&quot;message&quot;: &quot;POST&quot;,\n		})\n	})\n\n	r.PUT(&quot;/book&quot;, func(c *gin.Context) {\n		c.JSON(200, gin.H{\n			&quot;message&quot;: &quot;PUT&quot;,\n		})\n	})\n\n	r.DELETE(&quot;/book&quot;, func(c *gin.Context) {\n		c.JSON(200, gin.H{\n			&quot;message&quot;: &quot;DELETE&quot;,\n		})\n	})\n    \n   	// 启动HTTP服务，默认在0.0.0.0:8080启动服务\n	r.Run()\n}\n</code></pre>\n<p>开发RESTful API的时候我们通常使用<a href=\"https://www.getpostman.com/\">Postman</a>来作为客户端的测试工具。</p>\n<h2>Gin渲染</h2>\n<h3>HTML渲染</h3>\n<p>我们首先定义一个存放模板文件的<code>templates</code>文件夹，然后在其内部按照业务分别定义一个<code>posts</code>文件夹和一个<code>users</code>文件夹。 <code>posts/index.html</code>文件的内容如下：</p>\n<pre><code class=\"language-template\">{{define &quot;posts/index.html&quot;}}\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;posts/index&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    {{.title}}\n&lt;/body&gt;\n&lt;/html&gt;\n{{end}}\n</code></pre>\n<p><code>users/index.html</code>文件的内容如下：</p>\n<pre><code class=\"language-template\">{{define &quot;users/index.html&quot;}}\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;users/index&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    {{.title}}\n&lt;/body&gt;\n&lt;/html&gt;\n{{end}}\n</code></pre>\n<p>Gin框架中使用<code>LoadHTMLGlob()</code>或者<code>LoadHTMLFiles()</code>方法进行HTML模板渲染。</p>\n<pre><code class=\"language-go\">func main() {\n	r := gin.Default()\n	r.LoadHTMLGlob(&quot;templates/**/*&quot;)\n	//r.LoadHTMLFiles(&quot;templates/posts/index.html&quot;, &quot;templates/users/index.html&quot;)\n	r.GET(&quot;/posts/index&quot;, func(c *gin.Context) {\n		c.HTML(http.StatusOK, &quot;posts/index.html&quot;, gin.H{\n			&quot;title&quot;: &quot;posts/index&quot;,\n		})\n	})\n\n	r.GET(&quot;users/index&quot;, func(c *gin.Context) {\n		c.HTML(http.StatusOK, &quot;users/index.html&quot;, gin.H{\n			&quot;title&quot;: &quot;users/index&quot;,\n		})\n	})\n\n	r.Run(&quot;:8080&quot;)\n}\n</code></pre>\n<h3>自定义模板函数</h3>\n<p>定义一个不转义相应内容的<code>safe</code>模板函数如下：</p>\n<pre><code class=\"language-go\">func main() {\n	router := gin.Default()\n	router.SetFuncMap(template.FuncMap{\n		&quot;safe&quot;: func(str string) template.HTML{\n			return template.HTML(str)\n		},\n	})\n	router.LoadHTMLFiles(&quot;./index.tmpl&quot;)\n\n	router.GET(&quot;/index&quot;, func(c *gin.Context) {\n		c.HTML(http.StatusOK, &quot;index.tmpl&quot;, &quot;&lt;a href=\'https://liwenzhou.com\'&gt;李文周的博客&lt;/a&gt;&quot;)\n	})\n\n	router.Run(&quot;:8080&quot;)\n}\n</code></pre>\n<p>在<code>index.tmpl</code>中使用定义好的<code>safe</code>模板函数：</p>\n<pre><code class=\"language-template\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;zh-CN&quot;&gt;\n&lt;head&gt;\n    &lt;title&gt;修改模板引擎的标识符&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div&gt;{{ . | safe }}&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>为了让index.tmpl文件有语法显示，我们还需要配置一下</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/10/13/1602552096750.png\" alt=\"image-20200913213156919\" /></p>\n<p>然后我们加入 *.tmpl，保存即可</p>\n<h3>静态文件处理</h3>\n<p>当我们渲染的HTML文件中引用了静态文件时，我们只需要按照以下方式在渲染页面前调用<code>gin.Static</code>方法即可。</p>\n<pre><code class=\"language-go\">func main() {\n	r := gin.Default()\n	r.Static(&quot;/static&quot;, &quot;./static&quot;)\n	r.LoadHTMLGlob(&quot;templates/**/*&quot;)\n   // ...\n	r.Run(&quot;:8080&quot;)\n}\n</code></pre>\n<h3>使用模板继承</h3>\n<p>Gin框架默认都是使用单模板，如果需要使用<code>block template</code>功能，可以通过<code>&quot;github.com/gin-contrib/multitemplate&quot;</code>库实现，具体示例如下：</p>\n<p>首先，假设我们项目目录下的templates文件夹下有以下模板文件，其中<code>home.tmpl</code>和<code>index.tmpl</code>继承了<code>base.tmpl</code>：</p>\n<pre><code class=\"language-bash\">templates\n├── includes\n│   ├── home.tmpl\n│   └── index.tmpl\n├── layouts\n│   └── base.tmpl\n└── scripts.tmpl\n</code></pre>\n<p>然后我们定义一个<code>loadTemplates</code>函数如下：</p>\n<pre><code class=\"language-go\">func loadTemplates(templatesDir string) multitemplate.Renderer {\n	r := multitemplate.NewRenderer()\n	layouts, err := filepath.Glob(templatesDir + &quot;/layouts/*.tmpl&quot;)\n	if err != nil {\n		panic(err.Error())\n	}\n	includes, err := filepath.Glob(templatesDir + &quot;/includes/*.tmpl&quot;)\n	if err != nil {\n		panic(err.Error())\n	}\n	// 为layouts/和includes/目录生成 templates map\n	for _, include := range includes {\n		layoutCopy := make([]string, len(layouts))\n		copy(layoutCopy, layouts)\n		files := append(layoutCopy, include)\n		r.AddFromFiles(filepath.Base(include), files...)\n	}\n	return r\n}\n</code></pre>\n<p>我们在<code>main</code>函数中</p>\n<pre><code class=\"language-go\">func indexFunc(c *gin.Context){\n	c.HTML(http.StatusOK, &quot;index.tmpl&quot;, nil)\n}\n\nfunc homeFunc(c *gin.Context){\n	c.HTML(http.StatusOK, &quot;home.tmpl&quot;, nil)\n}\n\nfunc main(){\n	r := gin.Default()\n	r.HTMLRender = loadTemplates(&quot;./templates&quot;)\n	r.GET(&quot;/index&quot;, indexFunc)\n	r.GET(&quot;/home&quot;, homeFunc)\n	r.Run()\n}\n</code></pre>\n<h3>补充文件路径处理</h3>\n<p>关于模板文件和静态文件的路径，我们需要根据公司/项目的要求进行设置。可以使用下面的函数获取当前执行程序的路径。</p>\n<pre><code class=\"language-go\">func getCurrentPath() string {\n	if ex, err := os.Executable(); err == nil {\n		return filepath.Dir(ex)\n	}\n	return &quot;./&quot;\n}\n</code></pre>\n<h3>JSON渲染</h3>\n<pre><code class=\"language-go\">func main() {\n	r := gin.Default()\n\n	// gin.H 是map[string]interface{}的缩写\n	r.GET(&quot;/someJSON&quot;, func(c *gin.Context) {\n		// 方式一：自己拼接JSON\n		c.JSON(http.StatusOK, gin.H{&quot;message&quot;: &quot;Hello world!&quot;})\n	})\n	r.GET(&quot;/moreJSON&quot;, func(c *gin.Context) {\n		// 方法二：使用结构体\n		var msg struct {\n			Name    string `json:&quot;user&quot;`\n			Message string\n			Age     int\n		}\n		msg.Name = &quot;小王子&quot;\n		msg.Message = &quot;Hello world!&quot;\n		msg.Age = 18\n		c.JSON(http.StatusOK, msg)\n	})\n	r.Run(&quot;:8080&quot;)\n}\n</code></pre>\n<h3>XML渲染</h3>\n<p>注意需要使用具名的结构体类型。</p>\n<pre><code class=\"language-go\">func main() {\n	r := gin.Default()\n	// gin.H 是map[string]interface{}的缩写\n	r.GET(&quot;/someXML&quot;, func(c *gin.Context) {\n		// 方式一：自己拼接JSON\n		c.XML(http.StatusOK, gin.H{&quot;message&quot;: &quot;Hello world!&quot;})\n	})\n	r.GET(&quot;/moreXML&quot;, func(c *gin.Context) {\n		// 方法二：使用结构体\n		type MessageRecord struct {\n			Name    string\n			Message string\n			Age     int\n		}\n		var msg MessageRecord\n		msg.Name = &quot;小王子&quot;\n		msg.Message = &quot;Hello world!&quot;\n		msg.Age = 18\n		c.XML(http.StatusOK, msg)\n	})\n	r.Run(&quot;:8080&quot;)\n}\n</code></pre>\n<h3>YMAL渲染</h3>\n<pre><code class=\"language-go\">r.GET(&quot;/someYAML&quot;, func(c *gin.Context) {\n	c.YAML(http.StatusOK, gin.H{&quot;message&quot;: &quot;ok&quot;, &quot;status&quot;: http.StatusOK})\n})\n</code></pre>\n<h3>protobuf渲染</h3>\n<pre><code class=\"language-go\">r.GET(&quot;/someProtoBuf&quot;, func(c *gin.Context) {\n	reps := []int64{int64(1), int64(2)}\n	label := &quot;test&quot;\n	// protobuf 的具体定义写在 testdata/protoexample 文件中。\n	data := &amp;protoexample.Test{\n		Label: &amp;label,\n		Reps:  reps,\n	}\n	// 请注意，数据在响应中变为二进制数据\n	// 将输出被 protoexample.Test protobuf 序列化了的数据\n	c.ProtoBuf(http.StatusOK, data)\n})\n</code></pre>\n<h2>获取参数</h2>\n<h3>获取querystring参数</h3>\n<p><code>querystring</code>指的是URL中<code>?</code>后面携带的参数，例如：<code>/user/search?username=小王子&amp;address=沙河</code>。 获取请求的querystring参数的方法如下：</p>\n<pre><code class=\"language-go\">func main() {\n	//Default返回一个默认的路由引擎\n	r := gin.Default()\n	r.GET(&quot;/user/search&quot;, func(c *gin.Context) {\n        // 可以添加默认值\n		username := c.DefaultQuery(&quot;username&quot;, &quot;小王子&quot;)\n		//username := c.Query(&quot;username&quot;)\n		address := c.Query(&quot;address&quot;)\n		//输出json结果给调用方\n		c.JSON(http.StatusOK, gin.H{\n			&quot;message&quot;:  &quot;ok&quot;,\n			&quot;username&quot;: username,\n			&quot;address&quot;:  address,\n		})\n	})\n	r.Run()\n}\n</code></pre>\n<p>我们输入对应的URL，就能获取到对应的参数了</p>\n<pre><code class=\"language-bash\">http://localhost:9090/web?username=小王子&amp;address=沙河\n</code></pre>\n<h3>获取form参数</h3>\n<p>请求的数据通过form表单来提交，例如向<code>/user/search</code>发送一个POST请求，获取请求数据的方式如下：</p>\n<pre><code class=\"language-go\">func main() {\n	//Default返回一个默认的路由引擎\n	r := gin.Default()\n	r.POST(&quot;/user/search&quot;, func(c *gin.Context) {\n		// DefaultPostForm取不到值时会返回指定的默认值\n		//username := c.DefaultPostForm(&quot;username&quot;, &quot;小王子&quot;)\n		username := c.PostForm(&quot;username&quot;)\n		address := c.PostForm(&quot;address&quot;)\n		//输出json结果给调用方\n		c.JSON(http.StatusOK, gin.H{\n			&quot;message&quot;:  &quot;ok&quot;,\n			&quot;username&quot;: username,\n			&quot;address&quot;:  address,\n		})\n	})\n	r.Run(&quot;:8080&quot;)\n}\n</code></pre>\n<h3>获取path参数</h3>\n<p>请求的参数通过URL路径传递，例如：<code>/user/search/小王子/沙河</code>。 获取请求URL路径中的参数的方式如下。</p>\n<pre><code class=\"language-go\">func main() {\n	//Default返回一个默认的路由引擎\n	r := gin.Default()\n	r.GET(&quot;/user/search/:username/:address&quot;, func(c *gin.Context) {\n		username := c.Param(&quot;username&quot;)\n		address := c.Param(&quot;address&quot;)\n		//输出json结果给调用方\n		c.JSON(http.StatusOK, gin.H{\n			&quot;message&quot;:  &quot;ok&quot;,\n			&quot;username&quot;: username,\n			&quot;address&quot;:  address,\n		})\n	})\n\n	r.Run(&quot;:8080&quot;)\n}\n</code></pre>\n<h3>参数绑定</h3>\n<p>为了能够更方便的获取请求相关参数，提高开发效率，我们可以基于请求的<code>Content-Type</code>识别请求数据类型并利用反射机制自动提取请求中<code>QueryString</code>、<code>form表单</code>、<code>JSON</code>、<code>XML</code>等参数到结构体中。 下面的示例代码演示了<code>.ShouldBind()</code>强大的功能，它能够基于请求自动提取<code>JSON</code>、<code>form表单</code>和<code>QueryString</code>类型的数据，并把值绑定到指定的结构体对象。</p>\n<pre><code class=\"language-go\">// Binding from JSON\ntype Login struct {\n	User     string `form:&quot;user&quot; json:&quot;user&quot; binding:&quot;required&quot;`\n	Password string `form:&quot;password&quot; json:&quot;password&quot; binding:&quot;required&quot;`\n}\n\nfunc main() {\n	router := gin.Default()\n\n	// 绑定JSON的示例 ({&quot;user&quot;: &quot;q1mi&quot;, &quot;password&quot;: &quot;123456&quot;})\n	router.POST(&quot;/loginJSON&quot;, func(c *gin.Context) {\n		var login Login\n\n		if err := c.ShouldBind(&amp;login); err == nil {\n			fmt.Printf(&quot;login info:%#v\\n&quot;, login)\n			c.JSON(http.StatusOK, gin.H{\n				&quot;user&quot;:     login.User,\n				&quot;password&quot;: login.Password,\n			})\n		} else {\n			c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})\n		}\n	})\n\n	// 绑定form表单示例 (user=q1mi&amp;password=123456)\n	router.POST(&quot;/loginForm&quot;, func(c *gin.Context) {\n		var login Login\n		// ShouldBind()会根据请求的Content-Type自行选择绑定器\n		if err := c.ShouldBind(&amp;login); err == nil {\n			c.JSON(http.StatusOK, gin.H{\n				&quot;user&quot;:     login.User,\n				&quot;password&quot;: login.Password,\n			})\n		} else {\n			c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})\n		}\n	})\n\n	// 绑定QueryString示例 (/loginQuery?user=q1mi&amp;password=123456)\n	router.GET(&quot;/loginForm&quot;, func(c *gin.Context) {\n		var login Login\n		// ShouldBind()会根据请求的Content-Type自行选择绑定器\n		if err := c.ShouldBind(&amp;login); err == nil {\n			c.JSON(http.StatusOK, gin.H{\n				&quot;user&quot;:     login.User,\n				&quot;password&quot;: login.Password,\n			})\n		} else {\n			c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})\n		}\n	})\n\n	// Listen and serve on 0.0.0.0:8080\n	router.Run(&quot;:8080&quot;)\n}\n</code></pre>\n<p><code>ShouldBind</code>会按照下面的顺序解析请求中的数据完成绑定：</p>\n<ol>\n<li>如果是 <code>GET</code> 请求，只使用 <code>Form</code> 绑定引擎（<code>query</code>）。</li>\n<li>如果是 <code>POST</code> 请求，首先检查 <code>content-type</code> 是否为 <code>JSON</code> 或 <code>XML</code>，然后再使用 <code>Form</code>（<code>form-data</code>）。</li>\n</ol>\n<h2>文件上传</h2>\n<h3>单个文件上传</h3>\n<p>文件上传前端页面代码：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;zh-CN&quot;&gt;\n&lt;head&gt;\n    &lt;title&gt;上传文件示例&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;\n    &lt;input type=&quot;file&quot; name=&quot;f1&quot;&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>后端gin框架部分代码：</p>\n<pre><code class=\"language-go\">func main() {\n	router := gin.Default()\n	// 处理multipart forms提交文件时默认的内存限制是32 MiB\n	// 可以通过下面的方式修改\n	// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB\n	router.POST(&quot;/upload&quot;, func(c *gin.Context) {\n		// 单个文件\n		file, err := c.FormFile(&quot;f1&quot;)\n		if err != nil {\n			c.JSON(http.StatusInternalServerError, gin.H{\n				&quot;message&quot;: err.Error(),\n			})\n			return\n		}\n\n		log.Println(file.Filename)\n		dst := fmt.Sprintf(&quot;C:/tmp/%s&quot;, file.Filename)\n		// 上传文件到指定的目录\n		c.SaveUploadedFile(file, dst)\n		c.JSON(http.StatusOK, gin.H{\n			&quot;message&quot;: fmt.Sprintf(&quot;\'%s\' uploaded!&quot;, file.Filename),\n		})\n	})\n	router.Run()\n}\n</code></pre>\n<h3>多个文件上传</h3>\n<pre><code class=\"language-go\">func main() {\n	router := gin.Default()\n	// 处理multipart forms提交文件时默认的内存限制是32 MiB\n	// 可以通过下面的方式修改\n	// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB\n	router.POST(&quot;/upload&quot;, func(c *gin.Context) {\n		// Multipart form\n		form, _ := c.MultipartForm()\n		files := form.File[&quot;file&quot;]\n\n		for index, file := range files {\n			log.Println(file.Filename)\n			dst := fmt.Sprintf(&quot;C:/tmp/%s_%d&quot;, file.Filename, index)\n			// 上传文件到指定的目录\n			c.SaveUploadedFile(file, dst)\n		}\n		c.JSON(http.StatusOK, gin.H{\n			&quot;message&quot;: fmt.Sprintf(&quot;%d files uploaded!&quot;, len(files)),\n		})\n	})\n	router.Run()\n}\n</code></pre>\n<h2>重定向</h2>\n<h3>HTTP重定向</h3>\n<p>HTTP 重定向很容易。 内部、外部重定向均支持。</p>\n<pre><code class=\"language-go\">r.GET(&quot;/test&quot;, func(c *gin.Context) {\n	c.Redirect(http.StatusMovedPermanently, &quot;http://www.sogo.com/&quot;)\n})\n</code></pre>\n<h3>路由重定向</h3>\n<p>路由重定向，使用<code>HandleContext</code>：</p>\n<pre><code class=\"language-go\">r.GET(&quot;/test&quot;, func(c *gin.Context) {\n    // 指定重定向的URL\n    c.Request.URL.Path = &quot;/test2&quot;\n    r.HandleContext(c)\n})\nr.GET(&quot;/test2&quot;, func(c *gin.Context) {\n    c.JSON(http.StatusOK, gin.H{&quot;hello&quot;: &quot;world&quot;})\n})\n</code></pre>\n<h2>Gin路由</h2>\n<h3>普通路由</h3>\n<pre><code class=\"language-go\">r.GET(&quot;/index&quot;, func(c *gin.Context) {...})\nr.GET(&quot;/login&quot;, func(c *gin.Context) {...})\nr.POST(&quot;/login&quot;, func(c *gin.Context) {...})\n</code></pre>\n<p>此外，还有一个可以匹配所有请求方法的<code>Any</code>方法如下：</p>\n<pre><code class=\"language-go\">r.Any(&quot;/test&quot;, func(c *gin.Context) {...})\n</code></pre>\n<p>为没有配置处理函数的路由添加处理程序，默认情况下它返回404代码，下面的代码为没有匹配到路由的请求都返回<code>views/404.html</code>页面。</p>\n<pre><code class=\"language-go\">r.NoRoute(func(c *gin.Context) {\n		c.HTML(http.StatusNotFound, &quot;views/404.html&quot;, nil)\n	})\n</code></pre>\n<h3>路由组</h3>\n<p>我们可以将拥有共同URL前缀的路由划分为一个路由组。习惯性一对<code>{}</code>包裹同组的路由，这只是为了看着清晰，你用不用<code>{}</code>包裹功能上没什么区别。</p>\n<pre><code class=\"language-go\">func main() {\n	r := gin.Default()\n	userGroup := r.Group(&quot;/user&quot;)\n	{\n		userGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...})\n		userGroup.GET(&quot;/login&quot;, func(c *gin.Context) {...})\n		userGroup.POST(&quot;/login&quot;, func(c *gin.Context) {...})\n\n	}\n	shopGroup := r.Group(&quot;/shop&quot;)\n	{\n		shopGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...})\n		shopGroup.GET(&quot;/cart&quot;, func(c *gin.Context) {...})\n		shopGroup.POST(&quot;/checkout&quot;, func(c *gin.Context) {...})\n	}\n	r.Run()\n}\n</code></pre>\n<p>路由组也是支持嵌套的，例如：</p>\n<pre><code class=\"language-go\">shopGroup := r.Group(&quot;/shop&quot;)\n	{\n		shopGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...})\n		shopGroup.GET(&quot;/cart&quot;, func(c *gin.Context) {...})\n		shopGroup.POST(&quot;/checkout&quot;, func(c *gin.Context) {...})\n		// 嵌套路由组\n		xx := shopGroup.Group(&quot;xx&quot;)\n		xx.GET(&quot;/oo&quot;, func(c *gin.Context) {...})\n	}\n</code></pre>\n<p>通常我们将路由分组用在划分业务逻辑或划分API版本时。</p>\n<h3>路由原理</h3>\n<p>Gin框架中的路由使用的是<a href=\"https://github.com/julienschmidt/httprouter\">httprouter</a>这个库。</p>\n<p>其基本原理就是构造一个路由地址的前缀树。</p>\n<h2>Gin中间件</h2>\n<p>Gin框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、记录日志、耗时统计等。</p>\n<h3>定义中间件</h3>\n<p>Gin中的中间件必须是一个<code>gin.HandlerFunc</code>类型。例如我们像下面的代码一样定义一个统计请求耗时的中间件。</p>\n<pre><code class=\"language-go\">// StatCost 是一个统计耗时请求耗时的中间件\nfunc StatCost() gin.HandlerFunc {\n	return func(c *gin.Context) {\n		start := time.Now()\n		c.Set(&quot;name&quot;, &quot;小王子&quot;) // 可以通过c.Set在请求上下文中设置值，后续的处理函数能够取到该值\n		// 调用该请求的剩余处理程序\n		c.Next()\n		// 不调用该请求的剩余处理程序\n		// c.Abort()\n		// 计算耗时\n		cost := time.Since(start)\n		log.Println(cost)\n	}\n}\n</code></pre>\n<h3>注册中间件</h3>\n<p>在gin框架中，我们可以为每个路由添加任意数量的中间件。</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/10/13/1602552096800.png\" alt=\"image-20200917210942305\" /></p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/10/13/1602552096849.png\" alt=\"image-20200917211033323\" /></p>\n<p>中间的这个通过 Abort() 可以阻止执行</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/10/13/1602552096877.png\" alt=\"image-20200917211259531\" /></p>\n<h4>为全局路由注册</h4>\n<pre><code class=\"language-go\">func main() {\n	// 新建一个没有任何默认中间件的路由\n	r := gin.New()\n	// 注册一个全局中间件\n	r.Use(StatCost())\n	\n	r.GET(&quot;/test&quot;, func(c *gin.Context) {\n		name := c.MustGet(&quot;name&quot;).(string) // 从上下文取值\n		log.Println(name)\n		c.JSON(http.StatusOK, gin.H{\n			&quot;message&quot;: &quot;Hello world!&quot;,\n		})\n	})\n	r.Run()\n}\n</code></pre>\n<h4>为某个路由单独注册</h4>\n<pre><code class=\"language-go\">// 给/test2路由单独注册中间件（可注册多个）\n	r.GET(&quot;/test2&quot;, StatCost(), func(c *gin.Context) {\n		name := c.MustGet(&quot;name&quot;).(string) // 从上下文取值\n		log.Println(name)\n		c.JSON(http.StatusOK, gin.H{\n			&quot;message&quot;: &quot;Hello world!&quot;,\n		})\n	})\n</code></pre>\n<h4>为路由组注册中间件</h4>\n<p>为路由组注册中间件有以下两种写法。</p>\n<p>写法1：</p>\n<pre><code class=\"language-go\">shopGroup := r.Group(&quot;/shop&quot;, StatCost())\n{\n    shopGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...})\n    ...\n}\n</code></pre>\n<p>写法2：</p>\n<pre><code class=\"language-go\">shopGroup := r.Group(&quot;/shop&quot;)\nshopGroup.Use(StatCost())\n{\n    shopGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...})\n    ...\n}\n</code></pre>\n<h3>中间件注意事项</h3>\n<h4>gin默认中间件</h4>\n<p><code>gin.Default()</code>默认使用了<code>Logger</code>和<code>Recovery</code>中间件，其中：</p>\n<ul>\n<li><code>Logger</code>中间件将日志写入<code>gin.DefaultWriter</code>，即使配置了<code>GIN_MODE=release</code>。</li>\n<li><code>Recovery</code>中间件会recover任何<code>panic</code>。如果有panic的话，会写入500响应码。</li>\n</ul>\n<p>如果不想使用上面两个默认的中间件，可以使用<code>gin.New()</code>新建一个没有任何默认中间件的路由。</p>\n<h4>gin中间件中使用goroutine</h4>\n<p>当在中间件或<code>handler</code>中启动新的<code>goroutine</code>时，<strong>不能使用</strong>原始的上下文（c *gin.Context），必须使用其只读副本（<code>c.Copy()</code>）。</p>\n<h2>运行多个服务</h2>\n<p>我们可以在多个端口启动服务，例如：</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n	&quot;log&quot;\n	&quot;net/http&quot;\n	&quot;time&quot;\n\n	&quot;github.com/gin-gonic/gin&quot;\n	&quot;golang.org/x/sync/errgroup&quot;\n)\n\nvar (\n	g errgroup.Group\n)\n\nfunc router01() http.Handler {\n	e := gin.New()\n	e.Use(gin.Recovery())\n	e.GET(&quot;/&quot;, func(c *gin.Context) {\n		c.JSON(\n			http.StatusOK,\n			gin.H{\n				&quot;code&quot;:  http.StatusOK,\n				&quot;error&quot;: &quot;Welcome server 01&quot;,\n			},\n		)\n	})\n\n	return e\n}\n\nfunc router02() http.Handler {\n	e := gin.New()\n	e.Use(gin.Recovery())\n	e.GET(&quot;/&quot;, func(c *gin.Context) {\n		c.JSON(\n			http.StatusOK,\n			gin.H{\n				&quot;code&quot;:  http.StatusOK,\n				&quot;error&quot;: &quot;Welcome server 02&quot;,\n			},\n		)\n	})\n\n	return e\n}\n\nfunc main() {\n	server01 := &amp;http.Server{\n		Addr:         &quot;:8080&quot;,\n		Handler:      router01(),\n		ReadTimeout:  5 * time.Second,\n		WriteTimeout: 10 * time.Second,\n	}\n\n	server02 := &amp;http.Server{\n		Addr:         &quot;:8081&quot;,\n		Handler:      router02(),\n		ReadTimeout:  5 * time.Second,\n		WriteTimeout: 10 * time.Second,\n	}\n   // 借助errgroup.Group或者自行开启两个goroutine分别启动两个服务\n	g.Go(func() error {\n		return server01.ListenAndServe()\n	})\n\n	g.Go(func() error {\n		return server02.ListenAndServe()\n	})\n\n	if err := g.Wait(); err != nil {\n		log.Fatal(err)\n	}\n}\n</code></pre>\n', '7e0e93ea6cdb44ae92e58f48e6496ed7', 0, 0, 'd134bdfe255b9aa8c2ce44da8297f6a6', 0, '2020-10-13 09:21:43', '2020-10-13 09:21:47', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '0', 0, 1, 0, NULL, 17, NULL, 0);
INSERT INTO `t_blog` VALUES ('982cb047f1672d03324db6be18bfb373', 'go', 'go', '<blockquote>\n<p>go测试</p>\n</blockquote>\n<pre><code class=\"language-go\">package main\n\nimport (\n	&quot;context&quot;\n	&quot;fmt&quot;\n	&quot;go.etcd.io/etcd/clientv3&quot;\n	&quot;time&quot;\n)\n\nfunc main() {\n	cli, err := clientv3.New(clientv3.Config {\n		Endpoints: []string{&quot;127.0.0.1:2379&quot;}, // etcd的节点，可以传入多个\n		DialTimeout: 5*time.Second, // 连接超时时间\n	})\n\n	if err != nil {\n		fmt.Printf(&quot;connect to etcd failed, err: %v \\n&quot;, err)\n		return\n	}\n	fmt.Println(&quot;connect to etcd success&quot;)\n\n	// 延迟关闭\n	defer cli.Close()\n\n	// put操作  设置1秒超时\n	ctx, cancel := context.WithTimeout(context.Background(), time.Second)\n	_, err = cli.Put(ctx, &quot;moxi&quot;, &quot;lalala&quot;)\n	cancel()\n	if err != nil {\n		fmt.Printf(&quot;put to etcd failed, err:%v \\n&quot;, err)\n		return\n	}\n\n	// get操作，设置1秒超时\n	ctx, cancel = context.WithTimeout(context.Background(), time.Second)\n	resp, err := cli.Get(ctx, &quot;q1mi&quot;)\n	cancel()\n	if err != nil {\n		fmt.Printf(&quot;get from etcd failed, err:%v \\n&quot;, err)\n		return\n	}\n	fmt.Println(resp)\n}\n\n\n\n\n\n</code></pre>\n<h3 id=\"测试\">测试</h3>\n<p>今天我们在做啥呢</p>\n<p>我觉得还不错呢？</p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 2, 0, NULL, 0, '2020-09-11 19:41:35', '2020-09-14 10:32:20', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 18, NULL, 0);
INSERT INTO `t_blog` VALUES ('9d13d883621f4e7aafbb59b641af1b11', 'filedatas', 'filedatas', '<h1>Windows下Go语言的安装</h1>\n<h2>前言</h2>\n<p>这阵子因为以后工作的原因，所以开始了go语言的学习之旅，工欲善其事必先利其器，首先就得把go语言环境搭建完成</p>\n<h2>下载Go</h2>\n<p>因为go语言的官网经常打不开，所以我就找了一个 <a href=\"https://studygolang.com/dl\">镜像网站</a>，里面有很多版本的Go语言，选择自己合适的，比如我的是Windows电脑，所以我选中里面的Windows版本的</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/1/14/1610608176327.png\" alt=\"image-20200718111751694\" /></p>\n<p>下载完成是一个安装文件，我们需要进行安装，同时需要注意的就是安装目录，因为事后还需要配置环境变量，下面是安装成功后的图片</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/1/14/1610608176389.png\" alt=\"image-20200718111822269\" /></p>\n<h2>配置环境变量</h2>\n<p>根据windows系统在查找可执行程序的原理，可以将Go所在路径定义到环境变量中，让系统帮我们去找运行的执行程序，这样在任何目录下都可以执行go指令，需要配置的环境变量有：</p>\n<table>\n<thead>\n<tr><th>环境变量</th><th>说明</th></tr>\n</thead>\n<tbody>\n<tr><td>GOROOT</td><td>指定SDK的安装目录</td></tr>\n<tr><td>Path</td><td>添加SDK的/bin目录</td></tr>\n<tr><td>GOPATH</td><td>工作目录</td></tr>\n</tbody>\n</table>\n<p>这里面有几个重要的环境变量</p>\n<ul>\n<li><strong>GOPATH</strong>：在1.11版本之前，是我们书写项目的工作目录。在1.11版本之后它内部存储的是我们go.mod下载的依赖包。</li>\n<li><strong>GOROOT</strong>：Go语言的安装目录，不需要我们配置</li>\n<li><strong>GOPROXY</strong>：使用mod进行包管理时候的代理</li>\n</ul>\n<p>首先我们需要打开我们的环境变量，然后添加上GOROOT</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/1/14/1610608176527.png\" alt=\"image-20200718151418230\" /></p>\n<p>然后我们在PATH上添加我们的bin目录</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/1/14/1610608176601.png\" alt=\"image-20200718151503318\" /></p>\n<p>添加完成后，我们输入下面的命令，查看是否配置成功</p>\n<pre><code class=\"language-bash\">go version\n</code></pre>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/1/14/1610608176416.png\" alt=\"image-20200718112254366\" /></p>\n<h2>下载Jetbrain下的GoLang</h2>\n<p>在我们配置好环境，我们就可以使用Jetbrain公司开发的Goland编辑器了，首先进入官网下载</p>\n<p><a href=\"https://www.jetbrains.com/\">https://www.jetbrains.com/</a></p>\n<p>下载完成后，进行启动</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/1/14/1610608176499.png\" alt=\"image-20200718150736688\" /></p>\n<p>启动完成后，我们需要配置一下环境，点击：File -&gt;settings -&gt; GOROOT，配置一下刚刚go安装的目录</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/1/14/1610608176637.png\" alt=\"image-20200718151701767\" /></p>\n<p>以及GOPATH项目所在的目录</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/1/14/1610608176669.png\" alt=\"image-20200718151733127\" /></p>\n<h2>hello world</h2>\n<p>在上面的方法都完成以后，我来来输出hello world吧~</p>\n<pre><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc main() {\n	fmt.Println(&quot;hello world!&quot;)\n}\n</code></pre>\n<p>代码的说明</p>\n<ul>\n<li>go文件的后缀是.go</li>\n<li>package main：表示该hello.go文件所在的包是main，在go中，每个文件都归属与一个包</li>\n<li>import &quot;fmt&quot;：表示引入一个包，可以调用里面的函数</li>\n<li>func main()：表示程序入口，是一个主函数</li>\n</ul>\n<p>输出结果</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/1/14/1610608176715.png\" alt=\"image-20200718151850083\" /></p>\n<h2>编译和执行</h2>\n<p>我们可以通过使用下面命令进行编译和执行</p>\n<pre><code class=\"language-bash\"># 编译 hello.go 后 会生成一个 hello.exe文件\ngo build hello.go\n# 运行 hello.ext\nhello.ext\n</code></pre>\n<p>需要注意的是，我们也可以使用下面的方式，来直接运行的（使用go run会比较慢，因为内部有个编译的过程）</p>\n<pre><code class=\"language-bash\">go run hello.go\n</code></pre>\n<p>但是在生产环境中，是需要先编译在执行的</p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 0, 0, 'd134bdfe255b9aa8c2ce44da8297f6a6', 1, '2021-01-14 15:09:39', '2021-01-14 15:09:39', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '0', 0, 1, 0, NULL, 39, NULL, 0);
INSERT INTO `t_blog` VALUES ('9d7a6531cd55f415a0b26712f6fecc7a', '【JVM】垃圾回收相关概念', '【JVM】垃圾回收相关概念', '<h1 id=\"垃圾回收相关概念\">垃圾回收相关概念</h1>\n<h2 id=\"System-gc--的理解\">System.gc()的理解</h2>\n<p>在默认情况下，通过system.gc（）者Runtime.getRuntime().gc() 的调用，会显式触发FullGC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p>\n<p>然而system.gc() )调用附带一个免责声明，无法保证对垃圾收集器的调用。(不能确保立即生效)</p>\n<p>JVM实现者可以通过system.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()</p>\n<p>代码演示是否出发GC操作</p>\n<pre><code class=\"language-java\">/**\n * System.gc()\n *\n * @author: 陌溪\n * @create: 2020-07-12-19:07\n */\npublic class SystemGCTest {\n    public static void main(String[] args) {\n        new SystemGCTest();\n        // 提醒JVM进行垃圾回收\n        System.gc();\n        //System.runFinalization();\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        System.out.println(&quot;SystemGCTest 执行了 finalize方法&quot;);\n    }\n}\n\n</code></pre>\n<p>运行结果，但是不一定会触发销毁的方法，调用System.runFinalization()会强制调用 失去引用对象的finalize()</p>\n<pre><code>SystemGCTest 执行了 finalize方法\n\n</code></pre>\n<h3 id=\"手动GC来理解不可达对象的回收\">手动GC来理解不可达对象的回收</h3>\n<p>代码如下所示：</p>\n<pre><code class=\"language-java\">/**\n * 局部变量回收\n *\n * @author: 陌溪\n * @create: 2020-07-12-19:12\n */\npublic class LocalVarGC {\n\n    /**\n     * 触发Minor GC没有回收对象，然后在触发Full GC将该对象存入old区\n     */\n    public void localvarGC1() {\n        byte[] buffer = new byte[10*1024*1024];\n        System.gc();\n    }\n\n    /**\n     * 触发YoungGC的时候，已经被回收了\n     */\n    public void localvarGC2() {\n        byte[] buffer = new byte[10*1024*1024];\n        buffer = null;\n        System.gc();\n    }\n\n    /**\n     * 不会被回收，因为它还存放在局部变量表索引为1的槽中\n     */\n    public void localvarGC3() {\n        {\n            byte[] buffer = new byte[10*1024*1024];\n        }\n        System.gc();\n    }\n\n    /**\n     * 会被回收，因为它还存放在局部变量表索引为1的槽中，但是后面定义的value把这个槽给替换了\n     */\n    public void localvarGC4() {\n        {\n            byte[] buffer = new byte[10*1024*1024];\n        }\n        int value = 10;\n        System.gc();\n    }\n\n    /**\n     * localvarGC5中的数组已经被回收\n     */\n    public void localvarGC5() {\n        localvarGC1();\n        System.gc();\n    }\n\n    public static void main(String[] args) {\n        LocalVarGC localVarGC = new LocalVarGC();\n        localVarGC.localvarGC3();\n    }\n}\n\n</code></pre>\n<h2 id=\"内存溢出\">内存溢出</h2>\n<p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p>\n<p>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现ooM的情况。</p>\n<p>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Fu11GC操作，这时候会回收大量的内存，供应用程序继续使用。</p>\n<p>javadoc中对outofMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</p>\n<p>首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：</p>\n<ul>\n<li>Java虚拟机的堆内存设置不够。</li>\n</ul>\n<p>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。</p>\n<ul>\n<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</li>\n</ul>\n<p>对于老版本的oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space&quot;。</p>\n<p>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的ooM有所改观，出现ooM，异常信息则变成了：“java.lang.OutofMemoryError:Metaspace&quot;。直接内存不足，也会导致OOM。</p>\n<p>这里面隐含着一层意思是，在抛出OutofMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p>\n<blockquote>\n<p>例如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。 在java.nio.BIts.reserveMemory（）方法中，我们能清楚的看到，System.gc（）会被调用，以清理空间。</p>\n</blockquote>\n<p>当然，也不是在任何情况下垃圾收集器都会被触发的</p>\n<p>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。</p>\n<h2 id=\"内存泄漏\">内存泄漏</h2>\n<p>也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</p>\n<p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致00M，也可以叫做宽泛意义上的“内存泄漏”。</p>\n<p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现outofMemory异常，导致程序崩溃。</p>\n<p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p>\n<blockquote>\n<p>买房子：80平的房子，但是有10平是公摊的面积，我们是无法使用这10平的空间，这就是所谓的内存泄漏</p>\n</blockquote>\n<p><img src=\"http://image.moguit.cn/046b13313dee4023bc580c1943e46008\" alt=\"image-20200712195158470\" /></p>\n<p>Java使用可达性分析算法，最上面的数据不可达，就是需要被回收的。后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开，从而导致没有办法被回收。</p>\n<h3 id=\"举例\">举例</h3>\n<ul>\n<li>单例模式</li>\n</ul>\n<p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p>\n<ul>\n<li>一些提供close的资源未关闭导致内存泄漏</li>\n</ul>\n<p>数据库连接（dataSourse.getConnection() ），网络连接（socket）和io连接必须手动close，否则是不能被回收的。</p>\n<h2 id=\"Stop-The-World\">Stop The World</h2>\n<p>stop-the-world，简称STw，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p>\n<p>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。</p>\n<ul>\n<li>分析工作必须在一个能确保一致性的快照中进行</li>\n<li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li>\n<li>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</li>\n</ul>\n<p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STw的发生。</p>\n<p>STW事件和采用哪款GC无关所有的GC都有这个事件。</p>\n<p>哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p>\n<p>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p>\n<p>开发中不要用system.gc() 会导致stop-the-world的发生。</p>\n<h2 id=\"垃圾回收的并行与并发\">垃圾回收的并行与并发</h2>\n<h3 id=\"并发\">并发</h3>\n<p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</p>\n<p>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</p>\n<p><img src=\"http://image.moguit.cn/0f4dfad3e0f14f2bbb7329f4533e2dc8\" alt=\"image-20200712202522051\" /></p>\n<h3 id=\"并行\">并行</h3>\n<p>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行（Paralle1）。</p>\n<p>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。</p>\n<p>适合科学计算，后台处理等弱交互场景</p>\n<p><img src=\"http://image.moguit.cn/2340ed2b3f6047f5b34fc4cc52cc9d0f\" alt=\"image-20200712202822129\" /></p>\n<h3 id=\"并发和并行对比\">并发和并行对比</h3>\n<p><strong>并发</strong>，指的是多个事情，在同一时间段内同时发生了。</p>\n<p><strong>并行</strong>，指的是多个事情，在同一时间点上同时发生了。</p>\n<p>并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的。</p>\n<p>只有在多CPU或者一个CPU多核的情况中，才会发生并行。</p>\n<p>否则，看似同时发生的事情，其实都是并发执行的。</p>\n<h3 id=\"垃圾回收的并行与并发-\">垃圾回收的并行与并发</h3>\n<p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p>\n<ul>\n<li>并行（Paralle1）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。如ParNew、Parallel Scavenge、Parallel old；</li>\n<li>串行（Serial）\n<ul>\n<li>相较于并行的概念，单线程执行。</li>\n<li>如果内存不够，则程序暂停，启动JM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://image.moguit.cn/9472580fa84a4ac5946c7144986436e5\" alt=\"image-20200712203607845\" /></p>\n<p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p>\n<p>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。&gt;用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；</p>\n<blockquote>\n<p>如：CMS、G1</p>\n</blockquote>\n<p><img src=\"http://image.moguit.cn/74acc61000e844ca88edecd38720c5e1\" alt=\"image-20200712203815517\" /></p>\n<h2 id=\"安全点与安全区域\">安全点与安全区域</h2>\n<h3 id=\"安全点\">安全点</h3>\n<p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。</p>\n<p>Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。</p>\n<p>如何在cc发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p>\n<ul>\n<li><strong>抢先式中断</strong>：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li>\n<li><strong>主动式中断</strong>：设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）</li>\n</ul>\n<h3 id=\"安全区域\">安全区域</h3>\n<p>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？例如线程处于sleep-状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p>\n<p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始Gc都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。</p>\n<p><strong>执行流程：</strong></p>\n<ul>\n<li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Relgion，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程</li>\n<li>当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；</li>\n</ul>\n<h2 id=\"再谈引用\">再谈引用</h2>\n<p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p>\n<p>【既偏门又非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？ 在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：</p>\n<ul>\n<li>强引用（Strong Reference）</li>\n<li>软引用（Soft Reference）</li>\n<li>弱引用（Weak Reference）</li>\n<li>虚引用（Phantom Reference）</li>\n</ul>\n<p>这4种引用强度依次逐渐减弱。除强引用外，其他3种引用均可以在java.1ang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p>\n<p>.<img src=\"http://image.moguit.cn/6105615a5ecf4e47a77b96f8a52de0c2\" alt=\"image-20200712205813321\" /></p>\n<p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p>\n<ul>\n<li>强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“object obj=new Object（）”这种引用关系。无论任何情况下，==只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象==。</li>\n<li>软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存流出异常。</li>\n<li>弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li>\n<li>虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。==为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知==。</li>\n</ul>\n<h2 id=\"再谈引用-强引用\">再谈引用：强引用</h2>\n<p>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。</p>\n<p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p>\n<p>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</p>\n<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为nu11，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>\n<p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。</p>\n<h3 id=\"举例-\">举例</h3>\n<p>强引用的案例说明</p>\n<pre><code class=\"language-java\">StringBuffer str = new StringBuffer(&quot;hello mogublog&quot;);\n\n</code></pre>\n<p>局部变量str指向stringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是stringBuffer实例的强引用对应内存结构：</p>\n<p><img src=\"http://image.moguit.cn/6630ccac8d024a68be11c02811592741\" alt=\"image-20200712211501377\" /></p>\n<p>如果此时，在运行一个赋值语句</p>\n<pre><code class=\"language-java\">StringBuffer str = new StringBuffer(&quot;hello mogublog&quot;);\nStringBuffer str1 = str;\n\n</code></pre>\n<p>对应的内存结构为:</p>\n<p><img src=\"http://image.moguit.cn/fad5c54af6674a5b8231404ee0a69ac2\" alt=\"image-20200712211732976\" /></p>\n<p>那么我们将 str = null; 则 原来堆中的对象也不会被回收，因为还有其它对象指向该区域</p>\n<h3 id=\"总结\">总结</h3>\n<p>本例中的两个引用，都是强引用，强引用具备以下特点：</p>\n<ul>\n<li>强引用可以直接访问目标对象。</li>\n<li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</li>\n<li>强引用可能导致内存泄漏。</li>\n</ul>\n<h2 id=\"再谈引用--软引用\">再谈引用： 软引用</h2>\n<p>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>\n<blockquote>\n<p>注意，这里的第一次回收是不可达的对象</p>\n</blockquote>\n<p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>\n<p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p>\n<p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p>\n<blockquote>\n<p>一句话概括：当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象</p>\n</blockquote>\n<p>在JDK1.2版之后提供了SoftReference类来实现软引用</p>\n<pre><code class=\"language-java\">// 声明强引用\nObject obj = new Object();\n// 创建一个软引用\nSoftReference&lt;Object&gt; sf = new SoftReference&lt;&gt;(obj);\nobj = null; //销毁强引用，这是必须的，不然会存在强引用和软引用\n\n</code></pre>\n<h2 id=\"再谈引用-弱引用\">再谈引用：弱引用</h2>\n<blockquote>\n<p>发现即回收</p>\n</blockquote>\n<p>弱引用也是用来描述那些非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p>\n<p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p>\n<p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>\n<p>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p>\n<p>在JDK1.2版之后提供了WeakReference类来实现弱引用</p>\n<pre><code class=\"language-java\">// 声明强引用\nObject obj = new Object();\n// 创建一个弱引用\nWeakReference&lt;Object&gt; sf = new WeakReference&lt;&gt;(obj);\nobj = null; //销毁强引用，这是必须的，不然会存在强引用和弱引用\n\n</code></pre>\n<p>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。</p>\n<p>面试题：你开发中使用过WeakHashMap吗？</p>\n<p>WeakHashMap用来存储图片信息，可以在内存不足的时候，及时回收，避免了OOM</p>\n<h2 id=\"再谈引用-虚引用\">再谈引用：虚引用</h2>\n<p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个</p>\n<p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>\n<p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get（）方法取得对象时，总是null</p>\n<p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</p>\n<p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p>\n<p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p>\n<blockquote>\n<p>虚引用无法获取到我们的数据</p>\n</blockquote>\n<p>在JDK1.2版之后提供了PhantomReference类来实现虚引用。</p>\n<pre><code class=\"language-java\">// 声明强引用\nObject obj = new Object();\n// 声明引用队列\nReferenceQueue phantomQueue = new ReferenceQueue();\n// 声明虚引用（还需要传入引用队列）\nPhantomReference&lt;Object&gt; sf = new PhantomReference&lt;&gt;(obj, phantomQueue);\nobj = null; \n\n</code></pre>\n<h3 id=\"案例\">案例</h3>\n<p>我们使用一个案例，来结合虚引用，引用队列，finalize进行讲解</p>\n<pre><code class=\"language-java\">/**\n * @author: 陌溪\n * @create: 2020-07-12-21:42\n */\npublic class PhantomReferenceTest {\n    // 当前类对象的声明\n    public static PhantomReferenceTest obj;\n    // 引用队列\n    static ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = null;\n\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        System.out.println(&quot;调用当前类的finalize方法&quot;);\n        obj = this;\n    }\n\n    public static void main(String[] args) {\n        Thread thread = new Thread(() -&gt; {\n            while(true) {\n                if (phantomQueue != null) {\n                    PhantomReference&lt;PhantomReferenceTest&gt; objt = null;\n                    try {\n                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();\n                    } catch (Exception e) {\n                        e.getStackTrace();\n                    }\n                    if (objt != null) {\n                        System.out.println(&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;);\n                    }\n                }\n            }\n        }, &quot;t1&quot;);\n        thread.setDaemon(true);\n        thread.start();\n\n        phantomQueue = new ReferenceQueue&lt;&gt;();\n        obj = new PhantomReferenceTest();\n        // 构造了PhantomReferenceTest对象的虚引用，并指定了引用队列\n        PhantomReference&lt;PhantomReferenceTest&gt; phantomReference = new PhantomReference&lt;&gt;(obj, phantomQueue);\n        try {\n            System.out.println(phantomReference.get());\n            // 去除强引用\n            obj = null;\n            // 第一次进行GC，由于对象可复活，GC无法回收该对象\n            System.out.println(&quot;第一次GC操作&quot;);\n            System.gc();\n            Thread.sleep(1000);\n            if (obj == null) {\n                System.out.println(&quot;obj 是 null&quot;);\n            } else {\n                System.out.println(&quot;obj 不是 null&quot;);\n            }\n            System.out.println(&quot;第二次GC操作&quot;);\n            obj = null;\n            System.gc();\n            Thread.sleep(1000);\n            if (obj == null) {\n                System.out.println(&quot;obj 是 null&quot;);\n            } else {\n                System.out.println(&quot;obj 不是 null&quot;);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n\n        }\n    }\n}\n\n</code></pre>\n<p>最后运行结果</p>\n<pre><code class=\"language-java\">null\n第一次GC操作\n调用当前类的finalize方法\nobj 不是 null\n第二次GC操作\n追踪垃圾回收过程：PhantomReferenceTest实例被GC了\nobj 是 null\n\n</code></pre>\n<p>从上述运行结果我们知道，第一次尝试获取虚引用的值，发现无法获取的，这是因为虚引用是无法直接获取对象的值，然后进行第一次gc，因为会调用finalize方法，将对象复活了，所以对象没有被回收，但是调用第二次gc操作的时候，因为finalize方法只能执行一次，所以就触发了GC操作，将对象回收了，同时将会触发第二个操作就是 将回收的值存入到引用队列中。</p>\n<h2 id=\"终结器引用\">终结器引用</h2>\n<p>它用于实现对象的finalize() 方法，也可以称为终结器引用</p>\n<p>无需手动编码，其内部配合引用队列使用</p>\n<p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象</p>\n', '7e0e93ea6cdb44ae92e58f48e6496ed7,15721a34adba068763b5a2fb1991fc57,5626932d452c2ad863d9b3cb0b69d22d', 21, 1, '3dab9866f9ac1867d3845918d4b5b748', 1, '2020-08-17 01:19:35', '2020-12-26 16:01:52', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', 'db0d64ea7df409de5d2d747927cfa1a5', 0, '1', 0, 1, 0, NULL, 19, NULL, 0);
INSERT INTO `t_blog` VALUES ('9fa1fcd046b6cddb67c7859d050aeecd', '标题', '标题', '<h1>CentOS下安装Nacos</h1>\n\n<h2>前言</h2>\n\n<p>这阵子因为蘑菇博客的镜像越来越大，所以就打算重新构建一下蘑菇博客的Docker镜像，这里就打算在Centos下安装配置Nacos，之前写过一篇博客关于Window下配置蘑菇博客的Nacos，感兴趣的小伙伴可以参考一下</p>\n\n<p><a href=\"http://moguit.cn/#/info?blogUid=8dc52bd61e36fa56cfc7699815375572\">Window蘑菇博客Nacos部署指南</a></p>\n\n<p><a href=\"http://moguit.cn/#/info?blogUid=e6e619349d31dded928c9265c5a9c672\">【SpringCloud】使用Nacos实现服务注册发现以及配置中心等功能</a></p>\n\n<h2>下载Linux版Nacos</h2>\n\n<p>首先我们到Nacos的 <a href=\"https://github.com/alibaba/nacos/releases\">Github页面</a>，找到我们需要安装的版本</p>\n\n<p><img alt=\"image-20200822112106696\" src=\"http://image.moguit.cn/24b2f2832d764c58ace6fe4761a9bb14\" /></p>\n\n<p>我们也可以右键复制到链接，然后通过wget命令进行下载</p>\n\n<pre>\n<code class=\"language-bash\">wget https://github.com/alibaba/nacos/releases/download/1.3.2/nacos-server-1.3.2.tar.gz\n\n\n\n</code></pre>\n\n<p>下载完成后，我们使用下面的命令进行解压</p>\n\n<pre>\n<code class=\"language-bash\">#解压\ntar -zxvf nacos-server-1.3.2.tar.gz\n\n\n\n</code></pre>\n\n<p>解压完成后，进入nacos文件夹里</p>\n\n<pre>\n<code class=\"language-bash\">cd nacos/bin\n\n\n\n</code></pre>\n\n<p>然后修改startup.sh中jvm的内存大小，根据自己的机器情况决定。</p>\n\n<pre>\n<code class=\"language-bash\">vim startup.sh\n\n\n\n</code></pre>\n\n<p>这里我设置的是最小堆内存128m，最大堆内存256m</p>\n\n<pre>\n<code class=\"language-bash\">if [[ \"${MODE}\" == \"standalone\" ]]; then\n    JAVA_OPT=\"${JAVA_OPT} -Xms128m -Xmx256m -Xmn256m\"\n    JAVA_OPT=\"${JAVA_OPT} -Dnacos.standalone=true\"\nelse\n    if [[ \"${EMBEDDED_STORAGE}\" == \"embedded\" ]]; then\n        JAVA_OPT=\"${JAVA_OPT} -DembeddedStorage=true\"\n    fi\n    JAVA_OPT=\"${JAVA_OPT} -server -Xms256m -Xmx512m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m\"\n    JAVA_OPT=\"${JAVA_OPT} -XX:-OmitStackTraceInFastThrow -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=${BASE_DIR}/logs/java_heapdump.hprof\"\n    JAVA_OPT=\"${JAVA_OPT} -XX:-UseLargePages\"\n\n\n\n</code></pre>\n\n<h2>Nacos+MySQL配置持久化</h2>\n\n<p>原来的配置文件是存储在内置的数据库SQLite中，我们如果要移动起来，可能不方便，下面我们可以配置一下nacos的mysql存储，</p>\n\n<p>我们找到数据库新建脚本nacos/conf/nacos-mysql.sql，创建数据库nacos_config并执行脚本</p>\n\n<h3>导入遇到问题</h3>\n\n<p>tip：我们在导入的时候，可能会遇到这个错误</p>\n\n<blockquote>\n<p>Error occured at:2020-08-22 11:37:11 Line no.:190 Error Code: 1071 - Specified key was too long; max key length is 767 bytes</p>\n</blockquote>\n\n<p>先检查一下是不是数据库被限制了索引的大小</p>\n\n<pre>\n<code>SHOW variables like \'innodb_large_prefix\'\n\n\n\n</code></pre>\n\n<p>如果查询的值是OFF的话 执行下面命令</p>\n\n<pre>\n<code>SET GLOBAL INNODB_LARGE_PREFIX = ON;\n\n\n\n</code></pre>\n\n<p>执行完了 之后 还得查看当前的innodb_file_format引擎格式类型是不是BARRACUDA执行</p>\n\n<pre>\n<code>SHOW variables like \'innodb_file_format\'\n\n\n\n</code></pre>\n\n<p>如果不是的话则需要修改</p>\n\n<pre>\n<code>SET GLOBAL innodb_file_format = BARRACUDA;\n\n\n\n</code></pre>\n\n<p>然后再次尝试导入，则成功导入到数据库中</p>\n\n<h3>修改nacos配置</h3>\n\n<p>下面我们需要到nacos的配置目录</p>\n\n<pre>\n<code class=\"language-bash\">vim nacos/conf/application.properties\n\n\n\n</code></pre>\n\n<p>然后在末尾添加我们的mysql的配置信息</p>\n\n<pre>\n<code class=\"language-bash\">spring.datasource.platform=mysql\ndb.num=1\ndb.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC\ndb.user=root\ndb.password=mogu2018\n\n\n\n</code></pre>\n\n<p>修改完成后，回到bin目录，启动nacos，启动命令standalone代表着单机模式运行，非集群模式):</p>\n\n<pre>\n<code class=\"language-bash\">sh startup.sh -m standalone\n\n\n\n</code></pre>\n\n<p>然后我们输入地址</p>\n\n<pre>\n<code class=\"language-bash\">http://youip:8848/nacos\n\n\n\n</code></pre>\n\n<p>会跳转到登录页面，输入默认账号和密码 nacos nacos即可进入</p>\n\n<p><img alt=\"image-20200822115650579\" src=\"http://image.moguit.cn/217b883c57a14927b1138c9b8b981ac3\" /></p>\n\n<p>到这里linux下的nacos已经成功安装~</p>\n\n<p><img alt=\"image-20200822120856725\" src=\"http://image.moguit.cn/05cdd82ee6cf4f628dd61152649383cb\" /></p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 0, 0, '7086872f5fd4647152291a2c7dc0d3b3', 1, '2020-10-13 08:37:20', '2021-04-12 16:20:43', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 1, '1', 3, 1, 0, NULL, 20, NULL, 0);
INSERT INTO `t_blog` VALUES ('b0e6353c7031c3248b5666303164f14e', '【JVM】垃圾回收相关算法', '【JVM】垃圾回收相关算法', '<h1>垃圾回收相关算法</h1>\n\n<h2>标记阶段：引用计数算法</h2>\n\n<p>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</p>\n\n<p>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p>\n\n<p>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法。</strong></p>\n\n<p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</p>\n\n<p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p>\n\n<p>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</p>\n\n<p>缺点：它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。</p>\n\n<blockquote>\n<p>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</p>\n</blockquote>\n\n<h3>循环引用</h3>\n\n<p>当p的指针断开的时候，内部的引用形成一个循环，这就是循环引用，从而造成内存泄漏</p>\n\n<p><img alt=\"image-20200712102205795\" src=\"http://image.moguit.cn/d9be5130f1094f3a8591e924c050c253\" /></p>\n\n<h3>举例</h3>\n\n<p>我们使用一个案例来测试Java中是否采用的是引用计数算法</p>\n\n<pre>\n<code class=\"language-java\">/**\n * 引用计数算法测试\n *\n * @author: 陌溪\n * @create: 2020-07-12-10:26\n */\npublic class RefCountGC {\n    // 这个成员属性的唯一作用就是占用一点内存\n    private byte[] bigSize = new byte[5*1024*1024];\n    // 引用\n    Object reference = null;\n\n    public static void main(String[] args) {\n        RefCountGC obj1 = new RefCountGC();\n        RefCountGC obj2 = new RefCountGC();\n        obj1.reference = obj2;\n        obj2.reference = obj1;\n        obj1 = null;\n        obj2 = null;\n        // 显示的执行垃圾收集行为，判断obj1 和 obj2是否被回收？\n        System.gc();\n    }\n}\n</code></pre>\n\n<p>运行结果</p>\n\n<pre>\n<code>[GC (System.gc()) [PSYoungGen: 15490K-&gt;808K(76288K)] 15490K-&gt;816K(251392K), 0.0061980 secs] [Times: user=0.00 sys=0.00, real=0.36 secs] \n[Full GC (System.gc()) [PSYoungGen: 808K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;672K(175104K)] 816K-&gt;672K(251392K), [Metaspace: 3479K-&gt;3479K(1056768K)], 0.0045983 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \nHeap\n PSYoungGen      total 76288K, used 655K [0x000000076b500000, 0x0000000770a00000, 0x00000007c0000000)\n  eden space 65536K, 1% used [0x000000076b500000,0x000000076b5a3ee8,0x000000076f500000)\n  from space 10752K, 0% used [0x000000076f500000,0x000000076f500000,0x000000076ff80000)\n  to   space 10752K, 0% used [0x000000076ff80000,0x000000076ff80000,0x0000000770a00000)\n ParOldGen       total 175104K, used 672K [0x00000006c1e00000, 0x00000006cc900000, 0x000000076b500000)\n  object space 175104K, 0% used [0x00000006c1e00000,0x00000006c1ea8070,0x00000006cc900000)\n Metaspace       used 3486K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 385K, capacity 388K, committed 512K, reserved 1048576K\n</code></pre>\n\n<p>我们能够看到，上述进行了GC收集的行为，将上述的新生代中的两个对象都进行回收了</p>\n\n<pre>\n<code>PSYoungGen: 15490K-&gt;808K(76288K)] 15490K-&gt;816K(251392K)\n</code></pre>\n\n<p>如果使用引用计数算法，那么这两个对象将会无法回收。而现在两个对象被回收了，说明Java使用的不是引用计数算法来进行标记的。</p>\n\n<p><img alt=\"image-20200712103230349\" src=\"http://image.moguit.cn/19ff61c8b6e94ac788adcbf2b6a29229\" /></p>\n\n<h3>小结</h3>\n\n<p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</p>\n\n<p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p>\n\n<p>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。Python如何解决循环引用？</p>\n\n<blockquote>\n<p>手动解除：很好理解，就是在合适的时机，解除引用关系。 使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</p>\n</blockquote>\n\n<h2>标记阶段：可达性分析算法</h2>\n\n<h3>概念</h3>\n\n<p>可达性分析算法：也可以称为 根搜索算法、追踪性垃圾收集</p>\n\n<p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</p>\n\n<p>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）</p>\n\n<h3>思路</h3>\n\n<p>所谓&quot;GCRoots&rdquo;根集合就是一组必须活跃的引用。</p>\n\n<p>基本思路：</p>\n\n<ul>\n	<li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li>\n	<li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）</li>\n	<li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li>\n	<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li>\n</ul>\n\n<p><img alt=\"image-20200712104149246\" src=\"http://image.moguit.cn/6b260e7b92b1416da0ec37014dc7f7e3\" /></p>\n\n<p>官场上的裙带关系，可达性分析在人类关系网中</p>\n\n<p><img alt=\"image-20200712104312406\" src=\"http://image.moguit.cn/308db7e5cf8c42089581d22ebac92121\" /></p>\n\n<h3>GC Roots可以是哪些？</h3>\n\n<ul>\n	<li>虚拟机栈中引用的对象\n	<ul>\n		<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>\n	</ul>\n	</li>\n	<li>本地方法栈内JNI（通常说的本地方法）引用的对象方法区中类静态属性引用的对象\n	<ul>\n		<li>比如：Java类的引用类型静态变量</li>\n	</ul>\n	</li>\n	<li>方法区中常量引用的对象\n	<ul>\n		<li>比如：字符串常量池（string Table）里的引用</li>\n	</ul>\n	</li>\n	<li>所有被同步锁synchronized持有的对象</li>\n	<li>Java虚拟机内部的引用。\n	<ul>\n		<li>基本数据类型对应的Class对象，一些常驻的异常对象（如：Nu11PointerException、outofMemoryError），系统类加载器。</li>\n	</ul>\n	</li>\n	<li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>\n</ul>\n\n<p><img alt=\"image-20200712104622677\" src=\"http://image.moguit.cn/a75b0c204d2043939823e0c93a3f0c84\" /></p>\n\n<h4>总结</h4>\n\n<p>总结一句话就是，除了堆空间外的一些结构，比如 虚拟机栈、本地方法栈、方法区、字符串常量池 等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析</p>\n\n<p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象&ldquo;临时性&rdquo;地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（PartialGC）。</p>\n\n<p>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GCRoots集合中去考虑，才能保证可达性分析的准确性。</p>\n\n<h4>小技巧</h4>\n\n<p>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</p>\n\n<h3>注意</h3>\n\n<p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p>\n\n<p>这点也是导致GC进行时必须&ldquo;stop The World&rdquo;的一个重要原因。</p>\n\n<p>即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p>\n\n<h2>对象的finalization机制</h2>\n\n<p>Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p>\n\n<p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</p>\n\n<p>finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p>\n\n<h3>注意</h3>\n\n<p>永远不要主动调用某个对象的finalize（）方法I应该交给垃圾回收机制调用。理由包括下面三点：</p>\n\n<ul>\n	<li>在finalize（）时可能会导致对象复活。</li>\n	<li>finalize（）方法的执行时间是没有保障的，它完全由Gc线程决定，极端情况下，若不发生GC，则finalize（）方法将没有执行机会。\n	<ul>\n		<li>因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li>\n	</ul>\n	</li>\n	<li>一个糟糕的finalize（）会严重影响Gc的性能。</li>\n</ul>\n\n<p>从功能上来说，finalize（）方法与c++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize（）方法在本质上不同于C++中的析构函数。</p>\n\n<p>由于finalize（）方法的存在，虚拟机中的对象一般处于三种可能的状态。</p>\n\n<h3>生存还是死亡？</h3>\n\n<p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是&ldquo;非死不可&rdquo;的，这时候它们暂时处于&ldquo;缓刑&rdquo;阶段。<strong>一个无法触及的对象有可能在某一个条件下&ldquo;复活&rdquo;自己</strong>，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p>\n\n<ul>\n	<li>可触及的：从根节点开始，可以到达这个对象。</li>\n	<li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize（）中复活。</li>\n	<li>不可触及的：对象的finalize（）被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为<strong>finalize()只会被调用一次</strong>。</li>\n</ul>\n\n<p>以上3种状态中，是由于finalize（）方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p>\n\n<h3>具体过程</h3>\n\n<p>判定一个对象objA是否可回收，至少要经历两次标记过程：</p>\n\n<ul>\n	<li>\n	<p>如果对象objA到GC Roots没有引用链，则进行第一次标记。</p>\n	</li>\n	<li>\n	<p>进行筛选，判断此对象是否有必要执行finalize（）方法</p>\n\n	<ul>\n		<li>如果对象objA没有重写finalize（）方法，或者finalize（）方法已经被虚拟机调用过，则虚拟机视为&ldquo;没有必要执行&rdquo;，objA被判定为不可触及的。</li>\n		<li>如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。</li>\n		<li>finalize（）方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出&ldquo;即将回收&rdquo;集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</li>\n	</ul>\n	</li>\n</ul>\n\n<p><img alt=\"image-20200712110411885\" src=\"http://image.moguit.cn/d828a8387ad9443bab6b6274f835806a\" /></p>\n\n<p>上图就是我们看到的Finalizer线程</p>\n\n<h3>代码演示</h3>\n\n<p>我们使用重写 finalize()方法，然后在方法的内部，重写将其存放到GC Roots中</p>\n\n<pre>\n<code class=\"language-java\">/**\n * 测试Object类中finalize()方法\n * 对象复活场景\n *\n * @author: 陌溪\n * @create: 2020-07-12-11:06\n */\npublic class CanReliveObj {\n    // 类变量，属于GC Roots的一部分\n    public static CanReliveObj canReliveObj;\n\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        System.out.println(\"调用当前类重写的finalize()方法\");\n        canReliveObj = this;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        canReliveObj = new CanReliveObj();\n        canReliveObj = null;\n        System.gc();\n        System.out.println(\"-----------------第一次gc操作------------\");\n        // 因为Finalizer线程的优先级比较低，暂停2秒，以等待它\n        Thread.sleep(2000);\n        if (canReliveObj == null) {\n            System.out.println(\"obj is dead\");\n        } else {\n            System.out.println(\"obj is still alive\");\n        }\n\n        System.out.println(\"-----------------第二次gc操作------------\");\n        canReliveObj = null;\n        System.gc();\n        // 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了\n        Thread.sleep(2000);\n        if (canReliveObj == null) {\n            System.out.println(\"obj is dead\");\n        } else {\n            System.out.println(\"obj is still alive\");\n        }\n\n    }\n}\n</code></pre>\n\n<p>最后运行结果</p>\n\n<pre>\n<code>-----------------第一次gc操作------------\n调用当前类重写的finalize()方法\nobj is still alive\n-----------------第二次gc操作------------\nobj is dead\n</code></pre>\n\n<p>在进行第一次清除的时候，我们会执行finalize方法，然后 对象 进行了一次自救操作，但是因为finalize()方法只会被调用一次，因此第二次该对象将会被垃圾清除。</p>\n\n<h2>MAT与JProfiler的GC Roots溯源</h2>\n\n<h3>MAT是什么？</h3>\n\n<p>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</p>\n\n<p>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</p>\n\n<p>大家可以在http://www.eclipse.org/mat/下载并使用MAT</p>\n\n<h3>命令行使用 jmap</h3>\n\n<p><img alt=\"image-20200712112026317\" src=\"http://image.moguit.cn/acb49ce72eed4f9fad85a9a1e0816bdd\" /></p>\n\n<h3>使用JVIsualVM</h3>\n\n<p>捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。可通过以下方法捕获heap dump：</p>\n\n<p>在左侧&ldquo;Application&quot;（应用程序）子窗口中右击相应的应用程序，选择Heap Dump（堆Dump）。</p>\n\n<p>在Monitor（监视）子标签页中点击Heap Dump（堆Dump）按钮。本地应用程序的Heap dumps作为应用程序标签页的一个子标签页打开。同时，heap dump在左侧的Application（应用程序）栏中对应一个含有时间戳的节点。</p>\n\n<p>右击这个节点选择save as（另存为）即可将heap dump保存到本地。</p>\n\n<h3>使用MAT打开Dump文件</h3>\n\n<p>打开后，我们就可以看到有哪些可以作为GC Roots的对象</p>\n\n<p><img alt=\"image-20200712112512720\" src=\"http://image.moguit.cn/3f05998394914594a8fa1692e3bb1cbe\" /></p>\n\n<p>里面我们能够看到有一些常用的Java类，然后Thread线程。</p>\n\n<h3>JProfiler的GC Roots溯源</h3>\n\n<p>我们在实际的开发中，一般不会查找全部的GC Roots，可能只是查找某个对象的整个链路，或者称为GC Roots溯源，这个时候，我们就可以使用JProfiler</p>\n\n<p><img alt=\"image-20200712113256075\" src=\"http://image.moguit.cn/9675c82690c24bf0a08d3571a05804bb\" /></p>\n\n<h3>如何判断什么原因造成OOM</h3>\n\n<p>当我们程序出现OOM的时候，我们就需要进行排查，我们首先使用下面的例子进行说明</p>\n\n<pre>\n<code class=\"language-java\">/**\n * 内存溢出排查\n * -Xms8m -Xmx8m -XX:HeapDumpOnOutOfMemoryError\n * @author: 陌溪\n * @create: 2020-07-12-14:56\n */\npublic class HeapOOM {\n    // 创建1M的文件\n    byte [] buffer = new byte[1 * 1024 * 1024];\n\n    public static void main(String[] args) {\n        ArrayList&lt;HeapOOM&gt; list = new ArrayList&lt;&gt;();\n        int count = 0;\n        try {\n            while (true) {\n                list.add(new HeapOOM());\n                count++;\n            }\n        } catch (Exception e) {\n            e.getStackTrace();\n            System.out.println(\"count:\" + count);\n        }\n    }\n}\n</code></pre>\n\n<p>上述代码就是不断的创建一个1M小字节数组，然后让内存溢出，我们需要限制一下内存大小，同时使用HeapDumpOnOutOfMemoryError将出错时候的dump文件输出</p>\n\n<pre>\n<code>-Xms8m -Xmx8m -XX:HeapDumpOnOutOfMemoryError\n</code></pre>\n\n<p>我们将生成的dump文件打开，然后点击Biggest Objects就能够看到超大对象</p>\n\n<p><img alt=\"image-20200712150229048\" src=\"http://image.moguit.cn/298bb0a427ee4a03a45c907fffbd4d1a\" /></p>\n\n<p>然后我们通过线程，还能够定位到哪里出现OOM</p>\n\n<p><img alt=\"image-20200712150303710\" src=\"http://image.moguit.cn/12ca7a3058364a7d947b61ead19bb923\" /></p>\n\n<h2>清除阶段：标记-清除算法</h2>\n\n<p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是</p>\n\n<ul>\n	<li>标记一清除算法（Mark-Sweep）</li>\n	<li>复制算法（copying）</li>\n	<li>标记-压缩算法（Mark-Compact）</li>\n</ul>\n\n<p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p>\n\n<h3>执行过程</h3>\n\n<p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p>\n\n<ul>\n	<li><strong>标记</strong>：Collector从引用根节点开始遍历，<strong>标记所有被引用的对象</strong>。一般是在对象的Header中记录为可达对象。\n\n	<ul>\n		<li><strong>标记的是引用的对象，不是垃圾！！</strong></li>\n	</ul>\n	</li>\n	<li><strong>清除</strong>：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li>\n</ul>\n\n<p><img alt=\"image-20200712150935078\" src=\"http://image.moguit.cn/dfda028dbb924ed58cb0b1a95637da1b\" /></p>\n\n<h3>什么是清除？</h3>\n\n<p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</p>\n\n<p>关于空闲列表是在为对象分配内存的时候 提过</p>\n\n<ul>\n	<li>如果内存规整\n	<ul>\n		<li>采用指针碰撞的方式进行内存分配</li>\n	</ul>\n	</li>\n	<li>如果内存不规整\n	<ul>\n		<li>虚拟机需要维护一个列表</li>\n		<li>空闲列表分配</li>\n	</ul>\n	</li>\n</ul>\n\n<h3>缺点</h3>\n\n<ul>\n	<li>标记清除算法的效率不算高</li>\n	<li>在进行GC的时候，需要停止整个应用程序，用户体验较差</li>\n	<li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li>\n</ul>\n\n<h2>清除阶段：复制算法</h2>\n\n<h3>背景</h3>\n\n<p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，&ldquo;使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）&rdquo;。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</p>\n\n<h3>核心思想</h3>\n\n<p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p>\n\n<p><img alt=\"image-20200712151916991\" src=\"http://image.moguit.cn/5585bb2b64eb4528970e244b46835d6a\" /></p>\n\n<p>把可达的对象，直接复制到另外一个区域中复制完成后，A区就没有用了，里面的对象可以直接清除掉，其实里面的新生代里面就用到了复制算法</p>\n\n<p><img alt=\"image-20200712152029615\" src=\"http://image.moguit.cn/0533a6c4af2c4a2da59fdecb54623780\" /></p>\n\n<h3>优点</h3>\n\n<ul>\n	<li>没有标记和清除过程，实现简单，运行高效</li>\n	<li>复制过去以后保证空间的连续性，不会出现&ldquo;碎片&rdquo;问题。</li>\n</ul>\n\n<h3>缺点</h3>\n\n<ul>\n	<li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li>\n	<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li>\n</ul>\n\n<h3>注意</h3>\n\n<p>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行（老年代大量的对象存活，那么复制的对象将会有很多，效率会很低）</p>\n\n<p>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p>\n\n<p><img alt=\"image-20200712152847218\" src=\"http://image.moguit.cn/33caf928236744f489912ab7306ae1f8\" /></p>\n\n<h2>清除阶段：标记-整理算法</h2>\n\n<h3>背景</h3>\n\n<p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p>\n\n<p>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JvM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p>\n\n<p>1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p>\n\n<h3>执行过程</h3>\n\n<p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</p>\n\n<p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</p>\n\n<p><img alt=\"image-20200712153236508\" src=\"http://image.moguit.cn/7586a82ca34a4d7ca59cd1b262c663be\" /></p>\n\n<h3>标清和标整的区别</h3>\n\n<p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</p>\n\n<p>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p>\n\n<h3>标整的优缺点</h3>\n\n<h4>优点</h4>\n\n<ul>\n	<li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li>\n	<li>消除了复制算法当中，内存减半的高额代价。</li>\n</ul>\n\n<h4>缺点</h4>\n\n<ul>\n	<li>从效率上来说，标记-整理算法要低于复制算法。</li>\n	<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li>\n	<li>移动过程中，需要全程暂停用户应用程序。即：STW</li>\n</ul>\n\n<h2>小结</h2>\n\n<p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p>\n\n<p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p>\n\n<p>| | 标记清除 | 标记整理 | 复制 | | ------------ | ------------------ | ---------------- | ------------------------------------- | | <strong>速率</strong> | 中等 | 最慢 | 最快 | | <strong>空间开销</strong> | 少（但会堆积碎片） | 少（不堆积碎片） | 通常需要活对象的2倍空间（不堆积碎片） | | <strong>移动对象</strong> | 否 | 是 | 是 |</p>\n\n<p>综合我们可以找到，没有最好的算法，只有最合适的算法</p>\n\n<h3>分代收集算法</h3>\n\n<p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p>\n\n<p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>\n\n<p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：string对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p>\n\n<p>目前几乎所有的GC都采用分代手机算法执行垃圾回收的</p>\n\n<p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p>\n\n<ul>\n	<li>年轻代（Young Gen）</li>\n</ul>\n\n<p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p>\n\n<p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p>\n\n<ul>\n	<li>老年代（Tenured Gen）</li>\n</ul>\n\n<p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p>\n\n<p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p>\n\n<ul>\n	<li>Mark阶段的开销与存活对象的数量成正比。</li>\n	<li>Sweep阶段的开销与所管理区域的大小成正相关。</li>\n	<li>compact阶段的开销与存活对象的数据成正比。</li>\n</ul>\n\n<p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用serial old执行FullGC以达到对老年代内存的整理。</p>\n\n<p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p>\n\n<h2>增量收集算法</h2>\n\n<h3>概述</h3>\n\n<p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the World的状态。在stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p>\n\n<p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p>\n\n<p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。<strong>增量收集算法通过对线程间冲突的妥善处理</strong>，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</p>\n\n<h3>缺点</h3>\n\n<p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p>\n\n<h2>分区算法</h2>\n\n<p>一般来说，在相同条件下，堆空间越大，一次Gc时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p>\n\n<p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>\n\n<p><img alt=\"image-20200712165318590\" src=\"http://image.moguit.cn/87ecf9a06bbb4fc6ab0f162bbd0fa037\" /></p>\n\n<h2>写到最后</h2>\n\n<p>注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</p>\n', '7e0e93ea6cdb44ae92e58f48e6496ed7,15721a34adba068763b5a2fb1991fc57,5626932d452c2ad863d9b3cb0b69d22d', 16, 0, 'e30ba2f4812f34bf83d56ef3dc9ce739', 1, '2020-08-16 00:11:03', '2020-08-25 23:22:08', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪_', '蘑菇博客', 'db0d64ea7df409de5d2d747927cfa1a5', 0, '1', 0, 1, 0, NULL, 21, NULL, 0);
INSERT INTO `t_blog` VALUES ('b100fde21ac0b61414dbaa74d2db7192', 'CentOS下安装Sentinel', 'CentOS下安装Sentinel', '<h1 id=\"CentOS下安装Sentinel\">CentOS下安装Sentinel</h1>\n<h2 id=\"前言\">前言</h2>\n<p>Sentinel被称为分布式系统的流量防卫兵，这里主要讲的是CentOS下如何安装Sentinel，关于Windows下的安装以及Sentinel的介绍，可以参考下面的博客</p>\n<p><a href=\"http://moguit.cn/#/info?blogUid=408e9c889ebf96a66af2adfdc258ba5f\">【SpringCloud】使用Sentinel实现熔断和限流</a></p>\n<p><a href=\"http://moguit.cn/#/info?blogUid=7135efc7f536769efd0d0483c687ba07\">Windows下蘑菇博客Sentinel安装指南</a></p>\n<h2 id=\"下载Sentinel\">下载Sentinel</h2>\n<p>Sentinel的安装非常简单，只需要去<a href=\"https://github.com/alibaba/Sentinel/releases\">官网</a>下载好对应的可执行jar包</p>\n<p><img src=\"http://image.moguit.cn/0ae258651a4444a293bb817a04d20024\" alt=\"image-20200822150208675\" /></p>\n<p>然后在配置启动脚本和关闭脚本，同时设置启动端口号8070</p>\n<p>启动脚本：startup.sh</p>\n<pre><code class=\"language-bash\">#!/bin/bash   \nnohup java -jar sentinel-dashboard-1.8.0.jar --server.port=8070  &gt; catalina.out  2&gt;&amp;1 &amp;\n\n</code></pre>\n<p>关闭脚本：shutdown.sh</p>\n<pre><code class=\"language-bash\">#!/bin/bash\nPID=$(ps -ef | grep sentinel-dashboard-1.8.0.jar  | grep -v grep | awk \'{ print $2 }\')\nif [ -z &quot;$PID&quot; ]\nthen\n    echo Application is already stopped\nelse\n    echo kill $PID\n    kill $PID\nfi\n\n</code></pre>\n<p>启动成功后，访问地址：http://youip:8070，即可打开sentinel的管理页面</p>\n<p><img src=\"http://image.moguit.cn/ba61b29866d849aeb8345a9a81466385\" alt=\"image-20200822151430102\" /></p>\n<p>输入sentinel sentinel进入即可</p>\n', '1d1fd6d26c8e40a38637ef6126c45cd0,e81bc2dca42c4031be7d66fef4a71e16', 12, 0, 'd2424afcd30ca070d43930d0257097ad', 0, '2020-08-25 08:54:02', '2020-10-07 16:32:38', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 3, '1', 0, 1, 0, NULL, 22, NULL, 0);
INSERT INTO `t_blog` VALUES ('b335e8608ffd672a6351fdc2a3510eed', 'README', 'README', '<h2>前言</h2>\n<p>今天有个热心的小伙伴，通过 <strong>MySQL</strong> 图形化管理工具 <strong>SQLyog</strong> 进行远程数据库连接，成功进入了 <strong>蘑菇博客</strong> 的生产环境数据库。然后在博客数据表中增加一个<strong>超级管理员</strong>账号，最后通过新创建的超级管理员，在蘑菇博客后台转悠了一圈，然后进入蘑菇博客交流群和我反馈了这个 <strong>BUG</strong> ，在这里首先感谢这位小伙伴的<strong>不删库之恩</strong> ....</p>\n<h2>问题缘由</h2>\n<p>问题出现的原因，是因为蘑菇博客生产环境的数据库使用的远程登录密码为 <strong>默认密码(mogu2018)</strong> 。也就是说，当我们在 <strong>Linux</strong> 服务器中，使用下面的命令进行数据库连接</p>\n<pre><code class=\"language-bash\"># 连接mysql\nmysql -u root -p\n# 输入密码\nmogu2020\n</code></pre>\n<p>发现使用密码： <strong>mogu2020</strong> ，能够成功在服务器上登录MySQL</p>\n<p><img src=\"http://localhost:8600//blog/admin/jpg/2021/2/22/1613965094391.jpg\" alt=\"命令行方式进入MySQL\" /></p>\n<p>然后我们在通过 <strong>SQLyog</strong> 进行测试，我们输入密码  <strong>mogu2018</strong></p>\n<p><img src=\"http://localhost:8600//blog/admin/jpg/2021/2/22/1613965136489.jpg\" alt=\"通过SQLyog远程连接MySQL\" /></p>\n<p>发现也能够成功登录系统！问题就出在这里呢，我以为我把密码改成了 <strong>mogu2020</strong>  ，但是其他小伙伴如果使用远程工具，还可以继续使用 <strong>mogu2018</strong> 进行登录</p>\n<h2>解决方案</h2>\n<p>首先这个问题出现的原因，是因为<strong>远程连接的密码</strong>和<strong>本地连接的密码</strong>不一致引起的，也就是说我在部署完 <strong>MySQL</strong> 后，只修改了一个所引起的，首先我们查询 <strong>mysql</strong> 用户</p>\n<pre><code class=\"language-bash\"># 登录mysql\nmysql -u root -p\n\n# 使用mysql数据库\nuse mysql\n\n# 查询mysql用户\nselect user, host from mysql.user;\n</code></pre>\n<p>我们能够发现有4个用户</p>\n<p><img src=\"http://localhost:8600//blog/admin/jpg/2021/2/22/1613965073233.jpg\" alt=\"查询mysql的连接用户\" /></p>\n<p>其中 <strong>host</strong> 为 <strong>%</strong> 的表示是远程连接用户，而 <strong>localhost</strong> 和 <strong>127.0.0.1</strong> 都是本地用户，下面的配置就是蘑菇博客在线上的配置</p>\n<pre><code class=\"language-yaml\">  datasource:\n    username: root\n    password: mogu2020\n    url: jdbc:mysql://localhost:3306/mogu_admin\n</code></pre>\n<p>因为 <strong>MySQL</strong> 和项目是在同一个云服务器中，所以直接通过 localhost，即可连接。</p>\n<p>而我们在 <strong>Windows</strong> 上通过 <strong>SQLyog</strong> 远程连接我们的云服务器，就只能通过 <strong>%</strong> 用户进行连接了，现在我们要做的是修改 <strong>%</strong> 用户(也远程连接用户) 的 密码即可。</p>\n<pre><code class=\"language-bash\"># 修改密码，改成 mogu2020\nGRANT ALL PRIVILEGES ON *.* TO \'root\'@\'%\'IDENTIFIED BY \'mogu2020\' WITH GRANT OPTION;\n\n# 刷新\nflush privileges;\n</code></pre>\n<p>修改完密码后，<strong>SQLyog</strong> 远程连接通过 <strong>mogu2018</strong> 无法登录了，正所谓亡羊补牢，为时不晚。因为之前修改密码的时候，只修改了 <strong>localhost</strong> 的，而没有修改%的，而导致这个问题的出现，最后再次感谢热心的小伙伴发现这个问题，以及小伙伴的不删库之恩~</p>\n<h2>结语</h2>\n<p><strong>陌溪</strong>是一个从三本院校一路摸滚翻爬上来的互联网大厂程序员。独立做过几个开源项目，其中<strong>蘑菇博客</strong>在码云上有 <strong>2K Star</strong> 了。目前就职于<strong>字节跳动的Data广告部门</strong>，是字节跳动全线产品的商业变现研发团队。同时本公众号将会持续性的输出很多原创小知识以及学习资源。欢迎各位小伙伴关注陌溪，让我们一起成长~</p>\n<p><img src=\"http://localhost:8600//blog/admin/jpg/2021/2/22/1613965115450.jpg\" alt=\"和陌溪一起学编程\" /></p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 0, 0, 'd134bdfe255b9aa8c2ce44da8297f6a6', 1, '2021-02-22 11:39:10', '2021-02-22 11:39:10', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '0', 0, 1, 0, NULL, 47, NULL, 0);
INSERT INTO `t_blog` VALUES ('c4d982f7dbf0143624522f5e26d95358', '默认标题1', '默认简介1', '<h1 id=\"http及Template介绍\">http及Template介绍</h1>\n<h2 id=\"来源\">来源</h2>\n<p><a href=\"https://www.liwenzhou.com/posts/Go/go_template/\">https://www.liwenzhou.com/posts/Go/go_template/</a></p>\n<h2 id=\"介绍\">介绍</h2>\n<p><code>html/template</code>包实现了数据驱动的模板，用于生成可防止代码注入的安全的HTML内容。它提供了和 <code>text/template</code>包相同的接口，Go语言中输出HTML的场景都应使用 <code>html/template</code>这个包。</p>\n<h2 id=\"模板与渲染\">模板与渲染</h2>\n<p>在一些前后端不分离的Web架构中，我们通常需要在后端将一些数据渲染到HTML文档中，从而实现动态的网页（网页的布局和样式大致一样，但展示的内容并不一样）效果。</p>\n<p>我们这里说的模板可以理解为事先定义好的HTML文档文件，模板渲染的作用机制可以简单理解为文本替换操作–使用相应的数据去替换HTML文档中事先准备好的标记。</p>\n<p>很多编程语言的Web框架中都使用各种模板引擎，比如Python语言中Flask框架中使用的jinja2模板引擎。</p>\n<h2 id=\"Go语言的模板引擎\">Go语言的模板引擎</h2>\n<p>Go语言内置了文本模板引擎 <code>text/template</code>和用于HTML文档的 <code>html/template</code>。它们的作用机制可以简单归纳如下：</p>\n<ol>\n<li>模板文件通常定义为<code>.tmpl</code>和<code>.tpl</code>为后缀（也可以使用其他的后缀），必须使用<code>UTF8</code>编码。</li>\n<li>模板文件中使用<code>{{</code>和<code>}}</code>包裹和标识需要传入的数据。</li>\n<li>传给模板这样的数据就可以通过点号（<code>.</code>）来访问，如果数据是复杂类型的数据，可以通过{ { .FieldName }}来访问它的字段。</li>\n<li>除<code>{{</code>和<code>}}</code>包裹的内容外，其他内容均不做修改原样输出。</li>\n</ol>\n<h2 id=\"模板引擎的使用\">模板引擎的使用</h2>\n<p>Go语言模板引擎的使用可以分为三部分：定义模板文件、解析模板文件和模板渲染.</p>\n<h3 id=\"定义模板文件\">定义模板文件</h3>\n<p>其中，定义模板文件时需要我们按照相关语法规则去编写，后文会详细介绍。</p>\n<h3 id=\"解析模板文件\">解析模板文件</h3>\n<p>上面定义好了模板文件之后，可以使用下面的常用方法去解析模板文件，得到模板对象：</p>\n<pre><code class=\"language-go\">func (t *Template) Parse(src string) (*Template, error)\nfunc ParseFiles(filenames ...string) (*Template, error)\nfunc ParseGlob(pattern string) (*Template, error)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p>当然，你也可以使用 <code>func New(name string) *Template</code>函数创建一个名为 <code>name</code>的模板，然后对其调用上面的方法去解析模板字符串或模板文件。</p>\n<h3 id=\"模板渲染\">模板渲染</h3>\n<p>渲染模板简单来说就是使用数据去填充模板，当然实际上可能会复杂很多。</p>\n<pre><code class=\"language-go\">func (t *Template) Execute(wr io.Writer, data interface{}) error\nfunc (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<h3 id=\"基本示例\">基本示例</h3>\n<h4 id=\"定义模板文件-\">定义模板文件</h4>\n<p>我们按照Go模板语法定义一个 <code>hello.tmpl</code>的模板文件，内容如下：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;zh-CN&quot;&gt;\n&lt;head&gt;\n    &lt;title&gt;hello&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt; hello golang&lt;/h1&gt;\n    &lt;h1&gt;hello {{.}}&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<h4 id=\"解析和渲染模板文件\">解析和渲染模板文件</h4>\n<p>然后我们创建一个 <code>main.go</code>文件，在其中写下HTTP server端代码如下：</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n	&quot;fmt&quot;\n	&quot;html/template&quot;\n	&quot;net/http&quot;\n	&quot;os&quot;\n)\n\nfunc sayHello(w http.ResponseWriter, r *http.Request) {\n	// 获取项目的绝对路径\n	wd, err := os.Getwd()\n	if err != nil {\n		fmt.Printf(&quot;get wd failed, err:%v \\n&quot;, wd)\n		return\n	}\n	fmt.Println(&quot;wd:&quot;, wd + &quot;\\\\lesson04\\\\hello.tmpl&quot;)\n	// 解析指定文件生成模板对象\n	tmpl, err := template.ParseFiles( wd + &quot;\\\\lesson04\\\\hello.tmpl&quot;)\n\n	if err != nil {\n		fmt.Println(&quot;create template failed, err:&quot;, err)\n		return\n	}\n	// 利用给定数据渲染模板，并将结果写入w\n	tmpl.Execute(w, &quot;沙河小王子&quot;)\n}\nfunc main() {\n	http.HandleFunc(&quot;/&quot;, sayHello)\n	err := http.ListenAndServe(&quot;:9090&quot;, nil)\n	if err != nil {\n		fmt.Println(&quot;HTTP server failed,err:&quot;, err)\n		return\n	}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p>将上面的 <code>main.go</code>文件编译执行，然后使用浏览器访问 <code>http://127.0.0.1:9090</code>就能看到页面上显示了“Hello 沙河小王子”。 这就是一个最简单的模板渲染的示例，Go语言模板引擎详细用法请往下阅读。+</p>\n<p>得到运行结果</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/9/23/1600821758386.png\" alt=\"image-20200914201109380\" /></p>\n<h2 id=\"模板语法\">模板语法</h2>\n<h3 id=\"-\">}</h3>\n<p>模板语法都包含在 <code>{{</code>和 <code>}}</code>中间，其中 <code>{{.}}</code>中的点表示当前对象。</p>\n<p>当我们传入一个结构体对象时，我们可以根据 <code>.</code>来访问结构体的对应字段。例如：</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n	&quot;fmt&quot;\n	&quot;html/template&quot;\n	&quot;net/http&quot;\n	&quot;os&quot;\n)\n\n//定义用户结构体\ntype User struct {\n	Name string\n	Gender string\n	Age int\n}\n\nfunc sayHello(w http.ResponseWriter, r *http.Request) {\n	// 获取项目的绝对路径\n	wd, err := os.Getwd()\n	if err != nil {\n		fmt.Printf(&quot;get wd failed, err:%v \\n&quot;, wd)\n		return\n	}\n	fmt.Println(&quot;wd:&quot;, wd + &quot;\\\\lesson05\\\\hello.tmpl&quot;)\n	// 解析指定文件生成模板对象\n	tmpl, err := template.ParseFiles( wd + &quot;\\\\lesson05\\\\hello.tmpl&quot;)\n\n	if err != nil {\n		fmt.Println(&quot;create template failed, err:&quot;, err)\n		return\n	}\n\n	u1 := User{\n		Name: &quot;小王子&quot;,\n		Gender: &quot;男&quot;,\n		Age: 10,\n	}\n\n	// 利用给定数据渲染模板，并将结果写入w\n	tmpl.Execute(w, u1)\n}\nfunc main() {\n	http.HandleFunc(&quot;/&quot;, sayHello)\n	err := http.ListenAndServe(&quot;:9090&quot;, nil)\n	if err != nil {\n		fmt.Println(&quot;HTTP server failed,err:&quot;, err)\n		return\n	}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p>模板文件 <code>hello.tmpl</code>内容如下：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;zh-CN&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;Hello&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;姓名: {{.Name}}&lt;/h1&gt;\n&lt;h1&gt;性别: {{.Gender}}&lt;/h1&gt;\n&lt;h1&gt;年龄: {{.Age}}&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p>在浏览器输入如下网址</p>\n<pre><code class=\"language-bash\">http://localhost:9090/sayHello\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p>能够渲染出我们结构体中的值</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/9/23/1600821758544.png\" alt=\"image-20200914205920172\" /></p>\n<p>同理，当我们传入的变量是map时，也可以在模板文件中通过 <code>.</code>根据key来取值。</p>\n<pre><code class=\"language-go\">\n// 采用一个map\nm1 := map[string]interface{}{\n    &quot;Name&quot;: &quot;小王子&quot;,\n    &quot;Age&quot;: 18,\n    &quot;Gender&quot;: &quot;男&quot;,\n}\n\n// 利用给定数据渲染模板，并将结果写入w\ntmpl.Execute(w, m1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p>如果我们想把map 和 结构体都传递到前端，那么就需要在定义一个大的map来进行存储</p>\n<pre><code class=\"language-bash\">	// 采用结构体\n	u1 := User{\n		Name: &quot;小王子&quot;,\n		Gender: &quot;男&quot;,\n		Age: 10,\n	}\n\n	// 采用一个map\n	m1 := map[string]interface{}{\n		&quot;Name&quot;: &quot;小王子&quot;,\n		&quot;Age&quot;: 18,\n		&quot;Gender&quot;: &quot;男&quot;,\n	}\n\n	m2 := map[string]interface{}{\n		&quot;map&quot;: m1,\n		&quot;user&quot;: u1,\n	}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<h3 id=\"注释\">注释</h3>\n<pre><code class=\"language-template\">{{/* a comment */}}\n注释，执行时会忽略。可以多行。注释不能嵌套，并且必须紧贴分界符始止。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<h3 id=\"pipeline\">pipeline</h3>\n<p><code>pipeline</code>是指产生数据的操作。比如 <code>{{.}}</code>、<code>{{.Name}}</code>等。Go的模板语法中支持使用管道符号 <code>|</code>链接多个命令，用法和unix下的管道类似：<code>|</code>前面的命令会将运算结果(或返回值)传递给后一个命令的最后一个位置。</p>\n<p>**注意：**并不是只有使用了 <code>|</code>才是pipeline。Go的模板语法中，<code>pipeline的</code>概念是传递数据，只要能产生数据的，都是 <code>pipeline</code>。</p>\n<h3 id=\"变量\">变量</h3>\n<p>我们还可以在模板中声明变量，用来保存传入模板的数据或其他语句生成的结果。具体语法如下：</p>\n<pre><code class=\"language-template\">$obj := {{.}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p>其中 <code>$obj</code>是变量的名字，在后续的代码中就可以使用该变量了。</p>\n<h3 id=\"移除空格\">移除空格</h3>\n<p>有时候我们在使用模板语法的时候会不可避免的引入一下空格或者换行符，这样模板最终渲染出来的内容可能就和我们想的不一样，这个时候可以使用 <code>{{-</code>语法去除模板内容左侧的所有空白符号， 使用 <code>-}}</code>去除模板内容右侧的所有空白符号。</p>\n<p>例如：</p>\n<pre><code class=\"language-template\">{{- .Name -}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p><strong>注意：</strong><code>-</code>要紧挨 <code>{{</code>和 <code>}}</code>，同时与模板值之间需要使用空格分隔。</p>\n<h3 id=\"条件判断\">条件判断</h3>\n<p>Go模板语法中的条件判断有以下几种:</p>\n<pre><code class=\"language-template\">{{if pipeline}} T1 {{end}}\n\n{{if pipeline}} T1 {{else}} T0 {{end}}\n\n{{if pipeline}} T1 {{else if pipeline}} T0 {{end}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<h3 id=\"range\">range</h3>\n<p>Go的模板语法中使用 <code>range</code>关键字进行遍历，有以下两种写法，其中 <code>pipeline</code>的值必须是数组、切片、字典或者通道。</p>\n<pre><code class=\"language-template\">{{range pipeline}} T1 {{end}}\n如果pipeline的值其长度为0，不会有任何输出\n\n{{range pipeline}} T1 {{else}} T0 {{end}}\n如果pipeline的值其长度为0，则会执行T0。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<h3 id=\"with\">with</h3>\n<pre><code class=\"language-template\">{{with pipeline}} T1 {{end}}\n如果pipeline为empty不产生输出，否则将dot设为pipeline的值并执行T1。不修改外面的dot。\n\n{{with pipeline}} T1 {{else}} T0 {{end}}\n如果pipeline为empty，不改变dot并执行T0，否则dot设为pipeline的值并执行T1。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<h3 id=\"预定义函数\">预定义函数</h3>\n<p>执行模板时，函数从两个函数字典中查找：首先是模板函数字典，然后是全局函数字典。一般不在模板内定义函数，而是使用Funcs方法添加函数到模板里。</p>\n<p>预定义的全局函数如下：</p>\n<pre><code class=\"language-template\">and\n    函数返回它的第一个empty参数或者最后一个参数；\n    就是说&quot;and x y&quot;等价于&quot;if x then y else x&quot;；所有参数都会执行；\nor\n    返回第一个非empty参数或者最后一个参数；\n    亦即&quot;or x y&quot;等价于&quot;if x then x else y&quot;；所有参数都会执行；\nnot\n    返回它的单个参数的布尔值的否定\nlen\n    返回它的参数的整数类型长度\nindex\n    执行结果为第一个参数以剩下的参数为索引/键指向的值；\n    如&quot;index x 1 2 3&quot;返回x[1][2][3]的值；每个被索引的主体必须是数组、切片或者字典。\nprint\n    即fmt.Sprint\nprintf\n    即fmt.Sprintf\nprintln\n    即fmt.Sprintln\nhtml\n    返回与其参数的文本表示形式等效的转义HTML。\n    这个函数在html/template中不可用。\nurlquery\n    以适合嵌入到网址查询中的形式返回其参数的文本表示的转义值。\n    这个函数在html/template中不可用。\njs\n    返回与其参数的文本表示形式等效的转义JavaScript。\ncall\n    执行结果是调用第一个参数的返回值，该参数必须是函数类型，其余参数作为调用该函数的参数；\n    如&quot;call .X.Y 1 2&quot;等价于go语言里的dot.X.Y(1, 2)；\n    其中Y是函数类型的字段或者字典的值，或者其他类似情况；\n    call的第一个参数的执行结果必须是函数类型的值（和预定义函数如print明显不同）；\n    该函数类型值必须有1到2个返回值，如果有2个则后一个必须是error接口类型；\n    如果有2个返回值的方法返回的error非nil，模板执行会中断并返回给调用模板执行者该错误；\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<h3 id=\"比较函数\">比较函数</h3>\n<p>布尔函数会将任何类型的零值视为假，其余视为真。</p>\n<p>下面是定义为函数的二元比较运算的集合：</p>\n<pre><code class=\"language-template\">eq      如果arg1 == arg2则返回真\nne      如果arg1 != arg2则返回真\nlt      如果arg1 &lt; arg2则返回真\nle      如果arg1 &lt;= arg2则返回真\ngt      如果arg1 &gt; arg2则返回真\nge      如果arg1 &gt;= arg2则返回真\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p>为了简化多参数相等检测，eq（只有eq）可以接受2个或更多个参数，它会将第一个参数和其余参数依次比较，返回下式的结果：</p>\n<pre><code class=\"language-template\">{{eq arg1 arg2 arg3}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p>比较函数只适用于基本类型（或重定义的基本类型，如”type Celsius float32”）。但是，整数和浮点数不能互相比较。</p>\n<h3 id=\"自定义函数\">自定义函数</h3>\n<p>Go的模板支持自定义函数。</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n	&quot;fmt&quot;\n	&quot;html/template&quot;\n	&quot;net/http&quot;\n	&quot;os&quot;\n)\n\n/**\n * @Description f1函数\n * @Param \n * @return\n **/\nfunc f1(w http.ResponseWriter, r *http.Request) {\n	// 定义模板\n	// 解析模板\n	// 获取项目的绝对路径\n	wd, err := os.Getwd()\n	if err != nil {\n		fmt.Printf(&quot;get wd failed, err:%v \\n&quot;, wd)\n		return\n	}\n\n	// 定义一个自定义函数\n	// 要么只有一个返回值，要么有两个返回值，第二个返回值必须是error类型\n	kua := func(name string)(string, error) {\n		return name + &quot;年轻又帅气!&quot;, nil\n	}\n\n	// 创建一个名字为f的模板对象。注意，这个名字一定要和模板的名字对应上\n	tmpl := template.New(&quot;hello.tmpl&quot;)\n\n	// 告诉模板引擎，我现在多了一个自定义的函数kua\n	tmpl.Funcs(template.FuncMap{\n		&quot;kua&quot;: kua,\n	})\n\n	// 解析模板\n	_, err = tmpl.ParseFiles( wd + &quot;\\\\lesson06\\\\hello.tmpl&quot;)\n	if err != nil {\n		fmt.Printf(&quot;parse template failed, err:%v \\n&quot;, err)\n		return\n	}\n\n	// 采用一个map\n	m1 := map[string]interface{}{\n		&quot;Name&quot;: &quot;小王子&quot;,\n		&quot;Age&quot;: 18,\n		&quot;Gender&quot;: &quot;男&quot;,\n	}\n\n	// 渲染模板\n	tmpl.Execute(w, m1)\n}\nfunc main() {\n	http.HandleFunc(&quot;/hello&quot;, f1)\n	err := http.ListenAndServe(&quot;:9090&quot;, nil)\n	if err != nil {\n		fmt.Println(&quot;HTTP server failed,err:&quot;, err)\n		return\n	}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p>我们可以在模板文件 <code>hello.tmpl</code>中按照如下方式使用我们自定义的 <code>kua</code>函数了。</p>\n<pre><code class=\"language-template\">{{kua .Name}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p>最后运行的结果</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/9/23/1600821758582.png\" alt=\"image-20200916101259659\" /></p>\n<h3 id=\"模板的嵌套template\">模板的嵌套template</h3>\n<p>我们可以在template中嵌套其他的template。这个template可以是单独的文件，也可以是通过 <code>define</code>定义的template。</p>\n<p>举个例子： <code>t.tmpl</code>文件内容如下：</p>\n<pre><code class=\"language-template\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;zh-CN&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;tmpl test&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  \n    &lt;h1&gt;测试嵌套template语法&lt;/h1&gt;\n    &lt;hr&gt;\n    {{template &quot;ul.tmpl&quot;}}\n    &lt;hr&gt;\n    {{template &quot;ol.tmpl&quot;}}\n&lt;/body&gt;\n&lt;/html&gt; \n\n{{ define &quot;ol.tmpl&quot;}}\n&lt;ol&gt;\n    &lt;li&gt;吃饭&lt;/li&gt;\n    &lt;li&gt;睡觉&lt;/li&gt;\n    &lt;li&gt;打豆豆&lt;/li&gt;\n&lt;/ol&gt;\n{{end}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p><code>ul.tmpl</code>文件内容如下：</p>\n<pre><code class=\"language-template\">&lt;ul&gt;\n    &lt;li&gt;注释&lt;/li&gt;\n    &lt;li&gt;日志&lt;/li&gt;\n    &lt;li&gt;测试&lt;/li&gt;\n&lt;/ul&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p>我们注册一个 <code>templDemo</code>路由处理函数.</p>\n<pre><code class=\"language-go\">http.HandleFunc(&quot;/tmpl&quot;, tmplDemo)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p><code>tmplDemo</code>函数的具体内容如下：</p>\n<pre><code class=\"language-go\">func tmplDemo(w http.ResponseWriter, r *http.Request) {\n	tmpl, err := template.ParseFiles(&quot;./t.tmpl&quot;, &quot;./ul.tmpl&quot;)\n	if err != nil {\n		fmt.Println(&quot;create template failed, err:&quot;, err)\n		return\n	}\n	user := UserInfo{\n		Name:   &quot;小王子&quot;,\n		Gender: &quot;男&quot;,\n		Age:    18,\n	}\n	tmpl.Execute(w, user)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p><strong>注意</strong>：在解析模板时，被嵌套的模板一定要在后面解析，例如上面的示例中 <code>t.tmpl</code>模板中嵌套了 <code>ul.tmpl</code>，所以 <code>ul.tmpl</code>要在 <code>t.tmpl</code>后进行解析。</p>\n<h3 id=\"block\">block</h3>\n<pre><code class=\"language-template\">{{block &quot;name&quot; pipeline}} T1 {{end}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p><code>block</code>是定义模板 <code>{{define &quot;name&quot;}} T1 {{end}}</code>和执行 <code>{{template &quot;name&quot; pipeline}}</code>缩写，典型的用法是定义一组根模板，然后通过在其中重新定义块模板进行自定义。</p>\n<p>定义一个根模板 <code>templates/base.tmpl</code>，内容如下：</p>\n<pre><code class=\"language-template\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;zh-CN&quot;&gt;\n&lt;head&gt;\n    &lt;title&gt;Go Templates&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div class=&quot;container-fluid&quot;&gt;\n    {{block &quot;content&quot; . }}{{end}}\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p>然后定义一个 <code>templates/index.tmpl</code>，”继承”<code>base.tmpl</code>：</p>\n<pre><code class=\"language-tempalte\">{{template &quot;base.tmpl&quot;}}\n\n{{define &quot;content&quot;}}\n    &lt;div&gt;Hello world!&lt;/div&gt;\n{{end}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p>然后使用 <code>template.ParseGlob</code>按照正则匹配规则解析模板文件，然后通过 <code>ExecuteTemplate</code>渲染指定的模板：</p>\n<pre><code class=\"language-go\">func index(w http.ResponseWriter, r *http.Request){\n	tmpl, err := template.ParseGlob(&quot;templates/*.tmpl&quot;)\n	if err != nil {\n		fmt.Println(&quot;create template failed, err:&quot;, err)\n		return\n	}\n	err = tmpl.ExecuteTemplate(w, &quot;index.tmpl&quot;, nil)\n	if err != nil {\n		fmt.Println(&quot;render template failed, err:&quot;, err)\n		return\n	}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p>如果我们的模板名称冲突了，例如不同业务线下都定义了一个 <code>index.tmpl</code>模板，我们可以通过下面两种方法来解决。</p>\n<ol>\n<li>在模板文件开头使用<code>{{define 模板名}}</code>语句显式的为模板命名。</li>\n<li>可以把模板文件存放在<code>templates</code>文件夹下面的不同目录中，然后使用<code>template.ParseGlob(&quot;templates/**/*.tmpl&quot;)</code>解析模板。</li>\n</ol>\n<h3 id=\"修改默认的标识符\">修改默认的标识符</h3>\n<p>Go标准库的模板引擎使用的花括号 <code>{{</code>和 <code>}}</code>作为标识，而许多前端框架（如 <code>Vue</code>和 <code>AngularJS</code>）也使用 <code>{{</code>和 <code>}}</code>作为标识符，所以当我们同时使用Go语言模板引擎和以上前端框架时就会出现冲突，这个时候我们需要修改标识符，修改前端的或者修改Go语言的。这里演示如何修改Go语言模板引擎默认的标识符：</p>\n<pre><code class=\"language-go\">template.New(&quot;test&quot;).Delims(&quot;{[&quot;, &quot;]}&quot;).ParseFiles(&quot;./t.tmpl&quot;)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p>最后我们在渲染的时候</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;zh-CN&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;自定义模板函数&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;姓名: {[.Name]}&lt;/h1&gt;\n&lt;h1&gt;性别: {[.Gender]}&lt;/h1&gt;\n&lt;h1&gt;年龄: {[.Age]}&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p>最后运行结果，发现也能够正常显示</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/9/23/1600821758610.png\" alt=\"image-20200916214044623\" /></p>\n<h2 id=\"text-template与html-tempalte的区别\">text/template与html/tempalte的区别</h2>\n<p><code>html/template</code>针对的是需要返回HTML内容的场景，在模板渲染过程中会对一些有风险的内容进行转义，以此来防范跨站脚本攻击。</p>\n<p>例如，我定义下面的模板文件：</p>\n<pre><code class=\"language-template\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;zh-CN&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;Hello&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    {{.}}\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p>这个时候传入一段JS代码并使用 <code>html/template</code>去渲染该文件，会在页面上显示出转义后的JS内容。 <code>alert(\'嘿嘿嘿\')</code> 这就是 <code>html/template</code>为我们做的事。</p>\n<p>但是在某些场景下，我们如果相信用户输入的内容，不想转义的话，可以自行编写一个safe函数，手动返回一个 <code>template.HTML</code>类型的内容。示例如下：</p>\n<pre><code class=\"language-go\">func xss(w http.ResponseWriter, r *http.Request){\n	tmpl,err := template.New(&quot;xss.tmpl&quot;).Funcs(template.FuncMap{\n		&quot;safe&quot;: func(s string)template.HTML {\n			return template.HTML(s)\n		},\n	}).ParseFiles(&quot;./xss.tmpl&quot;)\n	if err != nil {\n		fmt.Println(&quot;create template failed, err:&quot;, err)\n		return\n	}\n	jsStr := `&lt;script&gt;alert(\'嘿嘿嘿\')&lt;/script&gt;`\n	err = tmpl.Execute(w, jsStr)\n	if err != nil {\n		fmt.Println(err)\n	}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n<p>这样我们只需要在模板文件不需要转义的内容后面使用我们定义好的safe函数就可以了。</p>\n<pre><code class=\"language-template\">{{ . | safe }}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n', '7e0e93ea6cdb44ae92e58f48e6496ed7,5626932d452c2ad863d9b3cb0b69d22d', 3, 0, 'd134bdfe255b9aa8c2ce44da8297f6a6', 0, '2020-09-23 08:42:43', '2020-10-07 16:28:33', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', 'db0d64ea7df409de5d2d747927cfa1a5', 0, '1', 0, 1, 0, NULL, 23, NULL, 0);
INSERT INTO `t_blog` VALUES ('c58083675437f407d73d3322ca01b995', '测试博客', '测试博客', '<p>测试博客</p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 6, 0, 'a5d84f5e443b781fe8146620e1abb5b8', 1, '2020-10-13 09:03:59', '2021-04-09 20:43:36', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 24, NULL, 0);
INSERT INTO `t_blog` VALUES ('ca84cf718b1678bfabb12f09d0537981', '今天的天气非常非常不错哦今天的天气非常非常不错哦', '今天的天气非常非常不错哦今天的天气非常非常不错哦', '<p>啦啦啦啦</p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 0, 0, '1e9b54926b2a9d9c23e90ff8bf5abc21', 0, '2021-04-12 10:13:32', '2021-04-12 10:55:55', NULL, '1', 'mogu2018', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '0', 0, 1, 0, NULL, 54, 'b486735e7b914e366840d01f049306e4', 0);
INSERT INTO `t_blog` VALUES ('db56ab5dcd8c85c393c5dc0a9e65579c', '测试博客', '测试博客', '<p>​a+\\underbrace{b+c}_{1.0}+d<img src=\"http://testimage.moguit.cn/116ff9d4da9b4b0eba912d44d3ddc338\" /></p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 6, 0, '90dd6ac4d3e000b8ea2f7162201d6ace', 1, '2021-01-14 22:26:50', '2021-04-12 11:30:19', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 44, NULL, 0);
INSERT INTO `t_blog` VALUES ('e247932bf5f883ad3699144a00318a4b', '【阿里云】双十一拼团 2核4G3M 664元/3年（强烈推荐）', '【阿里云】双十一拼团 2核4G3M 664元/3年（强烈推荐）', '<p>【阿里云】双十一拼团 2核4G3M 664元/3年（强烈推荐）&nbsp;<a href=\"http://a.aliyun.com/f1.l0DRK\">点我进入</a></p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 1003, 0, '58be54bbd3f64fc65c0c18ddbeeb995f', 1, '2020-11-07 10:29:32', '2021-04-12 16:20:43', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', '337806254f9c42999043de5c5ee09e77', 1, '1', 2, 1, 1, 'https://www.aliyun.com/1111/pintuan?utm_content=m_1000193619&spm=a2c4j.20775865.zh-cnc.1', 25, NULL, 0);
INSERT INTO `t_blog` VALUES ('e39e9f98eba5354187acd0dabc2688a9', 'Go语言安装.md', 'Go语言安装.md', '<h1>Windows下Go语言的安装</h1>\n<h2>前言</h2>\n<p>这阵子因为以后工作的原因，所以开始了go语言的学习之旅，工欲善其事必先利其器，首先就得把go语言环境搭建完成</p>\n<h2>下载Go</h2>\n<p>因为go语言的官网经常打不开，所以我就找了一个 <a href=\"https://studygolang.com/dl\">镜像网站</a>，里面有很多版本的Go语言，选择自己合适的，比如我的是Windows电脑，所以我选中里面的Windows版本的</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/1/14/1610606911318.png\" alt=\"image-20200718111751694\" /></p>\n<p>下载完成是一个安装文件，我们需要进行安装，同时需要注意的就是安装目录，因为事后还需要配置环境变量，下面是安装成功后的图片</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/1/14/1610606911363.png\" alt=\"image-20200718111822269\" /></p>\n<h2>配置环境变量</h2>\n<p>根据windows系统在查找可执行程序的原理，可以将Go所在路径定义到环境变量中，让系统帮我们去找运行的执行程序，这样在任何目录下都可以执行go指令，需要配置的环境变量有：</p>\n<table>\n<thead>\n<tr><th>环境变量</th><th>说明</th></tr>\n</thead>\n<tbody>\n<tr><td>GOROOT</td><td>指定SDK的安装目录</td></tr>\n<tr><td>Path</td><td>添加SDK的/bin目录</td></tr>\n<tr><td>GOPATH</td><td>工作目录</td></tr>\n</tbody>\n</table>\n<p>这里面有几个重要的环境变量</p>\n<ul>\n<li><strong>GOPATH</strong>：在1.11版本之前，是我们书写项目的工作目录。在1.11版本之后它内部存储的是我们go.mod下载的依赖包。</li>\n<li><strong>GOROOT</strong>：Go语言的安装目录，不需要我们配置</li>\n<li><strong>GOPROXY</strong>：使用mod进行包管理时候的代理</li>\n</ul>\n<p>首先我们需要打开我们的环境变量，然后添加上GOROOT</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/1/14/1610606911653.png\" alt=\"image-20200718151418230\" /></p>\n<p>然后我们在PATH上添加我们的bin目录</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/1/14/1610606911722.png\" alt=\"image-20200718151503318\" /></p>\n<p>添加完成后，我们输入下面的命令，查看是否配置成功</p>\n<pre><code class=\"language-bash\">go version\n</code></pre>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/1/14/1610606911423.png\" alt=\"image-20200718112254366\" /></p>\n<h2>下载Jetbrain下的GoLang</h2>\n<p>在我们配置好环境，我们就可以使用Jetbrain公司开发的Goland编辑器了，首先进入官网下载</p>\n<p><a href=\"https://www.jetbrains.com/\">https://www.jetbrains.com/</a></p>\n<p>下载完成后，进行启动</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/1/14/1610606911560.png\" alt=\"image-20200718150736688\" /></p>\n<p>启动完成后，我们需要配置一下环境，点击：File -&gt;settings -&gt; GOROOT，配置一下刚刚go安装的目录</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/1/14/1610606911795.png\" alt=\"image-20200718151701767\" /></p>\n<p>以及GOPATH项目所在的目录</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/1/14/1610606911822.png\" alt=\"image-20200718151733127\" /></p>\n<h2>hello world</h2>\n<p>在上面的方法都完成以后，我来来输出hello world吧~</p>\n<pre><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc main() {\n	fmt.Println(&quot;hello world!&quot;)\n}\n</code></pre>\n<p>代码的说明</p>\n<ul>\n<li>go文件的后缀是.go</li>\n<li>package main：表示该hello.go文件所在的包是main，在go中，每个文件都归属与一个包</li>\n<li>import &quot;fmt&quot;：表示引入一个包，可以调用里面的函数</li>\n<li>func main()：表示程序入口，是一个主函数</li>\n</ul>\n<p>输出结果</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2021/1/14/1610606911861.png\" alt=\"image-20200718151850083\" /></p>\n<h2>编译和执行</h2>\n<p>我们可以通过使用下面命令进行编译和执行</p>\n<pre><code class=\"language-bash\"># 编译 hello.go 后 会生成一个 hello.exe文件\ngo build hello.go\n# 运行 hello.ext\nhello.ext\n</code></pre>\n<p>需要注意的是，我们也可以使用下面的方式，来直接运行的（使用go run会比较慢，因为内部有个编译的过程）</p>\n<pre><code class=\"language-bash\">go run hello.go\n</code></pre>\n<p>但是在生产环境中，是需要先编译在执行的</p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 0, 0, 'd134bdfe255b9aa8c2ce44da8297f6a6', 1, '2021-01-14 14:48:34', '2021-01-14 14:48:34', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '0', 0, 1, 0, NULL, 38, NULL, 0);
INSERT INTO `t_blog` VALUES ('f1b941c69826487151f4d0ce9bd82dc1', '默认标题2', '默认简介2', '<h2>前言</h2>\n<p>大家好，我是<strong>陌溪</strong></p>\n<p>最近我在<strong>Gitee</strong>逛<strong>开源项目</strong>的时候，发现很多<strong>做的不错的开源项目</strong>都拥有自己的<strong>开源文档</strong>。</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/12/26/1608970912042.png\" alt=\"RuoYi的开源文档-采用VuePress\" /></p>\n<p>一份好的开源文档，能够方便大家快速进行内容的检索，让小伙伴在<strong>项目搭建的时候少走弯路</strong>。</p>\n<p>后面陌溪就开始琢磨着，给<strong>蘑菇博客</strong>也编写一个开源文档。将一些<strong>项目搭建的文档</strong>都放在上面，这样即使自己的网站宕机了，小伙伴也可以**通过查看开源文档完成蘑菇博客的部署(**因为蘑菇博客好几次宕机了，导致小伙伴无法正常完成项目部署)</p>\n<p>陌溪经过全方位的调查，发现别人开源项目的文档主要是通过 <strong>docsify</strong> 和 <strong>vuepress</strong> 进行编写</p>\n<blockquote>\n<p>vuepress官网：<a href=\"https://www.vuepress.cn/\">https://www.vuepress.cn/</a></p>\n<p>docsify官网：<a href=\"https://docsify.js.org/#/\">https://docsify.js.org/#/</a></p>\n</blockquote>\n<p><strong>RuoYi</strong> 项目用的是 <strong>Vuepress</strong>，效果如上图所示。后面我发现 <strong>docsify</strong> 搭建出来的样式比 <strong>Vuepress</strong> 的好看一些，所以就选择使用 <strong>docsify</strong> 进行搭建。没办法，谁叫我是<strong>颜值控</strong>呢</p>\n<p>最终蘑菇博客的开源文档效果如下所示：</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/12/26/1608970912204.png\" alt=\"蘑菇博客的开源文档\" /></p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/12/26/1608970912305.png\" alt=\"文档详情\" /></p>\n<blockquote>\n<p>文档地址：<a href=\"http://doc.moguit.cn/\">http://doc.moguit.cn</a></p>\n</blockquote>\n<p>下面，我将会介绍我是如何完成文档的搭建过程</p>\n<h2>安装</h2>\n<p>首先需要安装 <strong>docsify-cli</strong> 脚手架，用于初始化 <strong>docsify</strong> 文档项目</p>\n<pre><code class=\"language-bash\">npm i docsify-cli -g\n</code></pre>\n<p>然后初始化</p>\n<pre><code class=\"language-bash\">docsify init ./docs\n</code></pre>\n<p>初始化后，我们就能看到 docs文件夹，里面含有下面内容</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/12/26/1608970912133.png\" alt=\"docsify初始化\" /></p>\n<p>目录结构如下所示</p>\n<ul>\n<li><strong>index.html</strong> ：入口文件</li>\n<li><strong>README.md</strong>：会做为主页内容渲染</li>\n<li><strong>.nojekyll</strong>：用于阻止 GitHub Pages 会忽略掉下划线开头的文件 (.后缀结尾的是隐藏文件)</li>\n</ul>\n<h2>启动</h2>\n<p>在我们使用 <strong>init</strong> 命令初始化一个文档后，我们需要通过下面命令<strong>运行一个本地服务器</strong></p>\n<pre><code class=\"language-bash\">docsify serve\n</code></pre>\n<p>项目启动后，默认访问 <a href=\"http://localhost:3000/\">http://localhost:3000</a> ，如下图所示，我们能够看到一个帮助文档的骨架了</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/12/26/1608970912104.png\" alt=\"启动成功截图\" /></p>\n<p>同时 <strong>docsify</strong> 还提供了 <strong>LiveReload</strong> 功能，也就是可以在我们修改文档后，能够<strong>实时预览</strong></p>\n<h2>修改Loading</h2>\n<p>初始化时会显示 <strong>Loading...</strong> 内容，你可以自定义提示信息，我们只需要修改 <strong>index.html</strong> 中的 <code>&lt;div id=\'app\'&gt;</code>标签即可，在里面加入我们需要的提示内容</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/12/26/1608970912332.png\" alt=\"加入loading\" /></p>\n<h3>定制侧边栏</h3>\n<p>默认情况下，侧边栏会根据当前文档的标题生成目录，也可以通过设置文档链接，通过Markdown文件生成，效果如当前的文件的侧边栏，首先我们在 <strong>index.html</strong> 里面进行设置</p>\n<pre><code>window.$docsify = {\n	loadSidebar: true, // 设置侧边栏\n}\n</code></pre>\n<p>然后新增一个markdown文件<code>_sidebar.md</code> , 下面就是我的侧边栏代码，其实是使用了超链接，每个目录都链接到我的目录下的markdown文件。</p>\n<pre><code class=\"language-markdown\">- [**蘑菇博客**](README.md)\n\n- **文档**\n\n  - [项目介绍](doc/文档/项目介绍.md)\n  - [技术选型](doc/文档/技术选型.md)\n  - 项目搭建\n    - [Windows环境下搭建蘑菇博客](doc/文档/项目搭建/Windows环境下搭建蘑菇博客/README.md)\n    - [Docker搭建蘑菇博客](doc/文档/项目搭建/Docker搭建蘑菇博客/README.md)\n    - [蘑菇博客部署到云服务器](doc/文档/项目搭建/蘑菇博客部署到云服务器/README.md)\n    - [Github Actions完成蘑菇博客持续集成](doc/文档/项目搭建/蘑菇博客使用GithubAction完成持续集成/README.md)\n    - [蘑菇博客切换搜索模式](doc/文档/项目搭建/蘑菇博客切换搜索模式/README.md)\n    - [蘑菇博客配置七牛云对象存储](doc/文档/项目搭建/蘑菇博客配置七牛云存储/README.md)\n    - [使用Zipkin搭建蘑菇博客链路追踪](doc/文档/项目搭建/使用Zipkin搭建蘑菇博客链路追踪/README.md)\n\n- **其他**\n\n  - [致谢](doc/文档/致谢.md)\n  - [将要做的事](doc/文档/将要做的事.md)\n  - [贡献代码](doc/文档/贡献代码.md)\n</code></pre>\n<p>效果图如下所示：</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/12/26/1608970912371.png\" alt=\"侧边栏\" /></p>\n<h2>显示页面目录</h2>\n<p>定制的侧边栏仅显示了页面的链接。还可以设置在侧边栏显示当前页面的目录(标题)。需要在 <code>index.html</code> 文件中的 <code>window.$docsify</code> 添加 <code>subMaxLevel</code> 字段来设置：</p>\n<pre><code class=\"language-bash\">window.$docsify = {\n    loadSidebar: true,\n    subMaxLevel: 3\n}\n</code></pre>\n<p>通过 <code>subMaxLevel</code> 来限制显示的标题等级，效果如下所示：</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/12/26/1608970912432.png\" alt=\"页面目录\" /></p>\n<p><strong>subMaxLevel</strong> 类型是 <strong>number</strong>(数字)，表示显示的目录层级</p>\n<p>**注意：**如果md文件中的第一个标题是一级标题，那么不会显示在侧边栏，如上图所示</p>\n<table>\n<thead>\n<tr><th>值</th><th>说明</th></tr>\n</thead>\n<tbody>\n<tr><td>0</td><td>默认值，表示不显示目录</td></tr>\n<tr><td>1</td><td>显示一级标题(<code>h1</code>)</td></tr>\n<tr><td>2</td><td>显示一、二级标题(<code>h1</code> ~ <code>h2</code>)</td></tr>\n<tr><td>3</td><td>显示一、二、三级标题(<code>h1</code> ~ <code>h3</code>)</td></tr>\n<tr><td>n</td><td>n是数字，显示一、二、....n 级标题(<code>h1</code> ~ <code>hn</code>)</td></tr>\n</tbody>\n</table>\n<h2>定制导航栏</h2>\n<p>首先需要在<code>index.html</code>文件中的<code>window.$docsify</code>添加<code>loadNavbar: true,</code>选项：</p>\n<pre><code class=\"language-bash\">window.$docsify = {\n	loadNavbar: true\n}\n</code></pre>\n<p>接着在项目根目录创建 <code>_navbar.md</code> 文件，内容格式如下：</p>\n<pre><code class=\"language-markdown\">- [Gitee](https://gitee.com/moxi159753/mogu_blog_v2)\n- [Github](https://github.com/moxi624/mogu_blog_v2)\n- [演示](http://moguit.cn/#/)\n</code></pre>\n<p><strong>注意</strong></p>\n<ul>\n<li>如果使用配置文件来设置导航栏，那么在<code>index.html</code>中定义的导航栏只有在定制的首页才会生效，其他页面会被覆盖。</li>\n<li>如果只在根目录有一个<code>_navbar.md</code>文件，那么所有页面都将使用这个一个配置，也就是所有页面的导航栏都一样。</li>\n<li>如果一个子目录中有<code>_navbar.md</code>文件，那么这个子目录下的所有页面将使用这个文件的导航栏。</li>\n<li><code>_navbar.md</code>的加载逻辑是从每层目录下获取文件，如果当前目录不存在该文件则回退到上一级目录。例如当前路径为<code>/zh-cn/more-pages</code>则从<code>/zh-cn/_navbar.md</code>获取文件，如果不存在则从<code>/_navbar.md</code>获取。</li>\n</ul>\n<h2>设置封面</h2>\n<p>docsify默认是没有封面的，默认有个首页<code>./README.md</code>。 通过设置<code>coverpage</code>参数，可以开启渲染封面的功能。首先需要在<code>index.html</code>文件中的<code>window.$docsify</code>添加<code>coverpage: true</code>选项：</p>\n<pre><code class=\"language-bash\">window.$docsify = {\n	coverpage: true\n}\n</code></pre>\n<p>接着在项目根目录创建<code>_coverpage.md</code>文件，内容格式如下：</p>\n<pre><code class=\"language-markdown\">&lt;img width=&quot;180px&quot; style=&quot;border-radius: 50%&quot; bor src=&quot;./doc/images/gitee/favicon2.ico&quot;&gt;\n\n# 蘑菇博客\n\n- 蘑菇博客，一个基于微服务架构的前后端分离博客系统。前台使用Vue + Element , 后端使用spring boot + spring cloud + mybatis-plus进行开发，使用 Jwt + Spring Security做登录验证和权限校验，使用ElasticSearch和Solr作为全文检索服务，使用Github Actions完成博客的持续集成，文件支持上传七牛云。\n\n[![star](https://gitee.com/moxi159753/mogu_blog_v2/badge/star.svg?theme=dark)](https://gitee.com/moxi159753/mogu_blog_v2/stargazers)\n[![fork](https://gitee.com/moxi159753/mogu_blog_v2/badge/fork.svg?theme=dark)](https://gitee.com/moxi159753/mogu_blog_v2/members)\n\n[Gitee](&lt;https://gitee.com/moxi159753/mogu_blog_v2&gt;)\n[Github](&lt;https://github.com/moxi624/mogu_blog_v2&gt;)\n[开始阅读](README.md)\n</code></pre>\n<p>效果图如下所示：</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/12/26/1608970912503.png\" alt=\"设置封面\" /></p>\n<p>在这里使用了两个 <strong>Gitee</strong> 挂件，可以在开源项目的挂件按钮那里获取</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/12/26/1608970912554.png\" alt=\"添加Gitee的挂件\" /></p>\n<p>**注意：**一份文档只会在根目录下加载封面，其他页面或者二级目录下都不会加载。</p>\n<h2>自定义封面背景</h2>\n<p>目前的背景是随机生成的渐变色，每次刷新都会显示不同的颜色。 docsify封面支持自定义背景色或者背景图，在<code>_coverpage.md</code>文档末尾添加：</p>\n<pre><code class=\"language-bash\">&lt;!-- 背景图片 --&gt;\n![](_media/bg.png)\n\n&lt;!-- 背景色 --&gt;\n![color](#2f4253)\n</code></pre>\n<p><strong>注意：</strong></p>\n<ul>\n<li>自定义背景配置一定要在<code>_coverpage.md</code>文档末尾。</li>\n<li>背景图片和背景色只能有一个生效.</li>\n<li>背景色一定要是<code>#2f4253</code>这种格式的。</li>\n</ul>\n<h2>封面作为首页</h2>\n<p>配置了封面后，封面和首页是同时出现的，封面在上面，首页在下面。通过设置<code>onlyCover</code>参数，可以让docsify网站首页只显示封面，原来的首页通过<code>http://localhost:3000/#/README</code>访问。在<code>index.html</code>文件中的<code>window.$docsify</code>添加<code>onlyCover: true,</code>选项：</p>\n<pre><code class=\"language-bash\">window.$docsify = {\n    coverpage: true,\n    onlyCover: true,\n}\n</code></pre>\n<p>通过此配置可以把<code>./README.md</code>文件独立出来，当成项目真正的README介绍文件</p>\n<h3>搜索插件</h3>\n<p>全文搜索插件会根据当前页面上的超链接获取文档内容，在 localStorage 内建立文档索引。默认过期时间为一天，当然我们可以自己指定需要缓存的文件列表或者配置过期时间。</p>\n<pre><code class=\"language-html\">&lt;script&gt;\n    window.$docsify = {\n      // 完整配置参数\n      search: {\n        maxAge: 86400000,               // 过期时间，单位毫秒，默认一天\n        paths: [],                      // or \'auto\'，匹配文件路径\n        placeholder: \'Type to search\',  // 搜索提示框文字， 支持本地化，例子在下面\n        // placeholder: {\n        //   \'/zh-cn/\': \'搜索\',\n        //   \'/\': \'Type to search\'\n        // },\n        noData: \'No Results!\',          // 找不到结果文字提示，支持本地化，例子在下面\n        // noData: {\n        //   \'/zh-cn/\': \'找不到结果\',\n        //   \'/\': \'No Results\'\n        // },\n        depth: 2,                       // 搜索标题的最大程级, 1 - 6\n      }\n    }\n  &lt;/script&gt;\n  &lt;!-- 引入搜索模块 --&gt;\n  &lt;script src=&quot;//unpkg.com/docsify/lib/plugins/search.js&quot;&gt;&lt;/script&gt;\n</code></pre>\n<p>安装后，我们就能够使用搜索功能了</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/12/26/1608970912582.png\" alt=\"加入搜索功能\" /></p>\n<h2>自定义域名</h2>\n<p>首先我们需要创建项目 <code>moxi624.github.io</code> ，第一个moxi624是你的用户名，然后我们在创建一个文件 <code>CNAME</code></p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/12/26/1608970912610.png\" alt=\"添加CNAME文件\" /></p>\n<p>里面添加我们需要自定义的域名</p>\n<pre><code class=\"language-bash\">doc.moguit.cn\n</code></pre>\n<p>然后把当前项目提交到 <strong>moxi624.github.io</strong> 远程项目，然后选择 <strong>settings</strong></p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/12/26/1608970912677.png\" alt=\"Github的Settings\" /></p>\n<p>然后找到 <strong>Github Pages</strong>，选择主分支 <strong>master</strong></p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/12/26/1608970912732.png\" alt=\"\" /></p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/12/26/1608970912794.png\" alt=\"设置Github Pages\" /></p>\n<p>完成后，我们能够看到这样的页面，说明我们的站点已经发布在 <strong>doc.moguit.cn</strong> 了</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/12/26/1608970912844.png\" alt=\"\" /></p>\n<p>这个时候就需要配置域名解析了，我们到阿里云下的域名解析</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/12/26/1608970912893.png\" alt=\"修改阿里云域名解析\" /></p>\n<p>注意，这边 <strong>moxi624.github.io</strong> 就是我们刚刚创建的仓库名</p>\n<p>创建完成后，我们等待十分钟后，就能够正常访问我们的页面了~</p>\n<h2>评论插件Gitalk</h2>\n<p><strong>Gitalk</strong>：一个现代化的，基于 <strong>Preact</strong> 和 <strong>Github issue</strong> 的评论系统。<strong>Gitalk</strong> 的特性如下：</p>\n<ul>\n<li>使用 <strong>GitHub</strong> 登录</li>\n<li>支持多语言 <strong>[en, zh-CN, zh-TW, es-ES, fr, ru]</strong></li>\n<li>支持个人或组织</li>\n<li>无干扰模式（设置 <strong>distractionFreeMode</strong> 为 <strong>true</strong> 开启）</li>\n<li>快捷键提交评论 （<strong>cmd</strong>|<strong>ctrl + enter</strong>）</li>\n</ul>\n<p>使用例子：</p>\n<pre><code class=\"language-bash\">&lt;!-- 引入 gitalk留言功能 --&gt;\n&lt;link rel=&quot;stylesheet&quot; href=&quot;//unpkg.com/gitalk/dist/gitalk.css&quot;&gt;\n&lt;script src=&quot;//unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;//unpkg.com/docsify/lib/plugins/gitalk.min.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n  const gitalk = new Gitalk({\n    clientID: \'XXXXXXXXXXXXXXXXXXXX\',\n    clientSecret: \'XXXXXXXXXXXXXXXX\',\n    repo: \'XXXXXXXXXXXXXX\', // 存放评论的仓库\n    owner: \'XXXXX\', // 仓库的创建者\n    admin: [\'XXXXX\'], // 如果仓库有多个人可以操作，那么在这里以数组形式写出\n    id: location.pathname, // 用于标记评论是哪个页面的\n  })\n&lt;/script&gt;\n</code></pre>\n<p>其中我们首先需要到 <strong>Github Settings</strong> 中，创建一个 <strong>New OAuth App</strong></p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/12/26/1608970913014.png\" alt=\"添加一个Oauth Apps\" /></p>\n<p>然后添加如下内容</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/12/26/1608970913077.png\" alt=\"填写内容\" /></p>\n<p>创建完成后，在复制我们的密钥，替换上面的 <strong>clientID</strong> 和 <strong>clientSecret</strong></p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/12/26/1608970913103.png\" alt=\"获取密钥\" /></p>\n<p>最终，在页面引入 <strong>Gittalk</strong> 的效果图</p>\n<p><img src=\"http://localhost:8600//blog/admin/png/2020/12/26/1608970913154.png\" alt=\"引入后的效果\" /></p>\n<p>到此为止，蘑菇博客的开源文档就已经完成了，后续只需要不断加入文章完善即可。</p>\n<h2>结语</h2>\n<p><strong>陌溪</strong>是一个从三本院校一路摸滚翻爬上来的互联网大厂程序员。独立做过几个开源项目，其中<strong>蘑菇博客</strong>在码云上有 <strong>2K Star</strong> 。目前就职于<strong>字节跳动的Data广告部门</strong>，是字节跳动全线产品的商业变现研发团队。本公众号将会持续性的输出很多原创小知识以及学习资源。如果你觉得本文对你有所帮助，麻烦给文章点个「<font color=\\#00BFFF>赞</font>」和「<font color=\\#00BFFF>在看</font>」。同时欢迎各位小伙伴关注陌溪，让我们一起成长~</p>\n<p><img src=\"http://localhost:8600//blog/admin/jpg/2020/12/26/1608970912276.jpg\" alt=\"图片\" /></p>\n<center>\n    <font face=\"黑体\" color=#F08080 size=5>“种树的最好时间是十年前，其次是现在”</font>\n</center>\n', '5626932d452c2ad863d9b3cb0b69d22d', 0, 0, 'd134bdfe255b9aa8c2ce44da8297f6a6', 1, '2020-12-26 16:22:11', '2020-12-26 16:22:11', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '0', 0, 1, 0, NULL, 35, NULL, 0);
INSERT INTO `t_blog` VALUES ('f941246ea08539af0f9c068323b76e44', '新增博客1', '新增博客1', '<p>新增博客1</p>\n', '7e0e93ea6cdb44ae92e58f48e6496ed7', 0, 0, '90dd6ac4d3e000b8ea2f7162201d6ace', 1, '2020-12-08 21:16:49', '2020-12-08 21:16:49', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '1', 0, 1, 0, NULL, 29, NULL, 0);
INSERT INTO `t_blog` VALUES ('fc6fc52465a2797090a6ac8b09994d91', '测试', '测试', '<blockquote>\n<p>go测试</p>\n</blockquote>\n<pre><code class=\"language-go\">package main\n\nimport (\n	&quot;context&quot;\n	&quot;fmt&quot;\n	&quot;go.etcd.io/etcd/clientv3&quot;\n	&quot;time&quot;\n)\n\nfunc main() {\n	cli, err := clientv3.New(clientv3.Config {\n		Endpoints: []string{&quot;127.0.0.1:2379&quot;}, // etcd的节点，可以传入多个\n		DialTimeout: 5*time.Second, // 连接超时时间\n	})\n\n	if err != nil {\n		fmt.Printf(&quot;connect to etcd failed, err: %v \\n&quot;, err)\n		return\n	}\n	fmt.Println(&quot;connect to etcd success&quot;)\n\n	// 延迟关闭\n	defer cli.Close()\n\n	// put操作  设置1秒超时\n	ctx, cancel := context.WithTimeout(context.Background(), time.Second)\n	_, err = cli.Put(ctx, &quot;moxi&quot;, &quot;lalala&quot;)\n	cancel()\n	if err != nil {\n		fmt.Printf(&quot;put to etcd failed, err:%v \\n&quot;, err)\n		return\n	}\n\n	// get操作，设置1秒超时\n	ctx, cancel = context.WithTimeout(context.Background(), time.Second)\n	resp, err := cli.Get(ctx, &quot;q1mi&quot;)\n	cancel()\n	if err != nil {\n		fmt.Printf(&quot;get from etcd failed, err:%v \\n&quot;, err)\n		return\n	}\n	fmt.Println(resp)\n}\n\n\n\n\n\n\n\n</code></pre>\n<h3 id=\"测试\">测试</h3>\n<p>今天我们在做啥呢</p>\n<p>我觉得还不错呢？</p>\n', '7e0e93ea6cdb44ae92e58f48e6496ed7', 2, 0, '3dab9866f9ac1867d3845918d4b5b748', 0, '2020-09-14 16:41:10', '2020-10-07 16:31:58', '1f01cd1d2f474743b241d74008b12333', '1', '陌溪', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 2, '1', 0, 1, 0, NULL, 26, NULL, 0);
INSERT INTO `t_blog` VALUES ('ff066da5adfb6834cb8089cd5bcb3d32', 'README', 'README', '<h2>前言</h2>\n<p>今天有个热心的小伙伴，通过 <strong>MySQL</strong> 图形化管理工具 <strong>SQLyog</strong> 进行远程数据库连接，成功进入了 <strong>蘑菇博客</strong> 的生产环境数据库。然后在博客数据表中增加一个<strong>超级管理员</strong>账号，最后通过新创建的超级管理员，在蘑菇博客后台转悠了一圈，然后进入蘑菇博客交流群和我反馈了这个 <strong>BUG</strong> ，在这里首先感谢这位小伙伴的<strong>不删库之恩</strong> ....</p>\n<h2>问题缘由</h2>\n<p>问题出现的原因，是因为蘑菇博客生产环境的数据库使用的远程登录密码为 <strong>默认密码(mogu2018)</strong> 。也就是说，当我们在 <strong>Linux</strong> 服务器中，使用下面的命令进行数据库连接</p>\n<pre><code class=\"language-bash\"># 连接mysql\nmysql -u root -p\n# 输入密码\nmogu2020\n</code></pre>\n<p>发现使用密码： <strong>mogu2020</strong> ，能够成功在服务器上登录MySQL</p>\n<p><img src=\"http://localhost:8600//blog/admin/jpg/2021/2/22/1613965213535.jpg\" alt=\"命令行方式进入MySQL\" /></p>\n<p>然后我们在通过 <strong>SQLyog</strong> 进行测试，我们输入密码  <strong>mogu2018</strong></p>\n<p><img src=\"http://localhost:8600//blog/admin/jpg/2021/2/22/1613965213657.jpg\" alt=\"通过SQLyog远程连接MySQL\" /></p>\n<p>发现也能够成功登录系统！问题就出在这里呢，我以为我把密码改成了 <strong>mogu2020</strong>  ，但是其他小伙伴如果使用远程工具，还可以继续使用 <strong>mogu2018</strong> 进行登录</p>\n<h2>解决方案</h2>\n<p>首先这个问题出现的原因，是因为<strong>远程连接的密码</strong>和<strong>本地连接的密码</strong>不一致引起的，也就是说我在部署完 <strong>MySQL</strong> 后，只修改了一个所引起的，首先我们查询 <strong>mysql</strong> 用户</p>\n<pre><code class=\"language-bash\"># 登录mysql\nmysql -u root -p\n\n# 使用mysql数据库\nuse mysql\n\n# 查询mysql用户\nselect user, host from mysql.user;\n</code></pre>\n<p>我们能够发现有4个用户</p>\n<p><img src=\"http://localhost:8600//blog/admin/jpg/2021/2/22/1613965213384.jpg\" alt=\"查询mysql的连接用户\" /></p>\n<p>其中 <strong>host</strong> 为 <strong>%</strong> 的表示是远程连接用户，而 <strong>localhost</strong> 和 <strong>127.0.0.1</strong> 都是本地用户，下面的配置就是蘑菇博客在线上的配置</p>\n<pre><code class=\"language-yaml\">  datasource:\n    username: root\n    password: mogu2020\n    url: jdbc:mysql://localhost:3306/mogu_admin\n</code></pre>\n<p>因为 <strong>MySQL</strong> 和项目是在同一个云服务器中，所以直接通过 localhost，即可连接。</p>\n<p>而我们在 <strong>Windows</strong> 上通过 <strong>SQLyog</strong> 远程连接我们的云服务器，就只能通过 <strong>%</strong> 用户进行连接了，现在我们要做的是修改 <strong>%</strong> 用户(也远程连接用户) 的 密码即可。</p>\n<pre><code class=\"language-bash\"># 修改密码，改成 mogu2020\nGRANT ALL PRIVILEGES ON *.* TO \'root\'@\'%\'IDENTIFIED BY \'mogu2020\' WITH GRANT OPTION;\n\n# 刷新\nflush privileges;\n</code></pre>\n<p>修改完密码后，<strong>SQLyog</strong> 远程连接通过 <strong>mogu2018</strong> 无法登录了，正所谓亡羊补牢，为时不晚。因为之前修改密码的时候，只修改了 <strong>localhost</strong> 的，而没有修改%的，而导致这个问题的出现，最后再次感谢热心的小伙伴发现这个问题，以及小伙伴的不删库之恩~</p>\n<h2>结语</h2>\n<p><strong>陌溪</strong>是一个从三本院校一路摸滚翻爬上来的互联网大厂程序员。独立做过几个开源项目，其中<strong>蘑菇博客</strong>在码云上有 <strong>2K Star</strong> 了。目前就职于<strong>字节跳动的Data广告部门</strong>，是字节跳动全线产品的商业变现研发团队。同时本公众号将会持续性的输出很多原创小知识以及学习资源。欢迎各位小伙伴关注陌溪，让我们一起成长~</p>\n<p><img src=\"http://localhost:8600//blog/admin/jpg/2021/2/22/1613965213598.jpg\" alt=\"和陌溪一起学编程\" /></p>\n', '5626932d452c2ad863d9b3cb0b69d22d', 0, 0, 'd134bdfe255b9aa8c2ce44da8297f6a6', 1, '2021-02-22 11:40:27', '2021-02-22 11:40:27', '1f01cd1d2f474743b241d74008b12333', '1', 'admin', '蘑菇博客', 'a03d7290b1c04b6eaf46659661b47032', 0, '0', 0, 1, 0, NULL, 48, NULL, 0);

SET FOREIGN_KEY_CHECKS = 1;
